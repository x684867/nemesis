<html lang="en">
<head>
<title>GnuTLS 3.0.9</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GnuTLS 3.0.9">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual is last updated 25 November 2011 for version
3.0.9 of GnuTLS.

Copyright (C) 2001-2011 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled "GNU Free Documentation License".
-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
body { 
	margin: 2%;
	padding: 0 5%;
	background: #ffffff;
}
h1,h2,h3,h4,h5 {
    font-weight: bold;
    padding: 5px 5px 5px 5px;
    background-color: #c2e0ff;
    color: #336699;
}
h1 {
    padding: 2em 2em 2em 5%;
    color: white;
    background: #336699;
    text-align: center;
    letter-spacing: 3px;
}
h2 { text-decoration: underline; }
pre {
  margin: 0 5%;
  padding: 0.5em;
}
pre.example {
  border: solid 1px;
  background: #eeeeff;
  padding-bottom: 1em;
}
pre.verbatim {
  border: solid 1px gray;
  background: white;
  padding-bottom: 1em;
}
div.node {
  margin: 0 -5% 0 -2%;
  padding: 0.5em 0.5em;
  margin-top: 0.5em;
  margin-bottom: 0.5em;
  font-weight: bold;
}
dd, li {
  padding-top: 0.1em;
  padding-bottom: 0.1em;
}
--></style>
</head>
<body>
<h1 class="settitle">GnuTLS 3.0.9</h1>
<div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">GnuTLS</a>
<li><a name="toc_Preface" href="#Preface">1 Preface</a>
<li><a name="toc_Introduction-to-GnuTLS" href="#Introduction-to-GnuTLS">2 Introduction to GnuTLS</a>
<ul>
<li><a href="#GnuTLS-introduction">2.1 Introduction</a>
<li><a href="#Downloading-and-installing">2.2 Downloading and installing</a>
<li><a href="#Document-overview">2.3 Overview</a>
</li></ul>
<li><a name="toc_Introduction-to-TLS" href="#Introduction-to-TLS">3 Introduction to <acronym>TLS</acronym> and <acronym>DTLS</acronym></a>
<ul>
<li><a href="#TLS-layers">3.1 TLS layers</a>
<li><a href="#The-transport-layer">3.2 The transport layer</a>
<li><a href="#The-TLS-record-protocol">3.3 The TLS record protocol</a>
<ul>
<li><a href="#Encryption-algorithms-used-in-the-record-layer">3.3.1 Encryption algorithms used in the record layer</a>
<li><a href="#Compression-algorithms-used-in-the-record-layer">3.3.2 Compression algorithms used in the record layer</a>
<li><a href="#Weaknesses-and-countermeasures">3.3.3 Weaknesses and countermeasures</a>
<li><a href="#On-Record-Padding">3.3.4 On record padding</a>
</li></ul>
<li><a href="#The-TLS-Alert-Protocol">3.4 The TLS alert protocol</a>
<li><a href="#The-TLS-Handshake-Protocol">3.5 The TLS handshake protocol</a>
<ul>
<li><a href="#TLS-Cipher-Suites">3.5.1 TLS ciphersuites</a>
<li><a href="#Authentication">3.5.2 Authentication</a>
<li><a href="#Client-Authentication">3.5.3 Client authentication</a>
<li><a href="#Resuming-Sessions">3.5.4 Resuming sessions</a>
</li></ul>
<li><a href="#TLS-Extensions">3.6 TLS extensions</a>
<ul>
<li><a href="#Maximum-fragment-length-negotiation">3.6.1 Maximum fragment length negotiation</a>
<li><a href="#Server-name-indication">3.6.2 Server name indication</a>
<li><a href="#Session-tickets">3.6.3 Session tickets</a>
<li><a href="#Safe-renegotiation">3.6.4 Safe renegotiation</a>
</li></ul>
<li><a href="#How-to-use-TLS-in-application-protocols">3.7 How to use <acronym>TLS</acronym> in application protocols</a>
<ul>
<li><a href="#Separate-ports">3.7.1 Separate ports</a>
<li><a href="#Upward-negotiation">3.7.2 Upward negotiation</a>
</li></ul>
<li><a href="#On-SSL-2-and-older-protocols">3.8 On SSL 2 and older protocols</a>
</li></ul>
<li><a name="toc_Certificate-authentication" href="#Certificate-authentication">4 Certificate authentication</a>
<ul>
<li><a href="#Introduction">4.1 Introduction</a>
<li><a href="#X_002e509-certificates">4.2 <acronym>X.509</acronym> certificates</a>
<ul>
<li><a href="#X_002e509-certificate-structure">4.2.1 <acronym>X.509</acronym> certificate structure</a>
<li><a href="#Verifying-X_002e509-certificate-paths">4.2.2 Verifying <acronym>X.509</acronym> certificate paths</a>
<li><a href="#Verifying-a-certificate-in-the-context-of-TLS-session">4.2.3 Verifying a certificate in the context of TLS session</a>
</li></ul>
<li><a href="#OpenPGP-certificates">4.3 <acronym>OpenPGP</acronym> certificates</a>
<ul>
<li><a href="#OpenPGP-certificates">4.3.1 <acronym>OpenPGP</acronym> certificate structure</a>
<li><a href="#OpenPGP-certificates">4.3.2 Verifying an <acronym>OpenPGP</acronym> certificate</a>
<li><a href="#OpenPGP-certificates">4.3.3 Verifying a certificate in the context of a TLS session</a>
</li></ul>
<li><a href="#Digital-signatures">4.4 Digital signatures</a>
<ul>
<li><a href="#Digital-signatures">4.4.1 Trading security for interoperability</a>
</li></ul>
</li></ul>
<li><a name="toc_Shared_002dkey-and-anonymous-authentication" href="#Shared_002dkey-and-anonymous-authentication">5 Shared-key and anonymous authentication</a>
<ul>
<li><a href="#SRP-authentication">5.1 SRP authentication</a>
<ul>
<li><a href="#Authentication-using-SRP">5.1.1 Authentication using <acronym>SRP</acronym></a>
<li><a href="#Invoking-srptool">5.1.2 Invoking srptool</a>
</li></ul>
<li><a href="#PSK-authentication">5.2 PSK authentication</a>
<ul>
<li><a href="#Authentication-using-PSK">5.2.1 Authentication using <acronym>PSK</acronym></a>
<li><a href="#Invoking-psktool">5.2.2 Invoking psktool</a>
</li></ul>
<li><a href="#Anonymous-authentication">5.3 Anonymous authentication</a>
</li></ul>
<li><a name="toc_More-on-certificate-authentication" href="#More-on-certificate-authentication">6 More on certificate authentication</a>
<ul>
<li><a href="#PKCS-10-certificate-requests">6.1 <acronym>PKCS</acronym> #10 certificate requests</a>
<li><a href="#PKIX-certificate-revocation-lists">6.2 PKIX certificate revocation lists</a>
<li><a href="#Managing-encrypted-keys">6.3 Managing encrypted keys</a>
<li><a href="#The-certtool-application">6.4 The certtool application</a>
<li><a href="#Hardware-tokens">6.5 Security modules</a>
<ul>
<li><a href="#Introduction-on-security-modules">6.5.1 Introduction</a>
<li><a href="#PKCS11-Initialization">6.5.2 Initialization</a>
<li><a href="#Reading-objects">6.5.3 Reading objects</a>
<li><a href="#Writing-objects">6.5.4 Writing objects</a>
<li><a href="#Using-a-PKCS11-token-with-TLS">6.5.5 Using a <acronym>PKCS</acronym> #11 token with TLS</a>
<li><a href="#The-p11tool-application">6.5.6 The p11tool application</a>
</li></ul>
<li><a href="#Abstract-key-types">6.6 Abstract key types</a>
<ul>
<li><a href="#Abstract-public-keys">6.6.1 Public keys</a>
<li><a href="#Abstract-private-keys">6.6.2 Private keys</a>
<li><a href="#Operations">6.6.3 Operations</a>
</li></ul>
</li></ul>
<li><a name="toc_How-to-use-GnuTLS-in-applications" href="#How-to-use-GnuTLS-in-applications">7 How to use <acronym>GnuTLS</acronym> in applications</a>
<ul>
<li><a href="#Introduction-to-the-library">7.1 Introduction</a>
<ul>
<li><a href="#General-idea">7.1.1 General idea</a>
<li><a href="#Error-handling">7.1.2 Error handling</a>
<li><a href="#Debugging-and-auditing">7.1.3 Debugging and auditing</a>
<li><a href="#Thread-safety">7.1.4 Thread safety</a>
<li><a href="#Callback-functions">7.1.5 Callback functions</a>
</li></ul>
<li><a href="#Preparation">7.2 Preparation</a>
<ul>
<li><a href="#Headers">7.2.1 Headers</a>
<li><a href="#Initialization">7.2.2 Initialization</a>
<li><a href="#Version-check">7.2.3 Version check</a>
<li><a href="#Building-the-source">7.2.4 Building the source</a>
</li></ul>
<li><a href="#Session-initialization">7.3 Session initialization</a>
<li><a href="#Associating-the-credentials">7.4 Associating the credentials</a>
<ul>
<li><a href="#Certificate-credentials">7.4.1 Certificates</a>
<li><a href="#SRP-credentials">7.4.2 SRP</a>
<li><a href="#PSK-credentials">7.4.3 PSK</a>
<li><a href="#Anonymous-credentials">7.4.4 Anonymous</a>
</li></ul>
<li><a href="#Setting-up-the-transport-layer">7.5 Setting up the transport layer</a>
<ul>
<li><a href="#Asynchronous-operation">7.5.1 Asynchronous operation</a>
<li><a href="#DTLS-sessions">7.5.2 DTLS sessions</a>
</li></ul>
<li><a href="#TLS-handshake">7.6 TLS handshake</a>
<li><a href="#Data-transfer-and-termination">7.7 Data transfer and termination</a>
<li><a href="#Priority-Strings">7.8 Priority strings</a>
<li><a href="#Advanced-and-other-topics">7.9 Advanced and other topics</a>
<ul>
<li><a href="#Session-resumption">7.9.1 Session resumption</a>
<li><a href="#Parameter-generation">7.9.2 Parameter generation</a>
<li><a href="#Keying-Material-Exporters">7.9.3 Keying material exporters</a>
<li><a href="#Channel-Bindings">7.9.4 Channel bindings</a>
<li><a href="#Interoperability">7.9.5 Interoperability</a>
<li><a href="#Compatibility-with-the-OpenSSL-library">7.9.6 Compatibility with the OpenSSL library</a>
</li></ul>
<li><a href="#Using-the-cryptographic-library">7.10 Using the cryptographic library</a>
<ul>
<li><a href="#Symmetric-cryptography">7.10.1 Symmetric cryptography</a>
<li><a href="#Hash-and-HMAC-functions">7.10.2 Hash and HMAC functions</a>
<li><a href="#Random-number-generation">7.10.3 Random number generation</a>
</li></ul>
<li><a href="#Selecting-cryptographic-key-sizes">7.11 Selecting cryptographic key sizes</a>
</li></ul>
<li><a name="toc_GnuTLS-application-examples" href="#GnuTLS-application-examples">8 GnuTLS application examples</a>
<ul>
<li><a href="#Client-examples">8.1 Client examples</a>
<ul>
<li><a href="#Simple-client-example-with-anonymous-authentication">8.1.1 Simple client example with anonymous authentication</a>
<li><a href="#Simple-client-example-with-X_002e509-certificate-support">8.1.2 Simple client example with <acronym>X.509</acronym> certificate support</a>
<li><a href="#Simple-Datagram-TLS-client-example">8.1.3 Simple datagram <acronym>TLS</acronym> client example</a>
<li><a href="#Obtaining-session-information">8.1.4 Obtaining session information</a>
<li><a href="#Using-a-callback-to-select-the-certificate-to-use">8.1.5 Using a callback to select the certificate to use</a>
<li><a href="#Verifying-a-certificate">8.1.6 Verifying a certificate</a>
<li><a href="#Client-using-a-PKCS-11-token-with-TLS">8.1.7 Using a <acronym>PKCS</acronym> #11 token with TLS</a>
<li><a href="#Client-with-Resume-capability-example">8.1.8 Client with resume capability example</a>
<li><a href="#Simple-client-example-with-SRP-authentication">8.1.9 Simple client example with <acronym>SRP</acronym> authentication</a>
<li><a href="#Simple-client-example-in-C_002b_002b">8.1.10 Simple client example using the C++ API</a>
<li><a href="#Helper-function-for-TCP-connections">8.1.11 Helper function for TCP connections</a>
</li></ul>
<li><a href="#Server-examples">8.2 Server examples</a>
<ul>
<li><a href="#Echo-Server-with-X_002e509-authentication">8.2.1 Echo server with <acronym>X.509</acronym> authentication</a>
<li><a href="#Echo-Server-with-OpenPGP-authentication">8.2.2 Echo server with <acronym>OpenPGP</acronym> authentication</a>
<li><a href="#Echo-Server-with-SRP-authentication">8.2.3 Echo server with <acronym>SRP</acronym> authentication</a>
<li><a href="#Echo-Server-with-anonymous-authentication">8.2.4 Echo Server with anonymous authentication</a>
</li></ul>
<li><a href="#Miscellaneous-examples">8.3 Miscellaneous examples</a>
<ul>
<li><a href="#Checking-for-an-alert">8.3.1 Checking for an alert</a>
<li><a href="#X_002e509-certificate-parsing-example">8.3.2 <acronym>X.509</acronym> certificate parsing example</a>
</li></ul>
</li></ul>
<li><a name="toc_Other-included-programs" href="#Other-included-programs">9 Other included programs</a>
<ul>
<li><a href="#The-gnutls_002dcli-tool">9.1 The gnutls-cli tool</a>
<ul>
<li><a href="#Example-client-PSK-connection">9.1.1 Example client PSK connection</a>
</li></ul>
<li><a href="#The-gnutls_002dserv-tool">9.2 The gnutls-serv tool</a>
<ul>
<li><a href="#Setting-up-a-test-HTTPS-server">9.2.1 Setting up a test HTTPS server</a>
</li></ul>
<li><a href="#The-gnutls_002dcli_002ddebug-tool">9.3 The gnutls-cli-debug tool</a>
</li></ul>
<li><a name="toc_Internal-architecture-of-GnuTLS" href="#Internal-architecture-of-GnuTLS">10 Internal Architecture of GnuTLS</a>
<ul>
<li><a href="#The-TLS-Protocol">10.1 The TLS Protocol</a>
<li><a href="#TLS-Handshake-Protocol">10.2 TLS Handshake Protocol</a>
<li><a href="#TLS-Authentication-Methods">10.3 TLS Authentication Methods</a>
<li><a href="#TLS-Extension-Handling">10.4 TLS Extension Handling</a>
<ul>
<li><a href="#Adding-a-new-TLS-extension">10.4.1 Adding a new TLS extension</a>
</li></ul>
<li><a href="#Cryptographic-Backend">10.5 Cryptographic Backend</a>
<ul>
<li><a href="#Cryptographic-Backend">10.5.1 Cryptographic library layer</a>
<li><a href="#Cryptographic-Backend">10.5.2 External cryptography provider</a>
</li></ul>
</li></ul>
<li><a name="toc_Support" href="#Support">Appendix A Support</a>
<ul>
<li><a href="#Getting-help">A.1 Getting Help</a>
<li><a href="#Commercial-Support">A.2 Commercial Support</a>
<li><a href="#Bug-Reports">A.3 Bug Reports</a>
<li><a href="#Contributing">A.4 Contributing</a>
</li></ul>
<li><a name="toc_Error-codes" href="#Error-codes">Appendix B Error Codes and Descriptions</a>
<li><a name="toc_API-reference" href="#API-reference">Appendix C API reference</a>
<ul>
<li><a href="#Core-TLS-API">C.1 Core TLS API</a>
<li><a href="#Datagram-TLS-API">C.2 Datagram TLS API</a>
<li><a href="#X509-certificate-API">C.3 <acronym>X.509</acronym> certificate API</a>
<li><a href="#OpenPGP-API">C.4 <acronym>OpenPGP</acronym> API</a>
<li><a href="#PKCS-12-API">C.5 PKCS 12 API</a>
<li><a href="#PKCS-11-API">C.6 Hardware token via PKCS 11 API</a>
<li><a href="#Abstract-key-API">C.7 Abstract key API</a>
<li><a href="#Cryptographic-API">C.8 Cryptographic API</a>
<li><a href="#Compatibility-API">C.9 Compatibility API</a>
</li></ul>
<li><a name="toc_Supported-ciphersuites-in-GnuTLS" href="#Supported-ciphersuites-in-GnuTLS">Appendix D Supported Ciphersuites in <acronym>GnuTLS</acronym></a>
<li><a name="toc_Copying-Information" href="#Copying-Information">Appendix E Copying Information</a>
<ul>
<li><a href="#GNU-Free-Documentation-License">E.1 GNU Free Documentation License</a>
</li></ul>
<li><a name="toc_Bibliography" href="#Bibliography">Bibliography</a>
<li><a name="toc_Function-and-Data-Index" href="#Function-and-Data-Index">Function and Data Index</a>
<li><a name="toc_Concept-Index" href="#Concept-Index">Concept Index</a>
</li></ul>
</div>



<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Preface">Preface</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">GnuTLS</h2>

<p>This manual is last updated 25 November 2011 for version
3.0.9 of GnuTLS.

<p>Copyright &copy; 2001-2011 Free Software Foundation, Inc.

<blockquote>
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled &ldquo;GNU Free
Documentation License&rdquo;. 
</blockquote>

<ul class="menu">
<li><a accesskey="1" href="#Preface">Preface</a>
<li><a accesskey="2" href="#Introduction-to-GnuTLS">Introduction to GnuTLS</a>
<li><a accesskey="3" href="#Introduction-to-TLS">Introduction to TLS</a>
<li><a accesskey="4" href="#Certificate-authentication">Certificate authentication</a>
<li><a accesskey="5" href="#Shared_002dkey-and-anonymous-authentication">Shared-key and anonymous authentication</a>
<li><a accesskey="6" href="#More-on-certificate-authentication">More on certificate authentication</a>
<li><a accesskey="7" href="#How-to-use-GnuTLS-in-applications">How to use GnuTLS in applications</a>
<li><a accesskey="8" href="#GnuTLS-application-examples">GnuTLS application examples</a>
<li><a accesskey="9" href="#Other-included-programs">Other included programs</a>
<li><a href="#Internal-architecture-of-GnuTLS">Internal architecture of GnuTLS</a>
<li><a href="#Support">Support</a>
<li><a href="#Error-codes">Error codes</a>
<li><a href="#API-reference">API reference</a>
<li><a href="#Supported-ciphersuites-in-GnuTLS">Supported ciphersuites in GnuTLS</a>
<li><a href="#Copying-Information">Copying Information</a>
<li><a href="#Concept-Index">Concept Index</a>
<li><a href="#Function-and-Data-Index">Function and Data Index</a>
<!-- * @mybibnode{}:: -->
<li><a href="#Bibliography">Bibliography</a>
</ul>

<div class="node">
<a name="Preface"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Introduction-to-GnuTLS">Introduction to GnuTLS</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 Preface</h2>

<p>This document demonstrates and explains the <acronym>GnuTLS</acronym>
library API.  A brief introduction to the protocols and the technology
involved is also included so that an application programmer can
better understand the <acronym>GnuTLS</acronym> purpose and actual offerings. 
Even if <acronym>GnuTLS</acronym> is a typical library software, it operates
over several security and cryptographic protocols which require the
programmer to make careful and correct usage of them. Otherwise it
is likely to only obtain a false sense of security. 
The term of security is very broad even if restricted to computer
software, and cannot be confined to a single cryptographic
library.  For that reason, do not consider any program secure just
because it uses <acronym>GnuTLS</acronym>; there are several ways to compromise
a program or a communication line and <acronym>GnuTLS</acronym> only helps with
some of them.

<p>Although this document tries to be self contained, basic network
programming and public key infrastructure (PKI) knowledge is assumed
in most of it. A good introduction to networking can be found
in [<em>STEVENS</em>], to public key infrastructure in [<em>GUTPKI</em>]
and to security engineering in [<em>ANDERSON</em>].

<p>Updated versions of the <acronym>GnuTLS</acronym> software and this document
will be available from <a href="http://www.gnutls.org/">http://www.gnutls.org/</a> and
<a href="http://www.gnu.org/software/gnutls/">http://www.gnu.org/software/gnutls/</a>.

<div class="node">
<a name="Introduction-to-GnuTLS"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Introduction-to-TLS">Introduction to TLS</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Preface">Preface</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 Introduction to GnuTLS</h2>

<ul class="menu">
<li><a accesskey="1" href="#GnuTLS-introduction">GnuTLS introduction</a>
<li><a accesskey="2" href="#Downloading-and-installing">Downloading and installing</a>
<li><a accesskey="3" href="#Document-overview">Document overview</a>
</ul>

<div class="node">
<a name="GnuTLS-introduction"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Downloading-and-installing">Downloading and installing</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction-to-GnuTLS">Introduction to GnuTLS</a>

</div>

<h3 class="section">2.1 Introduction</h3>

<p>In brief <acronym>GnuTLS</acronym> can be described as a library which offers an API
to access secure communication protocols. These protocols provide
privacy over insecure lines, and were designed to prevent
eavesdropping, tampering, or message forgery.

<p>Technically <acronym>GnuTLS</acronym> is a portable ANSI C based library which
implements the protocols ranging from SSL 3.0 to TLS 1.2 (see <a href="#Introduction-to-TLS">Introduction to TLS</a>,
for a detailed description of the protocols), accompanied
with the required framework for authentication and public key
infrastructure.  Important features of the <acronym>GnuTLS</acronym> library
include:

     <ul>
<li>Support for TLS 1.2, TLS 1.1, TLS 1.0 and SSL 3.0 protocols.

     <li>Support for Datagram TLS 1.0.

     <li>Support for handling and verification of <acronym>X.509</acronym> and <acronym>OpenPGP</acronym> certificates.

     <li>Support for password authentication using <acronym>TLS-SRP</acronym>.

     <li>Support for keyed authentication using <acronym>TLS-PSK</acronym>.

     <li>Support for <acronym>PKCS</acronym> #11 tokens and smart-cards.

</ul>

<p>The <acronym>GnuTLS</acronym> library consists of three independent parts, namely the &ldquo;TLS
protocol part&rdquo;, the &ldquo;Certificate part&rdquo;, and the &ldquo;Cryptographic
back-end&rdquo; part.  The &ldquo;TLS protocol part&rdquo; is the actual protocol
implementation, and is entirely implemented within the
<acronym>GnuTLS</acronym> library.  The &ldquo;Certificate part&rdquo; consists of the
certificate parsing, and verification functions and it uses
functionality from the
libtasn1<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a> library. 
The &ldquo;Cryptographic back-end&rdquo; is provided by the nettle<a rel="footnote" href="#fn-2" name="fnd-2"><sup>2</sup></a>
library.

<div class="node">
<a name="Downloading-and-installing"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Document-overview">Document overview</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#GnuTLS-introduction">GnuTLS introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction-to-GnuTLS">Introduction to GnuTLS</a>

</div>

<h3 class="section">2.2 Downloading and installing</h3>

<p><a name="index-installation-1"></a><a name="index-download-2"></a>
GnuTLS is available for download at:
<a href="http://www.gnutls.org/download.html">http://www.gnutls.org/download.html</a>

<p>GnuTLS uses a development cycle where even minor version numbers
indicate a stable release and a odd minor version number indicate a
development release.  For example, GnuTLS 1.6.3 denote a stable
release since 6 is even, and GnuTLS 1.7.11 denote a development
release since 7 is odd.

<p>GnuTLS depends on Libnettle, and you will need to install it
before installing GnuTLS.  Libnettle is available from
<a href="http://www.lysator.liu.se/~nisse/nettle/">http://www.lysator.liu.se/~nisse/nettle/</a>. 
Don't forget to verify the cryptographic signature after downloading
source code packages.

<p>The package is then extracted, configured and built like many other
packages that use Autoconf.  For detailed information on configuring
and building it, refer to the <samp><span class="file">INSTALL</span></samp> file that is part of the
distribution archive.  Typically you invoke <code>./configure</code> and
then <code>make check install</code>.  There are a number of compile-time
parameters, as discussed below.

<p>The compression library, libz, as well as p11-kit are a optional dependencies. 
You can get libz from <a href="http://www.zlib.net/">http://www.zlib.net/</a> and p11-kit from <a href="http://p11-glue.freedesktop.org/">http://p11-glue.freedesktop.org/</a>.

<p>The X.509 part of GnuTLS needs ASN.1 functionality, from a library
called libtasn1.  A copy of libtasn1 is included in GnuTLS.  If you
want to install it separately (e.g., to make it possibly to use
libtasn1 in other programs), you can get it from
<a href="http://www.gnu.org/software/gnutls/download.html">http://www.gnu.org/software/gnutls/download.html</a>.

<p>A few <code>configure</code> options may be relevant, summarized below. 
They disable or enable particular features,
to create a smaller library with only the required features.

<pre class="verbatim">--disable-srp-authentication
--disable-psk-authentication
--disable-anon-authentication
--disable-extra-pki
--disable-openpgp-authentication
--disable-openssl-compatibility
--without-p11-kit
</pre>

<p>For the complete list, refer to the output from <code>configure --help</code>.

<div class="node">
<a name="Document-overview"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Downloading-and-installing">Downloading and installing</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction-to-GnuTLS">Introduction to GnuTLS</a>

</div>

<h3 class="section">2.3 Overview</h3>

<p>In this document we present an overview of the supported security protocols in <a href="#Introduction-to-TLS">Introduction to TLS</a>, and
continue by providing more information on the certificate authentication in <a href="#Certificate-authentication">Certificate authentication</a>,
and shared-key as well anonymous authentication in <a href="#Shared_002dkey-and-anonymous-authentication">Shared-key and anonymous authentication</a>. We
elaborate on certificate authentication by demonstrating advanced usage of the API in <a href="#More-on-certificate-authentication">More on certificate authentication</a>. 
The core of the TLS library is presented in <a href="#How-to-use-GnuTLS-in-applications">How to use GnuTLS in applications</a> and example
applications are listed in <a href="#GnuTLS-application-examples">GnuTLS application examples</a>. 
In <a href="#Other-included-programs">Other included programs</a> the usage of few included programs that
may assist debugging is presented. The last chapter is <a href="#Internal-architecture-of-GnuTLS">Internal architecture of GnuTLS</a> that
provides a short introduction to GnuTLS' internal architecture.

<div class="node">
<a name="Introduction-to-TLS"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Certificate-authentication">Certificate authentication</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction-to-GnuTLS">Introduction to GnuTLS</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 Introduction to <acronym>TLS</acronym> and <acronym>DTLS</acronym></h2>

<p><acronym>TLS</acronym> stands for &ldquo;Transport Layer Security&rdquo; and is the
successor of SSL, the Secure Sockets Layer protocol [<em>SSL3</em>]
designed by Netscape.  <acronym>TLS</acronym> is an Internet protocol, defined
by <acronym>IETF</acronym><a rel="footnote" href="#fn-3" name="fnd-3"><sup>3</sup></a>, described in [<em>RFC5246</em>]. 
The protocol provides
confidentiality, and authentication layers over any reliable transport
layer.  The description, above, refers to <acronym>TLS</acronym> 1.0 but applies
to all other TLS versions as the differences between the protocols are not major.

<p>The <acronym>DTLS</acronym> protocol, or &ldquo;Datagram <acronym>TLS</acronym>&rdquo; [<em>RFC4347</em>] is a
protocol with identical goals as <acronym>TLS</acronym>, but can operate
under unreliable transport layers such as <acronym>UDP</acronym>. The
discussions below apply to this protocol as well, except when
noted otherwise.

<ul class="menu">
<li><a accesskey="1" href="#TLS-layers">TLS layers</a>
<li><a accesskey="2" href="#The-transport-layer">The transport layer</a>
<li><a accesskey="3" href="#The-TLS-record-protocol">The TLS record protocol</a>
<li><a accesskey="4" href="#The-TLS-Alert-Protocol">The TLS Alert Protocol</a>
<li><a accesskey="5" href="#The-TLS-Handshake-Protocol">The TLS Handshake Protocol</a>
<li><a accesskey="6" href="#TLS-Extensions">TLS Extensions</a>
<li><a accesskey="7" href="#How-to-use-TLS-in-application-protocols">How to use TLS in application protocols</a>
<li><a accesskey="8" href="#On-SSL-2-and-older-protocols">On SSL 2 and older protocols</a>
</ul>

<div class="node">
<a name="TLS-layers"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-transport-layer">The transport layer</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction-to-TLS">Introduction to TLS</a>

</div>

<h3 class="section">3.1 TLS layers</h3>

<p><a name="index-TLS-layers-3"></a>
<acronym>TLS</acronym> is a layered protocol, and consists of the record
protocol, the handshake protocol and the alert protocol. The record
protocol is to serve all other protocols and is above the transport
layer.  The record protocol offers symmetric encryption, data
authenticity, and optionally compression. 
The alert protocol offers some signaling to the other protocols. It
can help informing the peer for the cause of failures and other error
conditions.  See <a href="#The-Alert-Protocol">The Alert Protocol</a>, for more information.  The
alert protocol is above the record protocol.

<p>The handshake protocol is responsible for the security parameters'
negotiation, the initial key exchange and authentication. 
See <a href="#The-Handshake-Protocol">The Handshake Protocol</a>, for more information about the handshake
protocol.  The protocol layering in TLS is shown in <a href="#fig_003atls_002dlayers">fig:tls-layers</a>.

<div class="float">
<a name="fig_003atls_002dlayers"></a><img src="gnutls-layers.png" alt="gnutls-layers.png">

<p><strong class="float-caption">Figure 3.1: The TLS protocol layers.</strong></p></div>

<div class="node">
<a name="The-transport-layer"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-TLS-record-protocol">The TLS record protocol</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#TLS-layers">TLS layers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction-to-TLS">Introduction to TLS</a>

</div>

<h3 class="section">3.2 The transport layer</h3>

<p><a name="index-transport-protocol-4"></a><a name="index-transport-layer-5"></a>
<acronym>TLS</acronym> is not limited to any transport layer and can be used
above any transport layer, as long as it is a reliable one.  <acronym>DTLS</acronym>
can be used over reliable and unreliable transport layers. 
<acronym>GnuTLS</acronym> supports TCP and UDP layers transparently using
the Berkeley sockets API. However, any transport layer can be used
by providing callbacks for <acronym>GnuTLS</acronym> to access the transport layer
(for details see <a href="#Setting-up-the-transport-layer">Setting up the transport layer</a>).

<div class="node">
<a name="The-TLS-record-protocol"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-TLS-Alert-Protocol">The TLS Alert Protocol</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-transport-layer">The transport layer</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction-to-TLS">Introduction to TLS</a>

</div>

<h3 class="section">3.3 The TLS record protocol</h3>

<p><a name="index-record-protocol-6"></a>
The record protocol is the secure communications provider. Its purpose
is to encrypt, authenticate and &mdash;optionally&mdash; compress packets. 
The record layer functions can be called at any time after
the handshake process is finished, when there is need to receive
or send data. In <acronym>DTLS</acronym> however, due to re-transmission
timers used in the handshake out-of-order handshake data might
be received for some time (maximum 60 seconds) after the handshake
process is finished. For this reason programs using <acronym>DTLS</acronym>
should call the receive functions for every packet received by
the peer, even if no data were expected.

<p>The functions to access the record protocol are limited to send
and receive functions, which might, given
the importance of this protocol in <acronym>TLS</acronym>, seem awkward.  This is because
the record protocol's parameters are all set by the handshake protocol. 
The record protocol initially starts with NULL parameters, which means
no encryption, and no MAC is used. Encryption and authentication begin
just after the handshake protocol has finished.

     <ul>
<li><a href="#gnutls_005frecord_005fsend">gnutls_record_send</a>
<li><a href="#gnutls_005frecord_005frecv">gnutls_record_recv</a>
<li><a href="#gnutls_005frecord_005frecv_005fseq">gnutls_record_recv_seq</a>
</ul>

<ul class="menu">
<li><a accesskey="1" href="#Encryption-algorithms-used-in-the-record-layer">Encryption algorithms used in the record layer</a>
<li><a accesskey="2" href="#Compression-algorithms-used-in-the-record-layer">Compression algorithms used in the record layer</a>
<li><a accesskey="3" href="#Weaknesses-and-countermeasures">Weaknesses and countermeasures</a>
<li><a accesskey="4" href="#On-Record-Padding">On Record Padding</a>
</ul>

<div class="node">
<a name="Encryption-algorithms-used-in-the-record-layer"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Compression-algorithms-used-in-the-record-layer">Compression algorithms used in the record layer</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-TLS-record-protocol">The TLS record protocol</a>

</div>

<h4 class="subsection">3.3.1 Encryption algorithms used in the record layer</h4>

<p><a name="index-symmetric-encryption-algorithms-7"></a>
Confidentiality in the record layer is achieved by using symmetric
block encryption algorithms like <code>3DES</code>, <code>AES</code>
or stream algorithms like <code>ARCFOUR_128</code>. 
 Ciphers are encryption algorithms that use a single, secret,
key to encrypt and decrypt data. Block algorithms in CBC mode also provide
protection against statistical analysis of the data.  Thus, if you're
using the <acronym>TLS</acronym> protocol, a random number of blocks will be
appended to data, to prevent eavesdroppers from guessing the actual
data size.

<p>The supported in <acronym>GnuTLS</acronym> ciphers and MAC algorithms are shown in <a href="#tab_003aciphers">tab:ciphers</a> and
<a href="#tab_003amacs">tab:macs</a>.

<div class="float">
<a name="tab_003aciphers"></a>
<p><table summary=""><tr align="left"><th valign="top" width="20%">Algorithm </th><th valign="top" width="70%">Description
<br></th></tr><tr align="left"><td valign="top" width="20%">3DES_CBC </td><td valign="top" width="70%">
This is the DES block cipher algorithm used with triple
encryption (EDE). Has 64 bits block size and is used in CBC mode.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">ARCFOUR_128 </td><td valign="top" width="70%">
ARCFOUR_128 is a compatible algorithm with RSA's RC4 algorithm, which is considered to be a trade
secret. It is a fast cipher but considered weak today.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">ARCFOUR_40 </td><td valign="top" width="70%">
This is the ARCFOUR cipher fed with a 40 bit key,
which is considered weak.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">AES_CBC </td><td valign="top" width="70%">
AES or RIJNDAEL is the block cipher algorithm that replaces the old
DES algorithm.  Has 128 bits block size and is used in CBC mode.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">AES_GCM </td><td valign="top" width="70%">
This is the AES algorithm in the authenticated encryption GCM mode. 
This mode combines message authentication and encryption and can
be extremely fast on CPUs that support hardware acceleration.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">CAMELLIA_CBC </td><td valign="top" width="70%">
This is an 128-bit block cipher developed by Mitsubishi and NTT. It
is one of the approved ciphers of the European NESSIE and Japanese
CRYPTREC projects.

<br></td></tr></table>

<p><strong class="float-caption">Table 3.1: Supported ciphers.</strong></p></div>

<div class="float">
<a name="tab_003amacs"></a>
<p><table summary=""><tr align="left"><th valign="top" width="20%">Algorithm </th><th valign="top" width="70%">Description
<br></th></tr><tr align="left"><td valign="top" width="20%">MAC_MD5 </td><td valign="top" width="70%">
This is a cryptographic hash algorithm designed by Ron Rivest. Outputs
128 bits of data.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">MAC_SHA1 </td><td valign="top" width="70%">
A cryptographic hash algorithm designed by NSA. Outputs 160
bits of data.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">MAC_SHA256 </td><td valign="top" width="70%">
A cryptographic hash algorithm designed by NSA. Outputs 256
bits of data.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">MAC_AEAD </td><td valign="top" width="70%">
This indicates that an authenticated encryption algorithm, such as
GCM, is in use.

<br></td></tr></table>

<p><strong class="float-caption">Table 3.2: Supported MAC algorithms.</strong></p></div>

<div class="node">
<a name="Compression-algorithms-used-in-the-record-layer"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Weaknesses-and-countermeasures">Weaknesses and countermeasures</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Encryption-algorithms-used-in-the-record-layer">Encryption algorithms used in the record layer</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-TLS-record-protocol">The TLS record protocol</a>

</div>

<h4 class="subsection">3.3.2 Compression algorithms used in the record layer</h4>

<p><a name="index-compression-algorithms-8"></a>
The TLS record layer also supports compression.  The algorithms
implemented in <acronym>GnuTLS</acronym> can be found in the table below. 
The included algorithms perform really good when text, or other
compressible data are to be transferred, but offer nothing on already
compressed data, such as compressed images, zipped archives etc. 
These compression algorithms, may be useful in high bandwidth TLS
tunnels, and in cases where network usage has to be minimized. It
should be noted however that compression increases latency.

<p>The record layer compression in <acronym>GnuTLS</acronym> is implemented based
on [<em>RFC3749</em>]. The supported algorithms are shown in
<a href="#gnutls_005fcompression_005fmethod_005ft">gnutls_compression_method_t</a>.

<div class="float">
<a name="gnutls_005fcompression_005fmethod_005ft"></a>
     <ul>
<li>GNUTLS_COMP_UNKNOWN
Unknown compression method. 
<li>GNUTLS_COMP_NULL
The NULL compression method (no compression). 
<li>GNUTLS_COMP_DEFLATE
The DEFLATE compression method from zlib. 
<li>GNUTLS_COMP_ZLIB
Same as <code>GNUTLS_COMP_DEFLATE</code>. 
</ul>
<p><strong class="float-caption">Table 3.3</strong></p></div>

<div class="node">
<a name="Weaknesses-and-countermeasures"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#On-Record-Padding">On Record Padding</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Compression-algorithms-used-in-the-record-layer">Compression algorithms used in the record layer</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-TLS-record-protocol">The TLS record protocol</a>

</div>

<h4 class="subsection">3.3.3 Weaknesses and countermeasures</h4>

<p>Some weaknesses that may affect the security of the record layer have
been found in <acronym>TLS</acronym> 1.0 protocol. These weaknesses can be
exploited by active attackers, and exploit the facts that

     <ol type=1 start=1>

     <li><acronym>TLS</acronym> has separate alerts for &ldquo;decryption_failed&rdquo; and
&ldquo;bad_record_mac&rdquo;

     <li>The decryption failure reason can be detected by timing the response
time.

     <li>The IV for CBC encrypted packets is the last block of the previous
encrypted packet.

     </ol>

<p>Those weaknesses were solved in <acronym>TLS</acronym> 1.1 [<em>RFC4346</em>]
which is implemented in <acronym>GnuTLS</acronym>. For this reason we suggest
to always negotiate the highest supported TLS version with the peer. 
For a detailed discussion of the issues see the archives of the TLS
Working Group mailing list and [<em>CBCATT</em>].

<div class="node">
<a name="On-Record-Padding"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Weaknesses-and-countermeasures">Weaknesses and countermeasures</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-TLS-record-protocol">The TLS record protocol</a>

</div>

<h4 class="subsection">3.3.4 On record padding</h4>

<p><a name="index-record-padding-9"></a><a name="index-bad_005frecord_005fmac-10"></a>
The TLS protocol allows for random padding of records in CBC ciphers, to prevent
statistical analysis based on the length of exchanged messages (see [<em>RFC5246</em>] section 6.2.3.2). 
GnuTLS appears to be one of few implementation that take advantage of this text,
and pad records by a random length.

<p>The TLS implementation in the Symbian operating system, frequently
used by Nokia and Sony-Ericsson mobile phones, cannot handle
non-minimal record padding.  What happens when one of these clients
handshake with a GnuTLS server is that the client will fail to compute
the correct MAC for the record.  The client sends a TLS alert
(<code>bad_record_mac</code>) and disconnects.  Typically this will result
in error messages such as 'A TLS fatal alert has been received', 'Bad
record MAC', or both, on the GnuTLS server side.

<p>GnuTLS implements a work around for this problem.  However, it has to
be enabled specifically.  It can be enabled by using
<a href="#gnutls_005frecord_005fdisable_005fpadding">gnutls_record_disable_padding</a>, or <a href="#gnutls_005fpriority_005fset">gnutls_priority_set</a> with
the <code>%COMPAT</code> priority string (see <a href="#Priority-Strings">Priority Strings</a>).

<p>If you implement an application that have a configuration file, we
recommend that you make it possible for users or administrators to
specify a GnuTLS protocol priority string, which is used by your
application via <a href="#gnutls_005fpriority_005fset">gnutls_priority_set</a>.  To allow the best
flexibility, make it possible to have a different priority string for
different incoming IP addresses.

<div class="node">
<a name="The-TLS-Alert-Protocol"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-TLS-Handshake-Protocol">The TLS Handshake Protocol</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-TLS-record-protocol">The TLS record protocol</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction-to-TLS">Introduction to TLS</a>

</div>

<h3 class="section">3.4 The TLS alert protocol</h3>

<p><a name="The-Alert-Protocol"></a><a name="index-alert-protocol-11"></a>
The alert protocol is there to allow signals to be sent between peers. 
These signals are mostly used to inform the peer about the cause of a
protocol failure. Some of these signals are used internally by the
protocol and the application protocol does not have to cope with them
(e.g. <code>GNUTLS_A_CLOSE_NOTIFY</code>), and others refer to the
application protocol solely (e.g. <code>GNUTLS_A_USER_CANCELLED</code>).  An
alert signal includes a level indication which may be either fatal or
warning. Fatal alerts always terminate the current connection, and
prevent future re-negotiations using the current session ID. All alert
messages are summarized in <a href="#tab_003aalerts">tab:alerts</a>.

<p>The alert messages are protected by the record protocol, thus the
information that is included does not leak. You must take extreme care
for the alert information not to leak to a possible attacker, via
public log files etc. The available functions to control the alert
protocol are shown below.

     <ul>
<li><a href="#gnutls_005falert_005fget">gnutls_alert_get</a>
</ul>

     <ul>
<li><a href="#gnutls_005falert_005fsend">gnutls_alert_send</a>
</ul>

     <ul>
<li><a href="#gnutls_005ferror_005fto_005falert">gnutls_error_to_alert</a>
<li><a href="#gnutls_005falert_005fget_005fname">gnutls_alert_get_name</a>
</ul>

<p>Available alert messages:
<p><table summary=""><a name="tab_003aalerts"></a><tr align="left"><td valign="top" width="55%">GNUTLS_A_CLOSE_NOTIFY
</td><td valign="top" width="10%">0
</td><td valign="top" width="30%">Close notify
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_UNEXPECTED_MESSAGE
</td><td valign="top" width="10%">10
</td><td valign="top" width="30%">Unexpected message
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_BAD_RECORD_MAC
</td><td valign="top" width="10%">20
</td><td valign="top" width="30%">Bad record MAC
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_DECRYPTION_FAILED
</td><td valign="top" width="10%">21
</td><td valign="top" width="30%">Decryption failed
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_RECORD_OVERFLOW
</td><td valign="top" width="10%">22
</td><td valign="top" width="30%">Record overflow
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_DECOMPRESSION_FAILURE
</td><td valign="top" width="10%">30
</td><td valign="top" width="30%">Decompression failed
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_HANDSHAKE_FAILURE
</td><td valign="top" width="10%">40
</td><td valign="top" width="30%">Handshake failed
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_SSL3_NO_CERTIFICATE
</td><td valign="top" width="10%">41
</td><td valign="top" width="30%">No certificate (SSL 3.0)
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_BAD_CERTIFICATE
</td><td valign="top" width="10%">42
</td><td valign="top" width="30%">Certificate is bad
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_UNSUPPORTED_CERTIFICATE
</td><td valign="top" width="10%">43
</td><td valign="top" width="30%">Certificate is not supported
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_CERTIFICATE_REVOKED
</td><td valign="top" width="10%">44
</td><td valign="top" width="30%">Certificate was revoked
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_CERTIFICATE_EXPIRED
</td><td valign="top" width="10%">45
</td><td valign="top" width="30%">Certificate is expired
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_CERTIFICATE_UNKNOWN
</td><td valign="top" width="10%">46
</td><td valign="top" width="30%">Unknown certificate
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_ILLEGAL_PARAMETER
</td><td valign="top" width="10%">47
</td><td valign="top" width="30%">Illegal parameter
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_UNKNOWN_CA
</td><td valign="top" width="10%">48
</td><td valign="top" width="30%">CA is unknown
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_ACCESS_DENIED
</td><td valign="top" width="10%">49
</td><td valign="top" width="30%">Access was denied
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_DECODE_ERROR
</td><td valign="top" width="10%">50
</td><td valign="top" width="30%">Decode error
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_DECRYPT_ERROR
</td><td valign="top" width="10%">51
</td><td valign="top" width="30%">Decrypt error
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_EXPORT_RESTRICTION
</td><td valign="top" width="10%">60
</td><td valign="top" width="30%">Export restriction
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_PROTOCOL_VERSION
</td><td valign="top" width="10%">70
</td><td valign="top" width="30%">Error in protocol version
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_INSUFFICIENT_SECURITY
</td><td valign="top" width="10%">71
</td><td valign="top" width="30%">Insufficient security
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_INTERNAL_ERROR
</td><td valign="top" width="10%">80
</td><td valign="top" width="30%">Internal error
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_USER_CANCELED
</td><td valign="top" width="10%">90
</td><td valign="top" width="30%">User canceled
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_NO_RENEGOTIATION
</td><td valign="top" width="10%">100
</td><td valign="top" width="30%">No renegotiation is allowed
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_UNSUPPORTED_EXTENSION
</td><td valign="top" width="10%">110
</td><td valign="top" width="30%">An unsupported extension was sent
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_CERTIFICATE_UNOBTAINABLE
</td><td valign="top" width="10%">111
</td><td valign="top" width="30%">Could not retrieve the specified certificate
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_UNRECOGNIZED_NAME
</td><td valign="top" width="10%">112
</td><td valign="top" width="30%">The server name sent was not recognized
<br></td></tr><tr align="left"><td valign="top" width="55%">GNUTLS_A_UNKNOWN_PSK_IDENTITY
</td><td valign="top" width="10%">115
</td><td valign="top" width="30%">The SRP/PSK username is missing or not known
<br></td></tr></table>

<div class="node">
<a name="The-TLS-Handshake-Protocol"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#TLS-Extensions">TLS Extensions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-TLS-Alert-Protocol">The TLS Alert Protocol</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction-to-TLS">Introduction to TLS</a>

</div>

<h3 class="section">3.5 The TLS handshake protocol</h3>

<p><a name="The-Handshake-Protocol"></a><a name="index-handshake-protocol-12"></a>
The handshake protocol is responsible for the ciphersuite negotiation,
the initial key exchange, and the authentication of the two peers. 
This is fully controlled by the application layer, thus your program
has to set up the required parameters. The main handshake function
is <a href="#gnutls_005fhandshake">gnutls_handshake</a>. In the next paragraphs we elaborate on
the handshake protocol, i.e., the ciphersuite negotiation.

<ul class="menu">
<li><a accesskey="1" href="#TLS-Cipher-Suites">TLS Cipher Suites</a>:            TLS session parameters. 
<li><a accesskey="2" href="#Authentication">Authentication</a>:               TLS authentication. 
<li><a accesskey="3" href="#Client-Authentication">Client Authentication</a>:        Requesting a certificate from the client. 
<li><a accesskey="4" href="#Resuming-Sessions">Resuming Sessions</a>:            Reusing previously established keys. 
</ul>

<div class="node">
<a name="TLS-Cipher-Suites"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Authentication">Authentication</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-TLS-Handshake-Protocol">The TLS Handshake Protocol</a>

</div>

<h4 class="subsection">3.5.1 TLS ciphersuites</h4>

<p>The handshake protocol of <acronym>TLS</acronym> negotiates cipher suites of
a special form illustrated by the <code>TLS_DHE_RSA_WITH_3DES_CBC_SHA</code> cipher suite name.  A typical cipher
suite contains these parameters:

     <ul>
<li>The key exchange algorithm. 
<code>DHE_RSA</code> in the example.

     <li>The Symmetric encryption algorithm and mode
<code>3DES_CBC</code> in this example.

     <li>The MAC<a rel="footnote" href="#fn-4" name="fnd-4"><sup>4</sup></a> algorithm used for authentication. 
<code>MAC_SHA</code> is used in the above example.

</ul>

<p>The cipher suite negotiated in the handshake protocol will affect the
record protocol, by enabling encryption and data authentication.  Note
that you should not over rely on <acronym>TLS</acronym> to negotiate the
strongest available cipher suite. Do not enable ciphers and algorithms
that you consider weak.

<p>All the supported ciphersuites are listed in <a href="#ciphersuites">ciphersuites</a>.

<div class="node">
<a name="Authentication"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Client-Authentication">Client Authentication</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#TLS-Cipher-Suites">TLS Cipher Suites</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-TLS-Handshake-Protocol">The TLS Handshake Protocol</a>

</div>

<h4 class="subsection">3.5.2 Authentication</h4>

<p>The key exchange algorithms of the <acronym>TLS</acronym> protocol offer
authentication, which is a prerequisite for a secure connection. 
The available authentication methods in <acronym>GnuTLS</acronym> follow.

     <ul>
<li>Certificate authentication: Authenticated key exchange using public key infrastructure and certificates (X.509 or OpenPGP). 
<li><acronym>SRP</acronym> authentication: Authenticated key exchange using a password. 
<li><acronym>PSK</acronym> authentication: Authenticated key exchange using a pre-shared key. 
<li>Anonymous authentication: Key exchange without peer authentication.

</ul>

<div class="float">
<a name="tab_003akey_002dexchange"></a>
<p><table summary="">
<tr align="left"><th valign="top" width="20%">Key exchange </th><th valign="top" width="70%">Description

<p><br></th></tr><tr align="left"><td valign="top" width="20%">RSA </td><td valign="top" width="70%">
The RSA algorithm is used to encrypt a key and send it to the peer. 
The certificate must allow the key to be used for encryption.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">RSA_EXPORT </td><td valign="top" width="70%">
The RSA algorithm is used to encrypt a key and send it to the peer. 
In the EXPORT algorithm, the server signs temporary RSA parameters of
512 bits &mdash; which are considered weak &mdash; and sends them to the
client.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">DHE_RSA </td><td valign="top" width="70%">
The RSA algorithm is used to sign ephemeral Diffie-Hellman parameters
which are sent to the peer. The key in the certificate must allow the
key to be used for signing. Note that key exchange algorithms which
use ephemeral Diffie-Hellman parameters, offer perfect forward
secrecy. That means that even if the private key used for signing is
compromised, it cannot be used to reveal past session data.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">ECDHE_RSA </td><td valign="top" width="70%">
The RSA algorithm is used to sign ephemeral elliptic curve Diffie-Hellman
parameters which are sent to the peer. The key in the certificate must allow
the key to be used for signing. It also offers perfect forward
secrecy. That means that even if the private key used for signing is
compromised, it cannot be used to reveal past session data.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">DHE_DSS </td><td valign="top" width="70%">
The DSA algorithm is used to sign ephemeral Diffie-Hellman parameters
which are sent to the peer. The certificate must contain DSA
parameters to use this key exchange algorithm. DSA is the algorithm
of the Digital Signature Standard (DSS).

<p><br></td></tr><tr align="left"><td valign="top" width="20%">ECDHE_ECDSA </td><td valign="top" width="70%">
The Elliptic curve DSA algorithm is used to sign ephemeral elliptic
curve Diffie-Hellman parameters which are sent to the peer. The
certificate must contain ECDSA parameters to use this key exchange
algorithm.

<br></td></tr></table>

<p><strong class="float-caption">Table 3.4: Supported key exchange algorithms.</strong></p></div>

<p>Each authentication method is associated with a key exchange method, shown
in <a href="#tab_003akey_002dexchange">Table 3.4</a>, and a credentials type. 
The contents of the credentials is method-dependent, e.g. certificates
for certificate authentication and should be initialized and associated
with a session (see <a href="#gnutls_005fcredentials_005fset">gnutls_credentials_set</a>).  A mapping of the key exchange methods
with the credential types is shown in <a href="#tab_003akey_002dexchange_002dcred">tab:key-exchange-cred</a>.

<div class="float">
<a name="tab_003akey_002dexchange_002dcred"></a>
<p><table summary="">
<tr align="left"><th valign="top" width="25%">Authentication method </th><th valign="top" width="25%">Key exchange </th><th valign="top" width="20%">Client credentials </th><th valign="top" width="20%">Server credentials

<p><br></th></tr><tr align="left"><td valign="top" width="25%">Certificate
</td><td valign="top" width="25%"><code>KX_RSA</code>,
<code>KX_DHE_RSA</code>,
<code>KX_DHE_DSS</code>,
<code>KX_ECDHE_RSA</code>,
<code>KX_ECDHE_ECDSA</code>,
<code>KX_RSA_EXPORT</code>
</td><td valign="top" width="20%"><code>CRD_CERTIFICATE</code>
</td><td valign="top" width="20%"><code>CRD_CERTIFICATE</code>

<p><br></td></tr><tr align="left"><td valign="top" width="25%">Password and certificate
</td><td valign="top" width="25%"><code>KX_SRP_RSA</code>, <code>KX_SRP_DSS</code>
</td><td valign="top" width="20%"><code>CRD_SRP</code>
</td><td valign="top" width="20%"><code>CRD_CERTIFICATE</code>, <code>CRD_SRP</code>

<p><br></td></tr><tr align="left"><td valign="top" width="25%">Password
</td><td valign="top" width="25%"><code>KX_SRP</code>
</td><td valign="top" width="20%"><code>CRD_SRP</code>
</td><td valign="top" width="20%"><code>CRD_SRP</code>

<p><br></td></tr><tr align="left"><td valign="top" width="25%">Anonymous
</td><td valign="top" width="25%"><code>KX_ANON_DH</code>,
<code>KX_ANON_ECDH</code>
</td><td valign="top" width="20%"><code>CRD_ANON</code>
</td><td valign="top" width="20%"><code>CRD_ANON</code>

<p><br></td></tr><tr align="left"><td valign="top" width="25%">Pre-shared key
</td><td valign="top" width="25%"><code>KX_PSK</code>,
<code>KX_DHE_PSK</code>, <code>KX_ECDHE_PSK</code>
</td><td valign="top" width="20%"><code>CRD_PSK</code>
</td><td valign="top" width="20%"><code>CRD_PSK</code>

<br></td></tr></table>

<p><strong class="float-caption">Table 3.5: Key exchange algorithms and the corresponding credential types.</strong></p></div>

<div class="node">
<a name="Client-Authentication"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Resuming-Sessions">Resuming Sessions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Authentication">Authentication</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-TLS-Handshake-Protocol">The TLS Handshake Protocol</a>

</div>

<h4 class="subsection">3.5.3 Client authentication</h4>

<p><a name="index-client-certificate-authentication-13"></a>
In the case of ciphersuites that use certificate authentication, the
authentication of the client is optional in <acronym>TLS</acronym>.  A server
may request a certificate from the client using the
<a href="#gnutls_005fcertificate_005fserver_005fset_005frequest">gnutls_certificate_server_set_request</a> function. We elaborate
in <a href="#Certificate-credentials">Certificate credentials</a>.

<div class="node">
<a name="Resuming-Sessions"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Client-Authentication">Client Authentication</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-TLS-Handshake-Protocol">The TLS Handshake Protocol</a>

</div>

<h4 class="subsection">3.5.4 Resuming sessions</h4>

<p><a name="resume"></a><a name="index-resuming-sessions-14"></a><a name="index-session-resumption-15"></a>
The TLS handshake process performs expensive calculations
and a busy server might easily be put under load. To
reduce the load, session resumption may be used. This
is a feature of the <acronym>TLS</acronym> protocol which allows a
client to connect to a server after a successful handshake, without
the expensive calculations.  This is achieved by re-using the previously
established keys, meaning the server needs to store the state of established
connections (unless session tickets are used &ndash; <a href="#Session-tickets">Session tickets</a>).

<p>Session resumption is an integral part of <acronym>GnuTLS</acronym>, and
<a href="#Session-resumption">Session resumption</a> and <a href="#ex_003aresume_002dclient">ex:resume-client</a> illustrate typical
uses of it.

<div class="node">
<a name="TLS-Extensions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-to-use-TLS-in-application-protocols">How to use TLS in application protocols</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-TLS-Handshake-Protocol">The TLS Handshake Protocol</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction-to-TLS">Introduction to TLS</a>

</div>

<h3 class="section">3.6 TLS extensions</h3>

<p><a name="index-TLS-extensions-16"></a>
A number of extensions to the <acronym>TLS</acronym> protocol have been
proposed mainly in [<em>TLSEXT</em>]. The extensions supported
in <acronym>GnuTLS</acronym> are:

     <ul>
<li>Maximum fragment length negotiation
<li>Server name indication
<li>Session tickets
<li>Safe Renegotiation
</ul>

<p>and they will be discussed in the subsections that follow.

<ul class="menu">
<li><a accesskey="1" href="#Maximum-fragment-length-negotiation">Maximum fragment length negotiation</a>
<li><a accesskey="2" href="#Server-name-indication">Server name indication</a>
<li><a accesskey="3" href="#Session-tickets">Session tickets</a>
<li><a accesskey="4" href="#Safe-renegotiation">Safe renegotiation</a>
</ul>

<div class="node">
<a name="Maximum-fragment-length-negotiation"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Server-name-indication">Server name indication</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#TLS-Extensions">TLS Extensions</a>

</div>

<h4 class="subsection">3.6.1 Maximum fragment length negotiation</h4>

<p><a name="index-TLS-extensions-17"></a><a name="index-maximum-fragment-length-18"></a>
This extension allows a <acronym>TLS</acronym> implementation to negotiate a
smaller value for record packet maximum length. This extension may be
useful to clients with constrained capabilities. The functions shown
below can be used to control this extension.

     <ul>
<li><a href="#gnutls_005frecord_005fget_005fmax_005fsize">gnutls_record_get_max_size</a>
<li><a href="#gnutls_005frecord_005fset_005fmax_005fsize">gnutls_record_set_max_size</a>
</ul>

<div class="node">
<a name="Server-name-indication"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Session-tickets">Session tickets</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Maximum-fragment-length-negotiation">Maximum fragment length negotiation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#TLS-Extensions">TLS Extensions</a>

</div>

<h4 class="subsection">3.6.2 Server name indication</h4>

<p><a name="serverind"></a><a name="index-TLS-extensions-19"></a><a name="index-server-name-indication-20"></a>
A common problem in <acronym>HTTPS</acronym> servers is the fact that the
<acronym>TLS</acronym> protocol is not aware of the hostname that a client
connects to, when the handshake procedure begins. For that reason the
<acronym>TLS</acronym> server has no way to know which certificate to send.

<p>This extension solves that problem within the <acronym>TLS</acronym> protocol,
and allows a client to send the HTTP hostname before the handshake
begins within the first handshake packet.  The functions
<a href="#gnutls_005fserver_005fname_005fset">gnutls_server_name_set</a> and <a href="#gnutls_005fserver_005fname_005fget">gnutls_server_name_get</a> can be
used to enable this extension, or to retrieve the name sent by a
client.

     <ul>
<li><a href="#gnutls_005fserver_005fname_005fset">gnutls_server_name_set</a>
<li><a href="#gnutls_005fserver_005fname_005fget">gnutls_server_name_get</a>
</ul>

<div class="node">
<a name="Session-tickets"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Safe-renegotiation">Safe renegotiation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Server-name-indication">Server name indication</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#TLS-Extensions">TLS Extensions</a>

</div>

<h4 class="subsection">3.6.3 Session tickets</h4>

<p><a name="index-TLS-extensions-21"></a><a name="index-session-tickets-22"></a><a name="index-tickets-23"></a>
To resume a TLS session the server normally store session parameters.  This
complicates deployment, and could be avoiding by delegating the storage
to the client. Because session parameters are sensitive they are encrypted
and authenticated with a key only known to the server and then sent to the
client. The Session Ticket
extension implements this idea, and it is documented in
RFC 5077 [<em>TLSTKT</em>].

<div class="node">
<a name="Safe-renegotiation"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Session-tickets">Session tickets</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#TLS-Extensions">TLS Extensions</a>

</div>

<h4 class="subsection">3.6.4 Safe renegotiation</h4>

<p><a name="index-renegotiation-24"></a><a name="index-safe-renegotiation-25"></a>
TLS gives the option to two communicating parties to renegotiate
and update their security parameters. One useful example of this feature
was for a client to initially connect using anonymous negotiation to a
server, and the renegotiate using some authenticated ciphersuite. This occurred
to avoid having the client sending its credentials in the clear.

<p>However this renegotiation, as initially designed would not ensure that
the party one is renegotiating is the same as the one in the initial negotiation. 
For example one server could forward all renegotiation traffic to an other
server who will see this traffic as an initial negotiation attempt.

<p>This might be seen as a valid design decision, but it seems it was
not widely known or understood, thus today some application protocols the TLS
renegotiation feature in a manner that enables a malicious server to insert
content of his choice in the beginning of a TLS session.

<p>The most prominent vulnerability was with HTTPS. There servers request
a renegotiation to enforce an anonymous user to use a certificate in order
to access certain parts of a web site.  The
attack works by having the attacker simulate a client and connect to a
server, with server-only authentication, and send some data intended
to cause harm.  The server will then require renegotiation from him
in order to perform the request. 
When the proper client attempts to contact the server,
the attacker hijacks that connection and forwards traffic to
the initial server that requested renegotiation.  The
attacker will not be able to read the data exchanged between the
client and the server.  However, the server will (incorrectly) assume
that the initial request sent by the attacker was sent by the now authenticated
client.  The result is a prefix plain-text injection attack.

<p>The above is just one example.  Other vulnerabilities exists that do
not rely on the TLS renegotiation to change the client's authenticated
status (either TLS or application layer).

<p>While fixing these application protocols and implementations would be
one natural reaction, an extension to TLS has been designed that
cryptographically binds together any renegotiated handshakes with the
initial negotiation.  When the extension is used, the attack is
detected and the session can be terminated.  The extension is
specified in [<em>RFC5746</em>].

<p>GnuTLS supports the safe renegotiation extension.  The default
behavior is as follows.  Clients will attempt to negotiate the safe
renegotiation extension when talking to servers.  Servers will accept
the extension when presented by clients.  Clients and servers will
permit an initial handshake to complete even when the other side does
not support the safe renegotiation extension.  Clients and servers
will refuse renegotiation attempts when the extension has not been
negotiated.

<p>Note that permitting clients to connect to servers when the safe
renegotiation extension is not enabled, is open up for attacks. 
Changing this default behavior would prevent interoperability against
the majority of deployed servers out there.  We will reconsider this
default behavior in the future when more servers have been upgraded. 
Note that it is easy to configure clients to always require the safe
renegotiation extension from servers.

<p>To modify the default behavior, we have introduced some new priority
strings (see <a href="#Priority-Strings">Priority Strings</a>). 
The <code>%UNSAFE_RENEGOTIATION</code> priority string permits
(re-)handshakes even when the safe renegotiation extension was not
negotiated. The default behavior is <code>%PARTIAL_RENEGOTIATION</code> that will
prevent renegotiation with clients and servers not supporting the
extension. This is secure for servers but leaves clients vulnerable
to some attacks, but this is a trade-off between security and compatibility
with old servers. The <code>%SAFE_RENEGOTIATION</code> priority string makes
clients and servers require the extension for every handshake. The latter
is the most secure option for clients, at the cost of not being able
to connect to legacy servers. Servers will also deny clients that
do not support the extension from connecting.

<p>It is possible to disable use of the extension completely, in both
clients and servers, by using the <code>%DISABLE_SAFE_RENEGOTIATION</code>
priority string however we strongly recommend you to only do this for
debugging and test purposes.

<p>The default values if the flags above are not specified are:
     <dl>
<dt><code>Server:</code><dd>%PARTIAL_RENEGOTIATION

     <br><dt><code>Client:</code><dd>%PARTIAL_RENEGOTIATION

</dl>

<p>For applications we have introduced a new API related to safe
renegotiation.  The <a href="#gnutls_005fsafe_005frenegotiation_005fstatus">gnutls_safe_renegotiation_status</a> function is
used to check if the extension has been negotiated on a session, and
can be used both by clients and servers.

<div class="node">
<a name="How-to-use-TLS-in-application-protocols"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#On-SSL-2-and-older-protocols">On SSL 2 and older protocols</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#TLS-Extensions">TLS Extensions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction-to-TLS">Introduction to TLS</a>

</div>

<h3 class="section">3.7 How to use <acronym>TLS</acronym> in application protocols</h3>

<p>This chapter is intended to provide some hints on how to use the
<acronym>TLS</acronym> over simple custom made application protocols.  The
discussion below mainly refers to the <acronym>TCP/IP</acronym> transport layer
but may be extended to other ones too.

<ul class="menu">
<li><a accesskey="1" href="#Separate-ports">Separate ports</a>
<li><a accesskey="2" href="#Upward-negotiation">Upward negotiation</a>
</ul>

<div class="node">
<a name="Separate-ports"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Upward-negotiation">Upward negotiation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#How-to-use-TLS-in-application-protocols">How to use TLS in application protocols</a>

</div>

<h4 class="subsection">3.7.1 Separate ports</h4>

<p>Traditionally <acronym>SSL</acronym> was used in application protocols by
assigning a new port number for the secure services. That way two
separate ports were assigned, one for the non secure sessions, and one
for the secured ones. This has the benefit that if a user requests a
secure session then the client will try to connect to the secure port
and fail otherwise. The only possible attack with this method is a
denial of service one. The most famous example of this method is the
famous &ldquo;HTTP over TLS&rdquo; or <acronym>HTTPS</acronym> protocol [<em>RFC2818</em>].

<p>Despite its wide use, this method is not as good as it seems.  This
approach starts the <acronym>TLS</acronym> Handshake procedure just after the
client connects on the &mdash;so called&mdash; secure port.  That way the
<acronym>TLS</acronym> protocol does not know anything about the client, and
popular methods like the host advertising in HTTP do not
work<a rel="footnote" href="#fn-5" name="fnd-5"><sup>5</sup></a>.  There is no way for the client to say &ldquo;I
connected to YYY server&rdquo; before the Handshake starts, so the server
cannot possibly know which certificate to use.

<p>Other than that it requires two separate ports to run a single
service, which is unnecessary complication. Due to the fact that there
is a limitation on the available privileged ports, this approach was
soon obsoleted.

<div class="node">
<a name="Upward-negotiation"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Separate-ports">Separate ports</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#How-to-use-TLS-in-application-protocols">How to use TLS in application protocols</a>

</div>

<h4 class="subsection">3.7.2 Upward negotiation</h4>

<p>Other application protocols<a rel="footnote" href="#fn-6" name="fnd-6"><sup>6</sup></a>  use a
different approach to enable the secure layer.  They use something
often called as the &ldquo;TLS upgrade&rdquo; method. This method is quite tricky but it
is more flexible. The idea is to extend the application protocol to
have a &ldquo;STARTTLS&rdquo; request, whose purpose it to start the TLS
protocols just after the client requests it.  This approach
does not require any extra port to be reserved. 
There is even an extension to HTTP protocol to support
that method [<em>RFC2817</em>].

<p>The tricky part, in this method, is that the &ldquo;STARTTLS&rdquo; request is
sent in the clear, thus is vulnerable to modifications.  A typical
attack is to modify the messages in a way that the client is fooled
and thinks that the server does not have the &ldquo;STARTTLS&rdquo; capability. 
See a typical conversation of a hypothetical protocol:

<blockquote>
(client connects to the server)

<p>CLIENT: HELLO I'M MR. XXX

<p>SERVER: NICE TO MEET YOU XXX

<p>CLIENT: PLEASE START TLS

<p>SERVER: OK

<p>*** TLS STARTS

<p>CLIENT: HERE ARE SOME CONFIDENTIAL DATA
</blockquote>

<p>And see an example of a conversation where someone is acting
in between:

<blockquote>
(client connects to the server)

<p>CLIENT: HELLO I'M MR. XXX

<p>SERVER: NICE TO MEET YOU XXX

<p>CLIENT: PLEASE START TLS

<p>(here someone inserts this message)

<p>SERVER: SORRY I DON'T HAVE THIS CAPABILITY

<p>CLIENT: HERE ARE SOME CONFIDENTIAL DATA
</blockquote>

<p>As you can see above the client was fooled, and was dummy enough to
send the confidential data in the clear.

<p>How to avoid the above attack? As you may have already noticed this
one is easy to avoid. The client has to ask the user before it
connects whether the user requests <acronym>TLS</acronym> or not. If the user
answered that he certainly wants the secure layer the last
conversation should be:

<blockquote>
(client connects to the server)

<p>CLIENT: HELLO I'M MR. XXX

<p>SERVER: NICE TO MEET YOU XXX

<p>CLIENT: PLEASE START TLS

<p>(here someone inserts this message)

<p>SERVER: SORRY I DON'T HAVE THIS CAPABILITY

<p>CLIENT: BYE

<p>(the client notifies the user that the secure connection was not possible)
</blockquote>

<p>This method, if implemented properly, is far better than the
traditional method, and the security properties remain the same, since
only denial of service is possible. The benefit is that the server may
request additional data before the <acronym>TLS</acronym> Handshake protocol
starts, in order to send the correct certificate, use the correct
password file, or anything else!

<div class="node">
<a name="On-SSL-2-and-older-protocols"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-to-use-TLS-in-application-protocols">How to use TLS in application protocols</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction-to-TLS">Introduction to TLS</a>

</div>

<h3 class="section">3.8 On SSL 2 and older protocols</h3>

<p><a name="index-SSL-2-26"></a>
One of the initial decisions in the <acronym>GnuTLS</acronym> development was
to implement the known security protocols for the transport layer. 
Initially <acronym>TLS</acronym> 1.0 was implemented since it was the latest at
that time, and was considered to be the most advanced in security
properties.  Later the <acronym>SSL</acronym> 3.0 protocol was implemented
since it is still the only protocol supported by several servers and
there are no serious security vulnerabilities known.

<p>One question that may arise is why we didn't implement <acronym>SSL</acronym>
2.0 in the library.  There are several reasons, most important being
that it has serious security flaws, unacceptable for a modern security
library.  Other than that, this protocol is barely used by anyone
these days since it has been deprecated since 1996.  The security
problems in <acronym>SSL</acronym> 2.0 include:

     <ul>
<li>Message integrity compromised. 
The <acronym>SSLv2</acronym> message authentication uses the MD5 function, and
is insecure.

     <li>Man-in-the-middle attack. 
There is no protection of the handshake in <acronym>SSLv2</acronym>, which
permits a man-in-the-middle attack.

     <li>Truncation attack. 
<acronym>SSLv2</acronym> relies on TCP FIN to close the session, so the
attacker can forge a TCP FIN, and the peer cannot tell if it was a
legitimate end of data or not.

     <li>Weak message integrity for export ciphers. 
The cryptographic keys in <acronym>SSLv2</acronym> are used for both message
authentication and encryption, so if weak encryption schemes are
negotiated (say 40-bit keys) the message authentication code use the
same weak key, which isn't necessary.

</ul>

<p><a name="index-PCT-27"></a>Other protocols such as Microsoft's <acronym>PCT</acronym> 1 and <acronym>PCT</acronym>
2 were not implemented because they were also abandoned and deprecated
by <acronym>SSL</acronym> 3.0 and later <acronym>TLS</acronym> 1.0.

<div class="node">
<a name="Certificate-authentication"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Shared_002dkey-and-anonymous-authentication">Shared-key and anonymous authentication</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction-to-TLS">Introduction to TLS</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">4 Certificate authentication</h2>

<p><a name="index-certificate-authentication-28"></a>

<ul class="menu">
<li><a accesskey="1" href="#Introduction">Introduction</a>
<li><a accesskey="2" href="#X_002e509-certificates">X.509 certificates</a>
<li><a accesskey="3" href="#OpenPGP-certificates">OpenPGP certificates</a>
<li><a accesskey="4" href="#Digital-signatures">Digital signatures</a>
</ul>

<div class="node">
<a name="Introduction"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#X_002e509-certificates">X.509 certificates</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Certificate-authentication">Certificate authentication</a>

</div>

<h3 class="section">4.1 Introduction</h3>

<p>The most known authentication method of <acronym>TLS</acronym> are certificates. 
The PKIX [<em>PKIX</em>] public key infrastructure is daily used by anyone
using a browser today. <acronym>GnuTLS</acronym> supports both
<acronym>X.509</acronym> certificates [<em>PKIX</em>] and <acronym>OpenPGP</acronym>
certificates using a common API.

<div class="node">
<a name="X.509-certificates"></a>
<a name="X_002e509-certificates"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#OpenPGP-certificates">OpenPGP certificates</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction">Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Certificate-authentication">Certificate authentication</a>

</div>

<h3 class="section">4.2 <acronym>X.509</acronym> certificates</h3>

<p><a name="index-X_002e509-certificates-29"></a>
The <acronym>X.509</acronym> protocols rely on a hierarchical trust model. In
this trust model Certification Authorities (CAs) are used to certify
entities.  Usually more than one certification authorities exist, and
certification authorities may certify other authorities to issue
certificates as well, following a hierarchical model.

<div class="float">
<a name="fig_003ax509"></a><img src="gnutls-x509.png" alt="gnutls-x509.png">

<p><strong class="float-caption">Figure 4.1: An example of the X.509 hierarchical trust model.</strong></p></div>

<p>One needs to trust one or more CAs for his secure communications. In
that case only the certificates issued by the trusted authorities are
acceptable.  The framework is illustrated on <a href="#fig_003ax509">Figure 4.1</a>.

<ul class="menu">
<li><a accesskey="1" href="#X_002e509-certificate-structure">X.509 certificate structure</a>
<li><a accesskey="2" href="#Verifying-X_002e509-certificate-paths">Verifying X.509 certificate paths</a>
<li><a accesskey="3" href="#Verifying-a-certificate-in-the-context-of-TLS-session">Verifying a certificate in the context of TLS session</a>
</ul>

<div class="node">
<a name="X.509-certificate-structure"></a>
<a name="X_002e509-certificate-structure"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Verifying-X_002e509-certificate-paths">Verifying X.509 certificate paths</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#X_002e509-certificates">X.509 certificates</a>

</div>

<h4 class="subsection">4.2.1 <acronym>X.509</acronym> certificate structure</h4>

<p>An <acronym>X.509</acronym> certificate usually contains information about the
certificate holder, the signer, a unique serial number, expiration
dates and some other fields [<em>PKIX</em>] as shown in <a href="#tab_003ax509">tab:x509</a>.

<div class="float">
<a name="tab_003ax509"></a>
<p><table summary="">
<tr align="left"><th valign="top" width="20%">Field </th><th valign="top" width="70%">Description

<p><br></th></tr><tr align="left"><td valign="top" width="20%">version </td><td valign="top" width="70%">
The field that indicates the version of the certificate.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">serialNumber </td><td valign="top" width="70%">
This field holds a unique serial number per certificate.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">signature </td><td valign="top" width="70%">
The issuing authority's signature.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">issuer </td><td valign="top" width="70%">
Holds the issuer's distinguished name.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">validity </td><td valign="top" width="70%">
The activation and expiration dates.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">subject </td><td valign="top" width="70%">
The subject's distinguished name of the certificate.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">extensions </td><td valign="top" width="70%">
The extensions are fields only present in version 3 certificates.

<br></td></tr></table>

<p><strong class="float-caption">Table 4.1: X.509 certificate fields.</strong></p></div>

<p>The certificate's <em>subject or issuer name</em> is not just a single
string.  It is a Distinguished name and in the <acronym>ASN.1</acronym>
notation is a sequence of several object identifiers with their corresponding
values. Some of available OIDs to be used in an <acronym>X.509</acronym>
distinguished name are defined in <samp><span class="file">gnutls/x509.h</span></samp>.

<p>The <em>Version</em> field in a certificate has values either 1 or 3 for
version 3 certificates.  Version 1 certificates do not support the
extensions field so it is not possible to distinguish a CA from a
person, thus their usage should be avoided.

<p>The <em>validity</em> dates are there to indicate the date that the
specific certificate was activated and the date the certificate's key
would be considered invalid.

<p>Certificate <em>extensions</em> are there to include information about
the certificate's subject that did not fit in the typical certificate
fields. Those may be e-mail addresses, flags that indicate whether the
belongs to a CA etc.  All the supported <acronym>X.509</acronym> version 3
extensions are shown in <a href="#tab_003ax509_002dext">tab:x509-ext</a>.

<div class="float">
<a name="tab_003ax509_002dext"></a>
<p><table summary="">
<tr align="left"><th valign="top" width="30%">Extension </th><th valign="top" width="20%">OID </th><th valign="top" width="40%">Description

<p><br></th></tr><tr align="left"><td valign="top" width="30%">Subject key id </td><td valign="top" width="20%">2.5.29.14 </td><td valign="top" width="40%">
An identifier of the key of the subject.

<p><br></td></tr><tr align="left"><td valign="top" width="30%">Authority key id </td><td valign="top" width="20%">2.5.29.35 </td><td valign="top" width="40%">
An identifier of the authority's key used to sign the certificate.

<p><br></td></tr><tr align="left"><td valign="top" width="30%">Subject alternative name </td><td valign="top" width="20%">2.5.29.17 </td><td valign="top" width="40%">
Alternative names to subject's distinguished name.

<p><br></td></tr><tr align="left"><td valign="top" width="30%">Key usage </td><td valign="top" width="20%">2.5.29.15 </td><td valign="top" width="40%">
Constraints the key's usage of the certificate.

<p><br></td></tr><tr align="left"><td valign="top" width="30%">Extended key usage </td><td valign="top" width="20%">2.5.29.37 </td><td valign="top" width="40%">
Constraints the purpose of the certificate.

<p><br></td></tr><tr align="left"><td valign="top" width="30%">Basic constraints </td><td valign="top" width="20%">2.5.29.19 </td><td valign="top" width="40%">
Indicates whether this is a CA certificate or not, and specify the
maximum path lengths of certificate chains.

<p><br></td></tr><tr align="left"><td valign="top" width="30%">CRL distribution points </td><td valign="top" width="20%">2.5.29.31 </td><td valign="top" width="40%">
This extension is set by the CA, in order to inform about the issued
CRLs.

<p><br></td></tr><tr align="left"><td valign="top" width="30%">Proxy Certification Information </td><td valign="top" width="20%">1.3.6.1.5.5.7.1.14 </td><td valign="top" width="40%">
Proxy Certificates includes this extension that contains the OID of
the proxy policy language used, and can specify limits on the maximum
lengths of proxy chains.  Proxy Certificates are specified in
[<em>RFC3820</em>].

<br></td></tr></table>

<p><strong class="float-caption">Table 4.2: X.509 certificate extensions.</strong></p></div>

<p>In <acronym>GnuTLS</acronym> the <acronym>X.509</acronym> certificate structures are
handled using the <code>gnutls_x509_crt_t</code> type and the corresponding
private keys with the <code>gnutls_x509_privkey_t</code> type.  All the
available functions for <acronym>X.509</acronym> certificate handling have
their prototypes in <samp><span class="file">gnutls/x509.h</span></samp>. An example program to
demonstrate the <acronym>X.509</acronym> parsing capabilities can be found at
<a href="#ex_003ax509_002dinfo">ex:x509-info</a>.

<div class="node">
<a name="Verifying-X.509-certificate-paths"></a>
<a name="Verifying-X_002e509-certificate-paths"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Verifying-a-certificate-in-the-context-of-TLS-session">Verifying a certificate in the context of TLS session</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#X_002e509-certificate-structure">X.509 certificate structure</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#X_002e509-certificates">X.509 certificates</a>

</div>

<h4 class="subsection">4.2.2 Verifying <acronym>X.509</acronym> certificate paths</h4>

<p><a name="index-verifying-certificate-paths-30"></a>
Verifying certificate paths is important in <acronym>X.509</acronym>
authentication. For this purpose the following functions are
provided.

     <ul>
<li><a href="#gnutls_005fx509_005ftrust_005flist_005fadd_005fcas">gnutls_x509_trust_list_add_cas</a>
</ul>

     <ul>
<li><a href="#gnutls_005fx509_005ftrust_005flist_005fadd_005fnamed_005fcrt">gnutls_x509_trust_list_add_named_crt</a>
</ul>

     <ul>
<li><a href="#gnutls_005fx509_005ftrust_005flist_005fadd_005fcrls">gnutls_x509_trust_list_add_crls</a>
</ul>

     <ul>
<li><a href="#gnutls_005fx509_005ftrust_005flist_005fverify_005fcrt">gnutls_x509_trust_list_verify_crt</a>
</ul>

     <ul>
<li><a href="#gnutls_005fx509_005ftrust_005flist_005fverify_005fnamed_005fcrt">gnutls_x509_trust_list_verify_named_crt</a>
</ul>

<p>The verification function will verify a given certificate chain against a list of certificate
authorities and certificate revocation lists, and output
a bit-wise OR of elements of the <code>gnutls_certificate_status_t</code>
enumeration shown in <a href="#gnutls_005fcertificate_005fstatus_005ft">gnutls_certificate_status_t</a>.

<div class="float">
<a name="gnutls_005fcertificate_005fstatus_005ft"></a>
     <ul>
<li>GNUTLS_CERT_INVALID
The certificate is not signed by one of the
known authorities or the signature is invalid. 
<li>GNUTLS_CERT_REVOKED
Certificate is revoked by its authority.  In X.509 this will be
set only if CRLs are checked. 
<li>GNUTLS_CERT_SIGNER_NOT_FOUND
The certificate's issuer is not known. 
This is the case if the issue is not included in the trusted certificate list. 
not found. 
<li>GNUTLS_CERT_SIGNER_NOT_CA
The certicates signer was not a CA. This
may happen if this was a version 1 certicate, which is common with
some CAs, or a version 3 certicate without the basic constrains extension. 
<li>GNUTLS_CERT_INSECURE_ALGORITHM
The certicate was signed using an in-
secure algorithm such as MD2 or MD5. These algorithms have been broken and
should not be trusted. 
<li>GNUTLS_CERT_NOT_ACTIVATED
The certificate is not yet activated. 
<li>GNUTLS_CERT_EXPIRED
The certificate has expired. 
</ul>
<p><strong class="float-caption">Table 4.3</strong></p></div>

<p>An example of certificate verification is shown in <a href="#ex_003averify2">ex:verify2</a>. 
It is also possible to have a set of certificates that
are trusted for a particular server but not to authorize other certificates. 
This purpose is served by the functions <a href="#gnutls_005fx509_005ftrust_005flist_005fadd_005fnamed_005fcrt">gnutls_x509_trust_list_add_named_crt</a> and <a href="#gnutls_005fx509_005ftrust_005flist_005fverify_005fnamed_005fcrt">gnutls_x509_trust_list_verify_named_crt</a>.

<div class="node">
<a name="Verifying-a-certificate-in-the-context-of-TLS-session"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Verifying-X_002e509-certificate-paths">Verifying X.509 certificate paths</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#X_002e509-certificates">X.509 certificates</a>

</div>

<h4 class="subsection">4.2.3 Verifying a certificate in the context of TLS session</h4>

<p><a name="index-verifying-certificate-paths-31"></a><a name="index-gnutls_005fcertificate_005fverify_005fflags-32"></a>
When operating in the context of a TLS session, the trusted certificate
authority list has been set via the
<a href="#gnutls_005fcertificate_005fset_005fx509_005ftrust_005ffile">gnutls_certificate_set_x509_trust_file</a> and <a href="#gnutls_005fcertificate_005fset_005fx509_005fcrl_005ffile">gnutls_certificate_set_x509_crl_file</a>,
thus it is not required to setup a trusted list as above. 
Convenience functions such as <a href="#gnutls_005fcertificate_005fverify_005fpeers2">gnutls_certificate_verify_peers2</a>
are equivalent and will verify the peer's certificate chain
in a TLS session.

<p>There is also the possibility to pass some input to the verification
functions in the form of flags. For <a href="#gnutls_005fx509_005ftrust_005flist_005fverify_005fcrt">gnutls_x509_trust_list_verify_crt</a> the
flags are passed straightforward, but
<a href="#gnutls_005fcertificate_005fverify_005fpeers2">gnutls_certificate_verify_peers2</a> depends on the flags set by
calling <a href="#gnutls_005fcertificate_005fset_005fverify_005fflags">gnutls_certificate_set_verify_flags</a>.  All the available
flags are part of the enumeration
<code>gnutls_certificate_verify_flags</code> shown in <a href="#gnutls_005fcertificate_005fverify_005fflags">gnutls_certificate_verify_flags</a>.

<div class="float">
<a name="gnutls_005fcertificate_005fverify_005fflags"></a>
     <ul>
<li>GNUTLS_VERIFY_DISABLE_CA_SIGN
If set a signer does not have to be
a certificate authority. This flag should normaly be disabled,
unless you know what this means. 
<li>GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT
Allow trusted CA certicates
with version 1. This is safer than <code>GNUTLS_VERIFY_ALLOW_ANY_X509_V1_CA_CRT</code>,
and should be used instead. That way only signers in your trusted list
will be allowed to have certicates of version 1. This is the default. 
<li>GNUTLS_VERIFY_DO_NOT_ALLOW_SAME
If a certificate is not signed by
anyone trusted but exists in the trusted CA list do not treat it
as trusted. 
<li>GNUTLS_VERIFY_ALLOW_ANY_X509_V1_CA_CRT
Allow CA certificates that
have version 1 (both root and intermediate). This might be
dangerous since those haven't the basicConstraints
extension. Must be used in combination with
<code>GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT</code>. 
<li>GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD2
Allow certificates to be signed
using the broken MD2 algorithm. 
<li>GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD5
Allow certificates to be signed
using the broken MD5 algorithm. 
<li>GNUTLS_VERIFY_DISABLE_TIME_CHECKS
Disable checking of activation
and expiration validity periods of certificate chains. Don't set
this unless you understand the security implications. 
<li>GNUTLS_VERIFY_DISABLE_TRUSTED_TIME_CHECKS
If set a signer in the trusted
list is never checked for expiration or activation. 
<li>GNUTLS_VERIFY_DO_NOT_ALLOW_X509_V1_CA_CRT
Do not allow trusted CA
certificates that have version 1.  This option is to be used
to deprecate all certificates of version 1. 
<li>GNUTLS_VERIFY_DISABLE_CRL_CHECKS
Disable checking for validity
using certificate revocation lists. 
</ul>
<p><strong class="float-caption">Table 4.4</strong></p></div>

<p>Although the verification of a certificate path indicates that the
certificate is signed by trusted authority, does not reveal anything
about the peer's identity. It is required to verify if the
certificate's owner is the one you expect. For more information
consult [<em>RFC2818</em>] and section <a href="#ex_003averify">ex:verify</a> for an example.

<div class="node">
<a name="OpenPGP-certificates"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Digital-signatures">Digital signatures</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#X_002e509-certificates">X.509 certificates</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Certificate-authentication">Certificate authentication</a>

</div>

<h3 class="section">4.3 <acronym>OpenPGP</acronym> certificates</h3>

<p><a name="index-OpenPGP-certificates-33"></a>
The <acronym>OpenPGP</acronym> key authentication relies on a distributed trust
model, called the &ldquo;web of trust&rdquo;. The &ldquo;web of trust&rdquo; uses a
decentralized system of trusted introducers, which are the same as a
CA. <acronym>OpenPGP</acronym> allows anyone to sign anyone else's public
key. When Alice signs Bob's key, she is introducing Bob's key to
anyone who trusts Alice. If someone trusts Alice to introduce keys,
then Alice is a trusted introducer in the mind of that observer. 
For example in <a href="#fig_003aopenpgp">fig:openpgp</a>, David trusts Alice to be an introducer and Alice
signed Bob's key thus Dave trusts Bob's key to be the real one.

<div class="float">
<a name="fig_003aopenpgp"></a><img src="gnutls-pgp.png" alt="gnutls-pgp.png">

<p><strong class="float-caption">Figure 4.2: An example of the OpenPGP trust model.</strong></p></div>

<p>There are some key points that are important in that model. In the
example Alice has to sign Bob's key, only if she is sure that the key
belongs to Bob. Otherwise she may also make Dave falsely believe that
this is Bob's key. Dave has also the responsibility to know who to
trust.  This model is similar to real life relations.

<p>Just see how Charlie behaves in the previous example. Although he has
signed Bob's key - because he knows, somehow, that it belongs to Bob -
he does not trust Bob to be an introducer. Charlie decided to trust
only Kevin, for some reason. A reason could be that Bob is lazy
enough, and signs other people's keys without being sure that they
belong to the actual owner.

<h4 class="subsection">4.3.1 <acronym>OpenPGP</acronym> certificate structure</h4>

<p>In <acronym>GnuTLS</acronym> the <acronym>OpenPGP</acronym> key structures
[<em>RFC2440</em>] are handled using the <code>gnutls_openpgp_crt_t</code> type
and the corresponding private keys with the
<code>gnutls_openpgp_privkey_t</code> type. All the prototypes for the key
handling functions can be found at <samp><span class="file">gnutls/openpgp.h</span></samp>.

<h4 class="subsection">4.3.2 Verifying an <acronym>OpenPGP</acronym> certificate</h4>

<p>The verification functions of <acronym>OpenPGP</acronym> keys, included in
<acronym>GnuTLS</acronym>, are simple ones, and do not use the features of the
&ldquo;web of trust&rdquo;.  For that reason, if the verification needs are
complex, the assistance of external tools like <acronym>GnuPG</acronym> and
GPGME<a rel="footnote" href="#fn-7" name="fnd-7"><sup>7</sup></a> is
recommended.

<p>In GnuTLS there is a verification function for OpenPGP certificates,
the <a href="#gnutls_005fopenpgp_005fcrt_005fverify_005fring">gnutls_openpgp_crt_verify_ring</a>.  This checks an
<acronym>OpenPGP</acronym> key against a given set of public keys (keyring) and
returns the key status. The key verification status is the same as in
<acronym>X.509</acronym> certificates, although the meaning and interpretation
are different. For example an <acronym>OpenPGP</acronym> key may be valid, if
the self signature is ok, even if no signers were found.  The meaning
of verification status flags is the same as in the <acronym>X.509</acronym> certificates
(see <a href="#gnutls_005fcertificate_005fverify_005fflags">Table 4.4</a>).

     <ul>
<li><a href="#gnutls_005fopenpgp_005fcrt_005fverify_005fring">gnutls_openpgp_crt_verify_ring</a>
</ul>

     <ul>
<li><a href="#gnutls_005fopenpgp_005fcrt_005fverify_005fself">gnutls_openpgp_crt_verify_self</a>
</ul>

<h4 class="subsection">4.3.3 Verifying a certificate in the context of a TLS session</h4>

<p>Similarly with X.509 certificates, one needs to specify
the OpenPGP keyring file in the credentials structure. The certificates
in this file will be  used by <a href="#gnutls_005fcertificate_005fverify_005fpeers2">gnutls_certificate_verify_peers2</a>
to verify the signatures in the certificate sent by the peer.

     <ul>
<li><a href="#gnutls_005fcertificate_005fset_005fopenpgp_005fkeyring_005ffile">gnutls_certificate_set_openpgp_keyring_file</a>
</ul>

<div class="node">
<a name="Digital-signatures"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#OpenPGP-certificates">OpenPGP certificates</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Certificate-authentication">Certificate authentication</a>

</div>

<h3 class="section">4.4 Digital signatures</h3>

<p><a name="index-digital-signatures-34"></a>
In this section we will provide some information about digital
signatures, how they work, and give the rationale for disabling some
of the algorithms used.

<p>Digital signatures work by using somebody's secret key to sign some
arbitrary data.  Then anybody else could use the public key of that
person to verify the signature.  Since the data may be arbitrary it is
not suitable input to a cryptographic digital signature algorithm. For
this reason and also for performance cryptographic hash algorithms are
used to preprocess the input to the signature algorithm. This works as
long as it is difficult enough to generate two different messages with
the same hash algorithm output. In that case the same signature could
be used as a proof for both messages. Nobody wants to sign an innocent
message of donating 1 &euro; to Greenpeace and find out that he
donated 1.000.000 &euro; to Bad Inc.

<p>For a hash algorithm to be called cryptographic the following three
requirements must hold:

     <ol type=1 start=1>
<li>Preimage resistance. 
That means the algorithm must be one way and given the output of the
hash function H(x), it is impossible to calculate x.

     <li>2nd preimage resistance. 
That means that given a pair x,y with y=H(x) it is
impossible to calculate an x' such that y=H(x').

     <li>Collision resistance. 
That means that it is impossible to calculate random x and
x' such H(x')=H(x).
     </ol>

<p>The last two requirements in the list are the most important in
digital signatures. These protect against somebody who would like to
generate two messages with the same hash output. When an algorithm is
considered broken usually it means that the Collision resistance of
the algorithm is less than brute force. Using the birthday paradox the
brute force attack takes
2^((hash size) / 2)
operations. Today colliding certificates using the MD5 hash algorithm
have been generated as shown in [<em>WEGER</em>].

<p>There has been cryptographic results for the SHA-1 hash algorithms as
well, although they are not yet critical.  Before 2004, MD5 had a
presumed collision strength of 2^64, but it has been showed
to have a collision strength well under 2^50.  As of November
2005, it is believed that SHA-1's collision strength is around
2^63.  We consider this sufficiently hard so that we still
support SHA-1.  We anticipate that SHA-256/386/512 will be used in
publicly-distributed certificates in the future.  When 2^63
can be considered too weak compared to the computer power available
sometime in the future, SHA-1 will be disabled as well.  The collision
attacks on SHA-1 may also get better, given the new interest in tools
for creating them.

<h4 class="subsection">4.4.1 Trading security for interoperability</h4>

<p>If you connect to a server and use GnuTLS' functions to verify the
certificate chain, and get a <code>GNUTLS_CERT_INSECURE_ALGORITHM</code>
validation error (see <a href="#Verifying-X_002e509-certificate-paths">Verifying X.509 certificate paths</a>), it means
that somewhere in the certificate chain there is a certificate signed
using <code>RSA-MD2</code> or <code>RSA-MD5</code>.  These two digital signature
algorithms are considered broken, so GnuTLS fails verifying
the certificate.  In some situations, it may be useful to be
able to verify the certificate chain anyway, assuming an attacker did
not utilize the fact that these signatures algorithms are broken. 
This section will give help on how to achieve that.

<p>It is important to know that you do not have to enable any of
the flags discussed here to be able to use trusted root CA
certificates self-signed using <code>RSA-MD2</code> or <code>RSA-MD5</code>. The
certificates in the trusted list are considered trusted irrespective
of the signature.

<p>If you are using <a href="#gnutls_005fcertificate_005fverify_005fpeers2">gnutls_certificate_verify_peers2</a> to verify the
certificate chain, you can call
<a href="#gnutls_005fcertificate_005fset_005fverify_005fflags">gnutls_certificate_set_verify_flags</a> with the flags:
     <ul>
<li><code>GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD2</code>
<li><code>GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD5</code>
</ul>
as in the following example:

<pre class="smallexample">       gnutls_certificate_set_verify_flags (x509cred,
                                            GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD5);
</pre>
<p>This will tell the verifier algorithm to enable <code>RSA-MD5</code> when
verifying the certificates.

<p>If you are using <a href="#gnutls_005fx509_005fcrt_005fverify">gnutls_x509_crt_verify</a> or
<a href="#gnutls_005fx509_005fcrt_005flist_005fverify">gnutls_x509_crt_list_verify</a>, you can pass the
<code>GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD5</code> parameter directly in the
<code>flags</code> parameter.

<p>If you are using these flags, it may also be a good idea to warn the
user when verification failure occur for this reason.  The simplest is
to not use the flags by default, and only fall back to using them
after warning the user.  If you wish to inspect the certificate chain
yourself, you can use <a href="#gnutls_005fcertificate_005fget_005fpeers">gnutls_certificate_get_peers</a> to extract
the raw server's certificate chain, <a href="#gnutls_005fx509_005fcrt_005flist_005fimport">gnutls_x509_crt_list_import</a> to parse each of the certificates, and
then <a href="#gnutls_005fx509_005fcrt_005fget_005fsignature_005falgorithm">gnutls_x509_crt_get_signature_algorithm</a> to find out the
signing algorithm used for each certificate.  If any of the
intermediary certificates are using <code>GNUTLS_SIGN_RSA_MD2</code> or
<code>GNUTLS_SIGN_RSA_MD5</code>, you could present a warning.

<div class="node">
<a name="Shared-key-and-anonymous-authentication"></a>
<a name="Shared_002dkey-and-anonymous-authentication"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#More-on-certificate-authentication">More on certificate authentication</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Certificate-authentication">Certificate authentication</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">5 Shared-key and anonymous authentication</h2>

<ul class="menu">
<li><a accesskey="1" href="#SRP-authentication">SRP authentication</a>
<li><a accesskey="2" href="#PSK-authentication">PSK authentication</a>
<li><a accesskey="3" href="#Anonymous-authentication">Anonymous authentication</a>
</ul>

<div class="node">
<a name="SRP-authentication"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#PSK-authentication">PSK authentication</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Shared_002dkey-and-anonymous-authentication">Shared-key and anonymous authentication</a>

</div>

<h3 class="section">5.1 SRP authentication</h3>

<ul class="menu">
<li><a accesskey="1" href="#Authentication-using-SRP">Authentication using SRP</a>
<li><a accesskey="2" href="#Invoking-srptool">Invoking srptool</a>
</ul>

<div class="node">
<a name="Authentication-using-SRP"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Invoking-srptool">Invoking srptool</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#SRP-authentication">SRP authentication</a>

</div>

<h4 class="subsection">5.1.1 Authentication using <acronym>SRP</acronym></h4>

<p><a name="index-SRP-authentication-35"></a>
<acronym>GnuTLS</acronym> supports authentication via the Secure Remote Password
or <acronym>SRP</acronym> protocol (see [<em>RFC2945,TOMSRP</em>] for a description). 
The <acronym>SRP</acronym> key exchange is an extension to the
<acronym>TLS</acronym> protocol, and it provides an authenticated with a
password key exchange. The peers can be identified using a single password,
or there can be combinations where the client is authenticated using <acronym>SRP</acronym>
and the server using a certificate.

<p>The advantage of <acronym>SRP</acronym> authentication, over other proposed
secure password authentication schemes, is that <acronym>SRP</acronym> is not
susceptible to off-line dictionary attacks. 
Moreover, SRP does not require the server to hold the user's password. 
This kind of protection is similar to the one used traditionally in the <acronym>UNIX</acronym>
<samp><span class="file">/etc/passwd</span></samp> file, where the contents of this file did not cause
harm to the system security if they were revealed.  The <acronym>SRP</acronym>
needs instead of the plain password something called a verifier, which
is calculated using the user's password, and if stolen cannot be used
to impersonate the user. 
The Stanford <acronym>SRP</acronym> libraries, include a PAM module that synchronizes
the system's users passwords with the <acronym>SRP</acronym> password
files. That way <acronym>SRP</acronym> authentication could be used for all users
of a system.

<p>The implementation in <acronym>GnuTLS</acronym> is based on [<em>TLSSRP</em>]. The
supported key exchange methods are shown below.

     <dl>
<dt><code>SRP:</code><dd>Authentication using the <acronym>SRP</acronym> protocol.

     <br><dt><code>SRP_DSS:</code><dd>Client authentication using the <acronym>SRP</acronym> protocol. Server is
authenticated using a certificate with DSA parameters.

     <br><dt><code>SRP_RSA:</code><dd>Client authentication using the <acronym>SRP</acronym> protocol. Server is
authenticated using a certificate with RSA parameters.

</dl>

<p>Helper functions are included in <acronym>GnuTLS</acronym>, used to generate and
maintain <acronym>SRP</acronym> verifiers and password files.  A program to
manipulate the required parameters for <acronym>SRP</acronym> authentication is
also included.  See <a href="#srptool">srptool</a>, for more information.

     <ul>
<li><a href="#gnutls_005fsrp_005fverifier">gnutls_srp_verifier</a>
</ul>

     <ul>
<li><a href="#gnutls_005fsrp_005fbase64_005fencode">gnutls_srp_base64_encode</a>
<li><a href="#gnutls_005fsrp_005fbase64_005fdecode">gnutls_srp_base64_decode</a>
</ul>

<div class="node">
<a name="Invoking-srptool"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Authentication-using-SRP">Authentication using SRP</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#SRP-authentication">SRP authentication</a>

</div>

<h4 class="subsection">5.1.2 Invoking srptool</h4>

<p><a name="srptool"></a><a name="index-srptool-36"></a>
The <samp><span class="file">srptool</span></samp> is a very simple program that emulates the programs
in the <em>Stanford SRP libraries</em><a rel="footnote" href="#fn-8" name="fnd-8"><sup>8</sup></a>. It requires two files,
one called <code>tpasswd</code> which holds usernames and verifiers,
and <code>tpasswd.conf</code> which holds generators and primes.

<p>To create tpasswd.conf which holds the generator and prime values for
the <acronym>SRP</acronym> protocol, run:

<pre class="smallexample">     $ srptool --create-conf /etc/tpasswd.conf
</pre>
<p>This command will create /etc/tpasswd and will add user 'test' (you
will also be prompted for a password).  Verifiers are stored in a way that
is compatible with libsrp.

<pre class="smallexample">     $ srptool --passwd /etc/tpasswd \
         --passwd-conf /etc/tpasswd.conf -u test
</pre>
<p>This command will check against a password.  If the password matches
the one in /etc/tpasswd you will get an ok.

<pre class="smallexample">     $ srptool --passwd /etc/tpasswd \
         --passwd-conf /etc/tpasswd.conf --verify -u test
</pre>
<div class="node">
<a name="PSK-authentication"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Anonymous-authentication">Anonymous authentication</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#SRP-authentication">SRP authentication</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Shared_002dkey-and-anonymous-authentication">Shared-key and anonymous authentication</a>

</div>

<h3 class="section">5.2 PSK authentication</h3>

<ul class="menu">
<li><a accesskey="1" href="#Authentication-using-PSK">Authentication using PSK</a>
<li><a accesskey="2" href="#Invoking-psktool">Invoking psktool</a>
</ul>

<div class="node">
<a name="Authentication-using-PSK"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Invoking-psktool">Invoking psktool</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#PSK-authentication">PSK authentication</a>

</div>

<h4 class="subsection">5.2.1 Authentication using <acronym>PSK</acronym></h4>

<p><a name="index-PSK-authentication-37"></a>
Authentication using Pre-shared keys is a method to authenticate using
usernames and binary keys. This protocol avoids making use of public
key infrastructure and expensive calculations, thus it is suitable for
constraint clients.

<p>The implementation in <acronym>GnuTLS</acronym> is based on [<em>TLSPSK</em>]. 
The supported <acronym>PSK</acronym> key exchange methods are:

     <dl>
<dt><code>PSK:</code><dd>Authentication using the <acronym>PSK</acronym> protocol.

     <br><dt><code>DHE-PSK:</code><dd>Authentication using the <acronym>PSK</acronym> protocol and Diffie-Hellman key
exchange.  This method offers perfect forward secrecy.

     <br><dt><code>ECDHE-PSK:</code><dd>Authentication using the <acronym>PSK</acronym> protocol and Elliptic curve Diffie-Hellman key
exchange.  This method offers perfect forward secrecy.

</dl>

<p>Helper functions to generate and maintain <acronym>PSK</acronym> keys are also included
in <acronym>GnuTLS</acronym>.

     <ul>
<li><a href="#gnutls_005fkey_005fgenerate">gnutls_key_generate</a>
<li><a href="#gnutls_005fhex_005fencode">gnutls_hex_encode</a>
<li><a href="#gnutls_005fhex_005fdecode">gnutls_hex_decode</a>
</ul>

<div class="node">
<a name="Invoking-psktool"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Authentication-using-PSK">Authentication using PSK</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#PSK-authentication">PSK authentication</a>

</div>

<h4 class="subsection">5.2.2 Invoking psktool</h4>

<p><a name="index-psktool-38"></a>
This is a program to manage <acronym>PSK</acronym> username and keys. 
It will generate random keys for the indicated username,
using a simple password file format.

<pre class="smallexample">     PSKtool help
     Usage : psktool [options]
          -u, --username username
                                   specify username.
          -p, --passwd FILE        specify a password file.
          -s, --keysize SIZE       specify the key size in bytes.
          -v, --version            prints the program's version number
          -h, --help               shows this help text
</pre>
<p>The generation of a PSK password file is illustrated in the example below. 
The password is provided in the prompt.

<pre class="smallexample">     $ ./psktool -u psk_identity -p psks.txt
     Generating a random key for user 'psk_identity'
     Key stored to psks.txt
     $ cat psks.txt
     psk_identity:88f3824b3e5659f52d00e959bacab954b6540344
     $
</pre>
<div class="node">
<a name="Anonymous-authentication"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#PSK-authentication">PSK authentication</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Shared_002dkey-and-anonymous-authentication">Shared-key and anonymous authentication</a>

</div>

<h3 class="section">5.3 Anonymous authentication</h3>

<p><a name="index-anonymous-authentication-39"></a>
The anonymous key exchange offers encryption without any
indication of the peer's identity.  This kind of authentication
is vulnerable to a man in the middle attack, but can be
used even if there is no prior communication or shared trusted parties
with the peer. Moreover it is useful when complete anonymity is required. 
Unless in one of the above cases, do not use anonymous authentication.

<p>The available key exchange algorithms for anonymous authentication are
shown below.

     <dl>
<dt><code>ANON_DH:</code><dd>This algorithm exchanges Diffie-Hellman parameters.

     <br><dt><code>ANON_ECDH:</code><dd>This algorithm exchanges elliptic curve Diffie-Hellman parameters. It is more
efficient than ANON_DH on equivalent security levels.

</dl>

<div class="node">
<a name="More-on-certificate-authentication"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#How-to-use-GnuTLS-in-applications">How to use GnuTLS in applications</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Shared_002dkey-and-anonymous-authentication">Shared-key and anonymous authentication</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">6 More on certificate authentication</h2>

<p><a name="index-certificate-authentication-40"></a>

<ul class="menu">
<li><a accesskey="1" href="#PKCS-10-certificate-requests">PKCS 10 certificate requests</a>
<li><a accesskey="2" href="#PKIX-certificate-revocation-lists">PKIX certificate revocation lists</a>
<li><a accesskey="3" href="#Managing-encrypted-keys">Managing encrypted keys</a>
<li><a accesskey="4" href="#The-certtool-application">The certtool application</a>
<li><a accesskey="5" href="#Hardware-tokens">Hardware tokens</a>
<li><a accesskey="6" href="#Abstract-key-types">Abstract key types</a>
</ul>

<div class="node">
<a name="PKCS-10-certificate-requests"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#PKIX-certificate-revocation-lists">PKIX certificate revocation lists</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#More-on-certificate-authentication">More on certificate authentication</a>

</div>

<h3 class="section">6.1 <acronym>PKCS</acronym> #10 certificate requests</h3>

<p><a name="index-certificate-requests-41"></a><a name="index-PKCS-_002310-42"></a>
A certificate request is a structure, which contain information about
an applicant of a certificate service.  It usually contains a private
key, a distinguished name and secondary data such as a challenge
password. <acronym>GnuTLS</acronym> supports the requests defined in
<acronym>PKCS</acronym> #10 [<em>RFC2986</em>]. Other formats of certificate requests
are not currently supported.

<p>A certificate request can be generated by
associating it with a private key, setting the
subject's information and finally self signing it. 
The last step ensures that the requester is in
possession of the private key.

     <ul>
<li><a href="#gnutls_005fx509_005fcrq_005fset_005fversion">gnutls_x509_crq_set_version</a>
<li><a href="#gnutls_005fx509_005fcrq_005fset_005fdn_005fby_005foid">gnutls_x509_crq_set_dn_by_oid</a>
<li><a href="#gnutls_005fx509_005fcrq_005fset_005fkey_005fusage">gnutls_x509_crq_set_key_usage</a>
<li><a href="#gnutls_005fx509_005fcrq_005fset_005fkey_005fpurpose_005foid">gnutls_x509_crq_set_key_purpose_oid</a>
<li><a href="#gnutls_005fx509_005fcrq_005fset_005fbasic_005fconstraints">gnutls_x509_crq_set_basic_constraints</a>
</ul>

<p>The <a href="#gnutls_005fx509_005fcrq_005fset_005fkey">gnutls_x509_crq_set_key</a> and <a href="#gnutls_005fx509_005fcrq_005fsign2">gnutls_x509_crq_sign2</a>
functions associate the request with a private key and sign it. If a
request is to be signed with a key residing in a PKCS #11 token it is recommended to use
the signing functions shown in <a href="#Abstract-key-types">Abstract key types</a>.

     <ul>
<li><a href="#gnutls_005fx509_005fcrq_005fset_005fkey">gnutls_x509_crq_set_key</a>
</ul>

     <ul>
<li><a href="#gnutls_005fx509_005fcrq_005fsign2">gnutls_x509_crq_sign2</a>
</ul>

<p>The following example is about generating a certificate request, and a
private key. A certificate request can be later be processed by a CA
which should return a signed certificate.

<p><a name="ex_003acrq"></a>

<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h>
#endif

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#include &lt;gnutls/gnutls.h>
#include &lt;gnutls/x509.h>
#include &lt;gnutls/abstract.h>
#include &lt;time.h>

/* This example will generate a private key and a certificate
 * request.
 */

int
main (void)
{
  gnutls_x509_crq_t crq;
  gnutls_x509_privkey_t key;
  unsigned char buffer[10 * 1024];
  size_t buffer_size = sizeof (buffer);
  unsigned int bits;

  gnutls_global_init ();

  /* Initialize an empty certificate request, and
   * an empty private key.
   */
  gnutls_x509_crq_init (&amp;crq);

  gnutls_x509_privkey_init (&amp;key);

  /* Generate an RSA key of moderate security.
   */
  bits = gnutls_sec_param_to_pk_bits (GNUTLS_PK_RSA, GNUTLS_SEC_PARAM_NORMAL);
  gnutls_x509_privkey_generate (key, GNUTLS_PK_RSA, bits, 0);

  /* Add stuff to the distinguished name
   */
  gnutls_x509_crq_set_dn_by_oid (crq, GNUTLS_OID_X520_COUNTRY_NAME,
                                 0, "GR", 2);

  gnutls_x509_crq_set_dn_by_oid (crq, GNUTLS_OID_X520_COMMON_NAME,
                                 0, "Nikos", strlen ("Nikos"));

  /* Set the request version.
   */
  gnutls_x509_crq_set_version (crq, 1);

  /* Set a challenge password.
   */
  gnutls_x509_crq_set_challenge_password (crq, "something to remember here");

  /* Associate the request with the private key
   */
  gnutls_x509_crq_set_key (crq, key);

  /* Self sign the certificate request.
   */
  gnutls_x509_crq_sign2 (crq, key, GNUTLS_DIG_SHA1, 0);

  /* Export the PEM encoded certificate request, and
   * display it.
   */
  gnutls_x509_crq_export (crq, GNUTLS_X509_FMT_PEM, buffer, &amp;buffer_size);

  printf ("Certificate Request: \n%s", buffer);


  /* Export the PEM encoded private key, and
   * display it.
   */
  buffer_size = sizeof (buffer);
  gnutls_x509_privkey_export (key, GNUTLS_X509_FMT_PEM, buffer, &amp;buffer_size);

  printf ("\n\nPrivate key: \n%s", buffer);

  gnutls_x509_crq_deinit (crq);
  gnutls_x509_privkey_deinit (key);

  return 0;

}
</pre>
<div class="node">
<a name="PKIX-certificate-revocation-lists"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Managing-encrypted-keys">Managing encrypted keys</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#PKCS-10-certificate-requests">PKCS 10 certificate requests</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#More-on-certificate-authentication">More on certificate authentication</a>

</div>

<h3 class="section">6.2 PKIX certificate revocation lists</h3>

<p><a name="index-certificate-revocation-lists-43"></a><a name="index-CRL-44"></a>
A certificate revocation list (CRL) is a structure issued by an authority
periodically containing a list of revoked certificates serial numbers. 
The CRL structure is signed with the issuing authorities' keys. A typical
CRL contains the fields as shown in <a href="#tab_003acrl">tab:crl</a>. 
Certificate revocation lists are used to complement the expiration date of a certificate,
in order to account for other reasons of revocation, such as compromised keys, etc.

<p>A certificate request can be generated by
associating it with a private key, setting the
subject's information and finally self signing it. 
The last step ensures that the requester is in
possession of the private key. Each CRL is valid for limited amount of
time and is required to provide, except for the current issuing time, also
the issuing time of the next update.

<div class="float">
<a name="tab_003acrl"></a>
<p><table summary="">
<tr align="left"><th valign="top" width="20%">Field </th><th valign="top" width="70%">Description

<p><br></th></tr><tr align="left"><td valign="top" width="20%">version </td><td valign="top" width="70%">
The field that indicates the version of the CRL structure.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">signature </td><td valign="top" width="70%">
A signature by the issuing authority.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">issuer </td><td valign="top" width="70%">
Holds the issuer's distinguished name.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">thisUpdate </td><td valign="top" width="70%">
The issuing time of the revocation list.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">nextUpdate </td><td valign="top" width="70%">
The issuing time of the revocation list that will update that one.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">revokedCertificates </td><td valign="top" width="70%">
List of revoked certificates serial numbers.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">extensions </td><td valign="top" width="70%">
Optional CRL structure extensions.

<br></td></tr></table>

<p><strong class="float-caption">Table 6.1: Certificate revocation list fields.</strong></p></div>

     <ul>
<li><a href="#gnutls_005fx509_005fcrl_005fset_005fversion">gnutls_x509_crl_set_version</a>
<li><a href="#gnutls_005fx509_005fcrl_005fset_005fcrt_005fserial">gnutls_x509_crl_set_crt_serial</a>
<li><a href="#gnutls_005fx509_005fcrl_005fset_005fcrt">gnutls_x509_crl_set_crt</a>
<li><a href="#gnutls_005fx509_005fcrl_005fset_005fnext_005fupdate">gnutls_x509_crl_set_next_update</a>
<li><a href="#gnutls_005fx509_005fcrl_005fset_005fthis_005fupdate">gnutls_x509_crl_set_this_update</a>
</ul>

<p>The <a href="#gnutls_005fx509_005fcrl_005fsign2">gnutls_x509_crl_sign2</a> and <a href="#gnutls_005fx509_005fcrl_005fprivkey_005fsign">gnutls_x509_crl_privkey_sign</a>
functions sign the revocation list with a private key. The latter function
can be used to sign with a key residing in a PKCS #11 token.

     <ul>
<li><a href="#gnutls_005fx509_005fcrl_005fsign2">gnutls_x509_crl_sign2</a>
</ul>

     <ul>
<li><a href="#gnutls_005fx509_005fcrl_005fprivkey_005fsign">gnutls_x509_crl_privkey_sign</a>
</ul>

<p>Few extensions on the CRL structure are supported, including the
CRL number extension and the authority key identifier.

     <ul>
<li><a href="#gnutls_005fx509_005fcrl_005fset_005fnumber">gnutls_x509_crl_set_number</a>
<li><a href="#gnutls_005fx509_005fcrl_005fset_005fauthority_005fkey_005fid">gnutls_x509_crl_set_authority_key_id</a>
</ul>

<div class="node">
<a name="Managing-encrypted-keys"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-certtool-application">The certtool application</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#PKIX-certificate-revocation-lists">PKIX certificate revocation lists</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#More-on-certificate-authentication">More on certificate authentication</a>

</div>

<h3 class="section">6.3 Managing encrypted keys</h3>

<p><a name="index-Encrypted-keys-45"></a>
Transferring or storing private keys in plain might not be a
good idea. Any access on the keys becomes a fatal compromise. 
Storing the keys in hardware tokens (see <a href="#Hardware-tokens">Hardware tokens</a>)
could solve the storage problem but it is not always practical
or efficient enough. This section describes alternative ways
that involve encryption of the private keys to store and
transfer.

<p>There are two alternatives to use for key encryption,
PKCS #8 and #12 methods of private key encryption. The PKCS #8
method only allows encryption of the private key, whilst the
PKCS #12 method allows in addition the bundling of other
data into the structure. That could be bundling together the
certificate as well as the trusted CA certificate.

<h4 class="subheading"><acronym>PKCS</acronym> #8 structures</h4>

<p><a name="index-PKCS-_00238-46"></a>
PKCS #8 keys can be imported and exported as normal private keys using
the functions below. An addition to the normal import functions, are
a password and a flags argument. The flags can be any element of the <code>gnutls_pkcs_encrypt_flags_t</code>
enumeration. Note however, that GnuTLS only supports the PKCS #5 PBES2
encryption scheme. Keys encrypted with the obsolete PBES1 scheme cannot
be decrypted.

     <ul>
<li><a href="#gnutls_005fx509_005fprivkey_005fimport_005fpkcs8">gnutls_x509_privkey_import_pkcs8</a>
<li><a href="#gnutls_005fx509_005fprivkey_005fexport_005fpkcs8">gnutls_x509_privkey_export_pkcs8</a>
</ul>

<div class="float">
<a name="gnutls_005fpkcs_005fencrypt_005fflags_005ft"></a>
     <ul>
<li>GNUTLS_PKCS_PLAIN
Unencrypted private key. 
<li>GNUTLS_PKCS8_PLAIN
Same as <code>GNUTLS_PKCS_PLAIN</code>. 
<li>GNUTLS_PKCS_USE_PKCS12_3DES
PKCS-12 3DES. 
<li>GNUTLS_PKCS8_USE_PKCS12_3DES
Same as <code>GNUTLS_PKCS_USE_PKCS12_3DES</code>. 
<li>GNUTLS_PKCS_USE_PKCS12_ARCFOUR
PKCS-12 ARCFOUR. 
<li>GNUTLS_PKCS8_USE_PKCS12_ARCFOUR
Same as <code>GNUTLS_PKCS_USE_PKCS12_ARCFOUR</code>. 
<li>GNUTLS_PKCS_USE_PKCS12_RC2_40
PKCS-12 RC2-40. 
<li>GNUTLS_PKCS8_USE_PKCS12_RC2_40
Same as <code>GNUTLS_PKCS_USE_PKCS12_RC2_40</code>. 
<li>GNUTLS_PKCS_USE_PBES2_3DES
PBES2 3DES. 
<li>GNUTLS_PKCS_USE_PBES2_AES_128
PBES2 AES-128. 
<li>GNUTLS_PKCS_USE_PBES2_AES_192
PBES2 AES-192. 
<li>GNUTLS_PKCS_USE_PBES2_AES_256
PBES2 AES-256. 
</ul>
<p><strong class="float-caption">Table 6.2</strong></p></div>

<h4 class="subheading"><acronym>PKCS</acronym> #12 structures</h4>

<p><a name="index-PKCS-_002312-47"></a>
A <acronym>PKCS</acronym> #12 structure [<em>PKCS12</em>] usually contains a user's
private keys and certificates. It is commonly used in browsers to
export and import the user's identities.

<p>In <acronym>GnuTLS</acronym> the <acronym>PKCS</acronym> #12 structures are handled
using the <code>gnutls_pkcs12_t</code> type. This is an abstract type that
may hold several <code>gnutls_pkcs12_bag_t</code> types.  The bag types are
the holders of the actual data, which may be certificates, private
keys or encrypted data.  A bag of type encrypted should be decrypted
in order for its data to be accessed.

<p>The following functions are available to read a <acronym>PKCS</acronym> #12
structure.

     <ul>
<li><a href="#gnutls_005fpkcs12_005fget_005fbag">gnutls_pkcs12_get_bag</a>
<li><a href="#gnutls_005fpkcs12_005fverify_005fmac">gnutls_pkcs12_verify_mac</a>
<li><a href="#gnutls_005fpkcs12_005fbag_005fdecrypt">gnutls_pkcs12_bag_decrypt</a>
</ul>

     <ul>
<li><a href="#gnutls_005fpkcs12_005fbag_005fget_005fcount">gnutls_pkcs12_bag_get_count</a>
<li><a href="#gnutls_005fpkcs12_005fbag_005fget_005fdata">gnutls_pkcs12_bag_get_data</a>
<li><a href="#gnutls_005fpkcs12_005fbag_005fget_005fkey_005fid">gnutls_pkcs12_bag_get_key_id</a>
<li><a href="#gnutls_005fpkcs12_005fbag_005fget_005ffriendly_005fname">gnutls_pkcs12_bag_get_friendly_name</a>
</ul>

<p>The functions below are used to generate a PKCS #12 structure. An example
of their usage is also shown.

     <ul>
<li><a href="#gnutls_005fpkcs12_005fset_005fbag">gnutls_pkcs12_set_bag</a>
<li><a href="#gnutls_005fpkcs12_005fbag_005fencrypt">gnutls_pkcs12_bag_encrypt</a>
<li><a href="#gnutls_005fpkcs12_005fgenerate_005fmac">gnutls_pkcs12_generate_mac</a>
</ul>

     <ul>
<li><a href="#gnutls_005fpkcs12_005fbag_005fset_005fdata">gnutls_pkcs12_bag_set_data</a>
<li><a href="#gnutls_005fpkcs12_005fbag_005fset_005fcrl">gnutls_pkcs12_bag_set_crl</a>
<li><a href="#gnutls_005fpkcs12_005fbag_005fset_005fcrt">gnutls_pkcs12_bag_set_crt</a>
<li><a href="#gnutls_005fpkcs12_005fbag_005fset_005fkey_005fid">gnutls_pkcs12_bag_set_key_id</a>
<li><a href="#gnutls_005fpkcs12_005fbag_005fset_005ffriendly_005fname">gnutls_pkcs12_bag_set_friendly_name</a>
</ul>

<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h>
#endif

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;gnutls/gnutls.h>
#include &lt;gnutls/pkcs12.h>

#include "examples.h"

#define OUTFILE "out.p12"

/* This function will write a pkcs12 structure into a file.
 * cert: is a DER encoded certificate
 * pkcs8_key: is a PKCS #8 encrypted key (note that this must be
 *  encrypted using a PKCS #12 cipher, or some browsers will crash)
 * password: is the password used to encrypt the PKCS #12 packet.
 */
int
write_pkcs12 (const gnutls_datum_t * cert,
              const gnutls_datum_t * pkcs8_key, const char *password)
{
  gnutls_pkcs12_t pkcs12;
  int ret, bag_index;
  gnutls_pkcs12_bag_t bag, key_bag;
  char pkcs12_struct[10 * 1024];
  size_t pkcs12_struct_size;
  FILE *fd;

  /* A good idea might be to use gnutls_x509_privkey_get_key_id()
   * to obtain a unique ID.
   */
  gnutls_datum_t key_id = { (char *) "\x00\x00\x07", 3 };

  gnutls_global_init ();

  /* Firstly we create two helper bags, which hold the certificate,
   * and the (encrypted) key.
   */

  gnutls_pkcs12_bag_init (&amp;bag);
  gnutls_pkcs12_bag_init (&amp;key_bag);

  ret = gnutls_pkcs12_bag_set_data (bag, GNUTLS_BAG_CERTIFICATE, cert);
  if (ret &lt; 0)
    {
      fprintf (stderr, "ret: %s\n", gnutls_strerror (ret));
      return 1;
    }

  /* ret now holds the bag's index.
   */
  bag_index = ret;

  /* Associate a friendly name with the given certificate. Used
   * by browsers.
   */
  gnutls_pkcs12_bag_set_friendly_name (bag, bag_index, "My name");

  /* Associate the certificate with the key using a unique key
   * ID.
   */
  gnutls_pkcs12_bag_set_key_id (bag, bag_index, &amp;key_id);

  /* use weak encryption for the certificate. 
   */
  gnutls_pkcs12_bag_encrypt (bag, password, GNUTLS_PKCS_USE_PKCS12_RC2_40);

  /* Now the key.
   */

  ret = gnutls_pkcs12_bag_set_data (key_bag,
                                    GNUTLS_BAG_PKCS8_ENCRYPTED_KEY,
                                    pkcs8_key);
  if (ret &lt; 0)
    {
      fprintf (stderr, "ret: %s\n", gnutls_strerror (ret));
      return 1;
    }

  /* Note that since the PKCS #8 key is already encrypted we don't
   * bother encrypting that bag.
   */
  bag_index = ret;

  gnutls_pkcs12_bag_set_friendly_name (key_bag, bag_index, "My name");

  gnutls_pkcs12_bag_set_key_id (key_bag, bag_index, &amp;key_id);


  /* The bags were filled. Now create the PKCS #12 structure.
   */
  gnutls_pkcs12_init (&amp;pkcs12);

  /* Insert the two bags in the PKCS #12 structure.
   */

  gnutls_pkcs12_set_bag (pkcs12, bag);
  gnutls_pkcs12_set_bag (pkcs12, key_bag);


  /* Generate a message authentication code for the PKCS #12
   * structure.
   */
  gnutls_pkcs12_generate_mac (pkcs12, password);

  pkcs12_struct_size = sizeof (pkcs12_struct);
  ret =
    gnutls_pkcs12_export (pkcs12, GNUTLS_X509_FMT_DER, pkcs12_struct,
                          &amp;pkcs12_struct_size);
  if (ret &lt; 0)
    {
      fprintf (stderr, "ret: %s\n", gnutls_strerror (ret));
      return 1;
    }

  fd = fopen (OUTFILE, "w");
  if (fd == NULL)
    {
      fprintf (stderr, "cannot open file\n");
      return 1;
    }
  fwrite (pkcs12_struct, 1, pkcs12_struct_size, fd);
  fclose (fd);

  gnutls_pkcs12_bag_deinit (bag);
  gnutls_pkcs12_bag_deinit (key_bag);
  gnutls_pkcs12_deinit (pkcs12);

  return 0;
}
</pre>
<div class="node">
<a name="The-certtool-application"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Hardware-tokens">Hardware tokens</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Managing-encrypted-keys">Managing encrypted keys</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#More-on-certificate-authentication">More on certificate authentication</a>

</div>

<h3 class="section">6.4 The certtool application</h3>

<p><a name="index-certtool-48"></a>
This is a program to generate <acronym>X.509</acronym> certificates, certificate
requests, CRLs and private keys.

<pre class="example">     Certtool help
     Usage: certtool [options]
          -s, --generate-self-signed
                                   Generate a self-signed certificate.
          -c, --generate-certificate
                                   Generate a signed certificate.
          --generate-proxy         Generate a proxy certificate.
          --generate-crl           Generate a CRL.
          -u, --update-certificate
                                   Update a signed certificate.
          -p, --generate-privkey   Generate a private key.
          -q, --generate-request   Generate a PKCS #10 certificate
                                   request.
          -e, --verify-chain       Verify a PEM encoded certificate chain.
                                   The last certificate in the chain must
                                   be a self signed one.
          --verify                 Verify a PEM encoded certificate chain.
                                   CA certificates must be loaded with
                                   --load-ca-certificate.
          --verify-crl             Verify a CRL.
          --generate-dh-params     Generate PKCS #3 encoded Diffie-Hellman
                                   parameters.
          --get-dh-params          Get the included PKCS #3 encoded
                                   Diffie-Hellman parameters.
          --load-privkey FILE      Private key file to use.
          --load-pubkey FILE       Public key file to use.
          --load-request FILE      Certificate request file to use.
          --load-certificate FILE
                                   Certificate file to use.
          --load-ca-privkey FILE   Certificate authority's private key
                                   file to use.
          --load-ca-certificate FILE
                                   Certificate authority's certificate
                                   file to use.
          --password PASSWORD      Password to use.
          -i, --certificate-info   Print information on a certificate.
          --certificate-pubkey     Print certificate public key.
          --pgp-certificate-info   Print information on a OpenPGP
                                   certificate.
          --pgp-ring-info          Print information on a keyring
                                   structure.
          -l, --crl-info           Print information on a CRL.
          --crq-info               Print information on a Certificate
                                   Request.
          --no-crq-extensions      Do not use extensions in certificate
                                   requests.
          --p12-info               Print information on a PKCS #12
                                   structure.
          --p7-info                Print information on a PKCS #7
                                   structure.
          --smime-to-p7            Convert S/MIME to PKCS #7 structure.
          -k, --key-info           Print information on a private key.
          --pgp-key-info           Print information on a OpenPGP private
                                   key.
          --pubkey-info            Print information on a public key.
          --fix-key                Regenerate the parameters in a private
                                   key.
          --v1                     Generate an X.509 version 1 certificate
                                   (no extensions).
          --to-p12                 Generate a PKCS #12 structure.
          --to-p8                  Generate a PKCS #8 key structure.
          -8, --pkcs8              Use PKCS #8 format for private keys.
          --dsa                    Use DSA keys.
          --ecc                    Use ECC (ECDSA) keys.
          --hash STR               Hash algorithm to use for signing
                                   (MD5,SHA1,RMD160,SHA256,SHA384,SHA512).
          --export-ciphers         Use weak encryption algorithms.
          --inder                  Use DER format for input certificates
                                   and private keys.
          --inraw                  Use RAW/DER format for input
                                   certificates and private keys.
          --outder                 Use DER format for output certificates
                                   and private keys.
          --outraw                 Use RAW/DER format for output
                                   certificates and private keys.
          --bits BITS              specify the number of bits for key
                                   generation.
          --sec-param PARAM        specify the security level
                                   [low|normal|high|ultra].
          --disable-quick-random   Use /dev/random for key generationg,
                                   thus increasing the quality of
                                   randomness used.
          --outfile FILE           Output file.
          --infile FILE            Input file.
          --template FILE          Template file to use for non
                                   interactive operation.
          --pkcs-cipher CIPHER     Cipher to use for pkcs operations
                                   (3des,3des-pkcs12,aes-128,aes-192,aes-25
                                   6,rc2-40,arcfour).
          -d, --debug LEVEL        specify the debug level. Default is 1.
          -h, --help               shows this help text
          -v, --version            shows the program's version
</pre>
<p>The program can be used interactively or non interactively by
specifying the <code>--template</code> command line option. See below for an
example of a template file.

<h4 class="subheading">Diffie-Hellman parameter generation</h4>

<p>To generate parameters for Diffie-Hellman key exchange, use the command:
<pre class="smallexample">     $ certtool --generate-dh-params --outfile dh.pem
</pre>
<h4 class="subheading">Self-signed certificate generation</h4>

<p>To create a self signed certificate, use the command:
<pre class="smallexample">     $ certtool --generate-privkey --outfile ca-key.pem
     $ certtool --generate-self-signed --load-privkey ca-key.pem \
        --outfile ca-cert.pem
</pre>
<p>Note that a self-signed certificate usually belongs to a certificate
authority, that signs other certificates.

<h4 class="subheading">Private key generation</h4>

<p>To create a private key (RSA by default), run:

<pre class="smallexample">     $ certtool --generate-privkey --outfile key.pem
</pre>
<p>To create a DSA or elliptic curves (ECDSA) private key use the
above command combined with <code>--dsa</code> or <code>--ecc</code> options.

<h4 class="subheading">Certificate generation</h4>

<p>To generate a certificate using the private key, use the command:

<pre class="smallexample">     $ certtool --generate-certificate --load-privkey key.pem \
        --outfile cert.pem --load-ca-certificate ca-cert.pem \
        --load-ca-privkey ca-key.pem
</pre>
<p>Alternatively you may create a certificate request, which is needed
when the certificate will be signed by a third party authority.

<pre class="smallexample">     $ certtool --generate-request --load-privkey key.pem \
       --outfile request.pem
</pre>
<p>If the private key is stored in a smart card you can generate
a request by specifying the private key object URL (see <a href="#The-p11tool-application">The p11tool application</a>
on how to obtain the URL).

<pre class="smallexample">     $ certtool --generate-request --load-privkey pkcs11:(PRIVKEY URL) \
       --load-pubkey pkcs11:(PUBKEY URL) --outfile request.pem
</pre>
<p>To generate a certificate using the previous request, use the command:

<pre class="smallexample">     $ certtool --generate-certificate --load-request request.pem \
        --outfile cert.pem \
        --load-ca-certificate ca-cert.pem --load-ca-privkey ca-key.pem
</pre>
<h4 class="subheading">Certificate information</h4>

<p>To view the certificate information, use:

<pre class="smallexample">     $ certtool --certificate-info --infile cert.pem
</pre>
<h4 class="subheading"><acronym>PKCS</acronym> #12 structure generation</h4>

<p>To generate a <acronym>PKCS</acronym> #12 structure using the previous key and
certificate, use the command:

<pre class="smallexample">     $ certtool --load-certificate cert.pem --load-privkey key.pem \
       --to-p12 --outder --outfile key.p12
</pre>
<p>Some tools (reportedly web browsers) have problems with that file
because it does not contain the CA certificate for the certificate. 
To work around that problem in the tool, you can use the
&ndash;load-ca-certificate parameter as follows:

<pre class="smallexample">     $ certtool --load-ca-certificate ca.pem \
       --load-certificate cert.pem --load-privkey key.pem \
       --to-p12 --outder --outfile key.p12
</pre>
<h4 class="subheading">Proxy certificate generation</h4>

<p>Proxy certificate can be used to delegate your credential to a
temporary, typically short-lived, certificate.  To create one from the
previously created certificate, first create a temporary key and then
generate a proxy certificate for it, using the commands:

<pre class="smallexample">     $ certtool --generate-privkey &gt; proxy-key.pem
     $ certtool --generate-proxy --load-ca-privkey key.pem \
       --load-privkey proxy-key.pem --load-certificate cert.pem \
       --outfile proxy-cert.pem
</pre>
<h4 class="subheading">Certificate revocation list generation</h4>

<p>To create an empty Certificate Revocation List (CRL) do:

<pre class="smallexample">     $ certtool --generate-crl --load-ca-privkey x509-ca-key.pem \
                --load-ca-certificate x509-ca.pem
</pre>
<p>To create a CRL that contains some revoked certificates, place the
certificates in a file and use <code>--load-certificate</code> as follows:

<pre class="smallexample">     $ certtool --generate-crl --load-ca-privkey x509-ca-key.pem \
       --load-ca-certificate x509-ca.pem --load-certificate revoked-certs.pem
</pre>
<p>To verify a Certificate Revocation List (CRL) do:

<pre class="smallexample">     $ certtool --verify-crl --load-ca-certificate x509-ca.pem &lt; crl.pem
</pre>
<h4 class="subheading">Certtool's template file format:</h4>

<p>A template file can be used to avoid the interactive questions of
certtool. Initially create a file named 'cert.cfg' that contains the information
about the certificate. The template can be used as below:

<pre class="smallexample">     $ certtool --generate-certificate cert.pem --load-privkey key.pem  \
        --template cert.cfg \
        --load-ca-certificate ca-cert.pem --load-ca-privkey ca-key.pem
</pre>
<p>An example certtool template file:

<pre class="example">     # X.509 Certificate options
     #
     # DN options
     
     # The organization of the subject.
     organization = "Koko inc."
     
     # The organizational unit of the subject.
     unit = "sleeping dept."
     
     # The locality of the subject.
     # locality =
     
     # The state of the certificate owner.
     state = "Attiki"
     
     # The country of the subject. Two letter code.
     country = GR
     
     # The common name of the certificate owner.
     cn = "Cindy Lauper"
     
     # A user id of the certificate owner.
     #uid = "clauper"
     
     # If the supported DN OIDs are not adequate you can set
     # any OID here.
     # For example set the X.520 Title and the X.520 Pseudonym
     # by using OID and string pairs.
     #dn_oid = "2.5.4.12" "Dr." "2.5.4.65" "jackal"
     
     # This is deprecated and should not be used in new
     # certificates.
     # pkcs9_email = "none@none.org"
     
     # The serial number of the certificate
     serial = 007
     
     # In how many days, counting from today, this certificate will expire.
     expiration_days = 700
     
     # X.509 v3 extensions
     
     # A dnsname in case of a WWW server.
     #dns_name = "www.none.org"
     #dns_name = "www.morethanone.org"
     
     # An IP address in case of a server.
     #ip_address = "192.168.1.1"
     
     # An email in case of a person
     email = "none@none.org"
     
     # An URL that has CRLs (certificate revocation lists)
     # available. Needed in CA certificates.
     #crl_dist_points = "http://www.getcrl.crl/getcrl/"
     
     # Whether this is a CA certificate or not
     #ca
     
     # Whether this certificate will be used for a TLS client
     #tls_www_client
     
     # Whether this certificate will be used for a TLS server
     #tls_www_server
     
     # Whether this certificate will be used to sign data (needed
     # in TLS DHE ciphersuites).
     signing_key
     
     # Whether this certificate will be used to encrypt data (needed
     # in TLS RSA ciphersuites). Note that it is preferred to use different
     # keys for encryption and signing.
     #encryption_key
     
     # Whether this key will be used to sign other certificates.
     #cert_signing_key
     
     # Whether this key will be used to sign CRLs.
     #crl_signing_key
     
     # Whether this key will be used to sign code.
     #code_signing_key
     
     # Whether this key will be used to sign OCSP data.
     #ocsp_signing_key
     
     # Whether this key will be used for time stamping.
     #time_stamping_key
     
     # Whether this key will be used for IPsec IKE operations.
     #ipsec_ike_key
</pre>
<div class="node">
<a name="Hardware-tokens"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Abstract-key-types">Abstract key types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-certtool-application">The certtool application</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#More-on-certificate-authentication">More on certificate authentication</a>

</div>

<h3 class="section">6.5 Security modules</h3>

<p><a name="index-PKCS-_002311-tokens-49"></a><a name="index-hardware-tokens-50"></a><a name="index-hardware-security-modules-51"></a><a name="index-smart-cards-52"></a>

<ul class="menu">
<li><a accesskey="1" href="#Introduction-on-security-modules">Introduction on security modules</a>
<li><a accesskey="2" href="#PKCS11-Initialization">PKCS11 Initialization</a>
<li><a accesskey="3" href="#Reading-objects">Reading objects</a>
<li><a accesskey="4" href="#Writing-objects">Writing objects</a>
<li><a accesskey="5" href="#Using-a-PKCS11-token-with-TLS">Using a PKCS11 token with TLS</a>
<li><a accesskey="6" href="#The-p11tool-application">The p11tool application</a>
</ul>

<div class="node">
<a name="Introduction-on-security-modules"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#PKCS11-Initialization">PKCS11 Initialization</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Hardware-tokens">Hardware tokens</a>

</div>

<h4 class="subsection">6.5.1 Introduction</h4>

<p>In this section we present the smart-card and hardware security module support
in <acronym>GnuTLS</acronym> using <acronym>PKCS</acronym> #11 [<em>PKCS11</em>]. Hardware security
modules and smart cards provide a way to store private keys and perform
operations on them without exposing them. This allows decoupling cryptographic
keys from the applications that use them providing an additional security layer. 
Since this can also be achieved in software components such as in Gnome keyring,
we will use the term security module to describe such an isolation interface.

<p><acronym>PKCS</acronym> #11 is plugin API allowing applications to access cryptographic
operations on a security module, as well as to objects residing on it. PKCS
#11 modules exist for hardware tokens such as smart cards<a rel="footnote" href="#fn-9" name="fnd-9"><sup>9</sup></a>,
the trusted
platform module (TPM)<a rel="footnote" href="#fn-10" name="fnd-10"><sup>10</sup></a>
as well as for software modules like <acronym>Gnome Keyring</acronym>. 
The objects residing on a security module may be certificates, public keys,
private keys or secret keys. Of those certificates and public/private key
pairs can be used with <acronym>GnuTLS</acronym>. PKCS #11's main advantage is that
it allows operations on private key objects such as decryption
and signing without exposing the key.

<p>Moreover <acronym>PKCS</acronym> #11 can be (ab)used to allow all applications in the same operating system to access
shared cryptographic keys and certificates in a uniform way, as in <a href="#fig_003apkcs11_002dvision">fig:pkcs11-vision</a>. 
That way applications could load their trusted certificate list, as well as user
certificates from a common PKCS #11 module. Such a provider exists in the <acronym>Gnome</acronym>
system, being the <acronym>Gnome Keyring</acronym>.

<div class="float">
<a name="fig_003apkcs11_002dvision"></a><img src="pkcs11-vision.png" alt="pkcs11-vision.png">

<p><strong class="float-caption">Figure 6.1: PKCS #11 module usage.</strong></p></div>

<div class="node">
<a name="PKCS11-Initialization"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Reading-objects">Reading objects</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction-on-security-modules">Introduction on security modules</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Hardware-tokens">Hardware tokens</a>

</div>

<h4 class="subsection">6.5.2 Initialization</h4>

<p>To allow all the  <acronym>GnuTLS</acronym> applications to access <acronym>PKCS</acronym> #11 tokens
you can use a configuration per module, stored in <code>/etc/pkcs11/modules/</code>. 
These are the configuration files of <acronym>p11-kit</acronym><a rel="footnote" href="#fn-11" name="fnd-11"><sup>11</sup></a>. 
For example a file that will load the <acronym>OpenSC</acronym> module, could be named
<code>/etc/pkcs11/modules/opensc</code> and contain the following:

<pre class="smallexample">     module: /usr/lib/opensc-pkcs11.so
</pre>
<p>If you use this file, then there is no need for other initialization in
<acronym>GnuTLS</acronym>, except for the PIN and token functions. Those allow retrieving a PIN
when accessing a protected object, such as a private key, as well as probe
the user to insert the token. All the initialization functions are below.

     <ul>
<li><a href="#gnutls_005fpkcs11_005finit">gnutls_pkcs11_init</a>
</ul>

     <ul>
<li><a href="#gnutls_005fpkcs11_005fset_005ftoken_005ffunction">gnutls_pkcs11_set_token_function</a>
<li><a href="#gnutls_005fpkcs11_005fset_005fpin_005ffunction">gnutls_pkcs11_set_pin_function</a>
<li><a href="#gnutls_005fpkcs11_005fadd_005fprovider">gnutls_pkcs11_add_provider</a>
</ul>

<p>Note that due to limitations of <acronym>PKCS</acronym> #11 there are issues when multiple libraries
are sharing a module. To avoid this problem GnuTLS uses <acronym>p11-kit</acronym>
that provides a middleware to control access to resources over the
multiple users.

<div class="node">
<a name="Reading-objects"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Writing-objects">Writing objects</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#PKCS11-Initialization">PKCS11 Initialization</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Hardware-tokens">Hardware tokens</a>

</div>

<h4 class="subsection">6.5.3 Reading objects</h4>

<p>All <acronym>PKCS</acronym> #11 objects are referenced by <acronym>GnuTLS</acronym> functions by
URLs as described in [<em>PKCS11URI</em>]. 
This allows for a consistent naming of objects across systems and applications
in the same system. For example a public
key on a smart card may be referenced as:

<pre class="smallexample">     pkcs11:token=Nikos;serial=307521161601031;model=PKCS%2315; \
     manufacturer=EnterSafe;object=test1;objecttype=public;\
     id=32f153f3e37990b08624141077ca5dec2d15faed
</pre>
<p>while the smart card itself can be referenced as:
<pre class="smallexample">     pkcs11:token=Nikos;serial=307521161601031;model=PKCS%2315;manufacturer=EnterSafe
</pre>
<p>Objects stored in a <acronym>PKCS</acronym> #11 token can be extracted
if they are not marked as sensitive. Usually only private keys are marked as
sensitive and cannot be extracted, while certificates and other data can
be retrieved. The functions that can be used to access objects
are shown below.

     <ul>
<li><a href="#gnutls_005fpkcs11_005fobj_005fimport_005furl">gnutls_pkcs11_obj_import_url</a>
<li><a href="#gnutls_005fpkcs11_005fobj_005fexport_005furl">gnutls_pkcs11_obj_export_url</a>
</ul>

     <ul>
<li><a href="#gnutls_005fpkcs11_005fobj_005fget_005finfo">gnutls_pkcs11_obj_get_info</a>
</ul>

     <ul>
<li><a href="#gnutls_005fx509_005fcrt_005fimport_005fpkcs11">gnutls_x509_crt_import_pkcs11</a>
<li><a href="#gnutls_005fx509_005fcrt_005fimport_005fpkcs11_005furl">gnutls_x509_crt_import_pkcs11_url</a>
<li><a href="#gnutls_005fx509_005fcrt_005flist_005fimport_005fpkcs11">gnutls_x509_crt_list_import_pkcs11</a>
</ul>

<p>Properties of the physical token can also be accessed and altered with <acronym>GnuTLS</acronym>. 
For example data in a token can be erased (initialized), PIN can be altered, etc.

     <ul>
<li><a href="#gnutls_005fpkcs11_005ftoken_005finit">gnutls_pkcs11_token_init</a>
<li><a href="#gnutls_005fpkcs11_005ftoken_005fget_005furl">gnutls_pkcs11_token_get_url</a>
<li><a href="#gnutls_005fpkcs11_005ftoken_005fget_005finfo">gnutls_pkcs11_token_get_info</a>
<li><a href="#gnutls_005fpkcs11_005ftoken_005fget_005fflags">gnutls_pkcs11_token_get_flags</a>
<li><a href="#gnutls_005fpkcs11_005ftoken_005fset_005fpin">gnutls_pkcs11_token_set_pin</a>
</ul>

<p>The following examples demonstrate the usage of the API. The first example
will list all available PKCS #11 tokens in a system and the latter will
list all certificates in a token that have a corresponding private key.

<pre class="example">     int i;
     char* url;
     
     gnutls_global_init();
     
     for (i=0;;i++)
       {
         ret = gnutls_pkcs11_token_get_url(i, &amp;url);
         if (ret == GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE)
           break;
     
         if (ret &lt; 0)
           exit(1);
     
         fprintf(stdout, "Token[%d]: URL: %s\n", i, url);
         gnutls_free(url);
       }
     gnutls_global_deinit();
</pre>
<pre class="verbatim">#include &lt;config.h>
#include &lt;gnutls/gnutls.h>
#include &lt;gnutls/pkcs11.h>
#include &lt;stdio.h>
#include &lt;stdlib.h>

#define URL "pkcs11:URL"

int
main (int argc, char** argv)
{
  gnutls_pkcs11_obj_t *obj_list;
  gnutls_x509_crt_t xcrt;
  unsigned int obj_list_size = 0;
  gnutls_datum_t cinfo;
  int i, ret;

  obj_list_size = 0;
  ret = gnutls_pkcs11_obj_list_import_url (NULL, &amp;obj_list_size, URL,
                                       GNUTLS_PKCS11_OBJ_ATTR_CRT_WITH_PRIVKEY,
                                       0);
  if (ret &lt; 0 &amp;&amp; ret != GNUTLS_E_SHORT_MEMORY_BUFFER)
    return -1;

/* no error checking from now on */
  obj_list = malloc (sizeof (*obj_list) * obj_list_size);

  gnutls_pkcs11_obj_list_import_url (obj_list, &amp;obj_list_size, URL,
                                     GNUTLS_PKCS11_OBJ_ATTR_CRT_WITH_PRIVKEY,
                                     0);

/* now all certificates are in obj_list */
  for (i = 0; i &lt; obj_list_size; i++)
    {

      gnutls_x509_crt_init (&amp;xcrt);

      gnutls_x509_crt_import_pkcs11 (xcrt, obj_list[i]);

      gnutls_x509_crt_print (xcrt, GNUTLS_CRT_PRINT_FULL, &amp;cinfo);

      fprintf (stdout, "cert[%d]:\n %s\n\n", i, cinfo.data);

      gnutls_free (cinfo.data);
      gnutls_x509_crt_deinit (xcrt);
    }

  return 0;
}
</pre>
<div class="node">
<a name="Writing-objects"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-a-PKCS11-token-with-TLS">Using a PKCS11 token with TLS</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Reading-objects">Reading objects</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Hardware-tokens">Hardware tokens</a>

</div>

<h4 class="subsection">6.5.4 Writing objects</h4>

<p>With <acronym>GnuTLS</acronym> you can copy existing private keys and certificates
to a token. Note that when copying private keys it is recommended to mark
them as sensitive using the <code>GNUTLS_PKCS11_OBJ_FLAG_MARK_SENSITIVE</code>
to prevent its extraction. An object can be marked as private using the flag
<code>GNUTLS_PKCS11_OBJ_FLAG_MARK_PRIVATE</code>, to require PIN to be
entered before accessing the object (for operations or otherwise).

     <ul>
<li><a href="#gnutls_005fpkcs11_005fcopy_005fx509_005fprivkey">gnutls_pkcs11_copy_x509_privkey</a>
</ul>

     <ul>
<li><a href="#gnutls_005fpkcs11_005fcopy_005fx509_005fcrt">gnutls_pkcs11_copy_x509_crt</a>
</ul>

     <ul>
<li><a href="#gnutls_005fpkcs11_005fdelete_005furl">gnutls_pkcs11_delete_url</a>
</ul>

<div class="node">
<a name="Using-a-PKCS11-token-with-TLS"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-p11tool-application">The p11tool application</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Writing-objects">Writing objects</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Hardware-tokens">Hardware tokens</a>

</div>

<h4 class="subsection">6.5.5 Using a <acronym>PKCS</acronym> #11 token with TLS</h4>

<p>It is possible to use a <acronym>PKCS</acronym> #11 token to a TLS
session, as shown in <a href="#ex_003apkcs11_002dclient">ex:pkcs11-client</a>. In addition
the following functions can be used to load PKCS #11 key and
certificates by specifying a PKCS #11 URL instead of a filename.

     <ul>
<li><a href="#gnutls_005fcertificate_005fset_005fx509_005ftrust_005ffile">gnutls_certificate_set_x509_trust_file</a>
<li><a href="#gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile">gnutls_certificate_set_x509_key_file</a>
</ul>

<div class="node">
<a name="The-p11tool-application"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-a-PKCS11-token-with-TLS">Using a PKCS11 token with TLS</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Hardware-tokens">Hardware tokens</a>

</div>

<h4 class="subsection">6.5.6 The p11tool application</h4>

<p><a name="p11tool"></a><a name="index-p11tool-53"></a>
p11tool is a program that is used to access tokens
and security modules that support the PKCS #11 API. It requires
individual PKCS #11 modules to be loaded either with the
<code>--provider</code> option, or by setting up the GnuTLS configuration
file for PKCS #11 as in <a href="#Hardware-tokens">Hardware tokens</a>.

<pre class="example">     p11tool help
     Usage: p11tool [options]
     Usage: p11tool --list-tokens
     Usage: p11tool --list-all
     Usage: p11tool --export 'pkcs11:...'
     
          --export URL             Export an object specified by a pkcs11
                                   URL
          --list-tokens            List all available tokens
          --list-mechanisms URL    List all available mechanisms in token.
          --list-all               List all objects specified by a PKCS#11
                                   URL
          --list-all-certs         List all certificates specified by a
                                   PKCS#11 URL
          --list-certs             List certificates that have a private
                                   key specified by a PKCS#11 URL
          --list-privkeys          List private keys specified by a
                                   PKCS#11 URL
          --list-trusted           List certificates marked as trusted,
                                   specified by a PKCS#11 URL
          --initialize URL         Initializes a PKCS11 token.
          --write URL              Writes loaded certificates, private or
                                   secret keys to a PKCS11 token.
          --delete URL             Deletes objects matching the URL.
          --label label            Sets a label for the write operation.
          --trusted                Marks the certificate to be written as
                                   trusted.
          --private                Marks the object to be written as
                                   private (requires PIN).
          --no-private             Marks the object to be written as not
                                   private.
          --login                  Force login to token
          --detailed-url           Export detailed URLs.
          --no-detailed-url        Export less detailed URLs.
          --secret-key HEX_KEY     Provide a hex encoded secret key.
          --load-privkey FILE      Private key file to use.
          --load-pubkey FILE       Private key file to use.
          --load-certificate FILE
                                   Certificate file to use.
          -8, --pkcs8              Use PKCS #8 format for private keys.
          --inder                  Use DER format for input certificates
                                   and private keys.
          --inraw                  Use RAW/DER format for input
                                   certificates and private keys.
          --provider Library       Specify the pkcs11 provider library
          --outfile FILE           Output file.
          -d, --debug LEVEL        specify the debug level. Default is 1.
          -h, --help               shows this help text
</pre>
<p>After being provided the available PKCS #11 modules, it can list all tokens
available in your system, the objects on the tokens, and perform operations
on them.

<p>Some examples on how to use p11tool are illustrated in the following  paragraphs.

<h5 class="subsubheading">List all tokens</h5>

<pre class="smallexample">     $ p11tool --list-tokens
</pre>
<h5 class="subsubheading">List all objects</h5>

<p>The following command will list all objects in a token. The <code>--login</code>
is required to show objects marked as private.
<pre class="smallexample">     $ p11tool --login --list-all
</pre>
<h5 class="subsubheading">Exporting an object</h5>

<p>To retrieve an object stored in the card use the following command. 
Note however that objects marked as sensitive (typically PKCS #11 private keys)
are not allowed to be extracted from the token.
<pre class="smallexample">     $ p11tool --login --export [OBJECT URL]
</pre>
<h5 class="subsubheading">Copy an object to a token</h5>

<p>To copy an object, such as a certificate or private key to a token
use the following command.
<pre class="smallexample">     $ p11tool --login --write [TOKEN URL] \
       --load-certificate cert.pem --label "my_cert"
</pre>
<div class="node">
<a name="Abstract-key-types"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Hardware-tokens">Hardware tokens</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#More-on-certificate-authentication">More on certificate authentication</a>

</div>

<h3 class="section">6.6 Abstract key types</h3>

<p><a name="index-abstract-types-54"></a>
Since there are many forms of a public or private keys supported by <acronym>GnuTLS</acronym> such as
<acronym>X.509</acronym>, <acronym>OpenPGP</acronym>, or <acronym>PKCS</acronym> #11 it is desirable to allow common operations
on them. For these reasons the abstract <code>gnutls_privkey_t</code> and <code>gnutls_pubkey_t</code> were
introduced in <code>gnutls/abstract.h</code> header. Those types are initialized using a specific type of
key and then can be used to perform operations in an abstract way. For example in order
to sign an X.509 certificate with a key that resides in a token the following steps must be
used.

<pre class="example">     #inlude &lt;gnutls/abstract.h&gt;
     #inlude &lt;gnutls/pkcs11.h&gt;
     
     void sign_cert( gnutls_x509_crt_t to_be_signed)
     {
     gnutls_pkcs11_privkey_t ca_key;
     gnutls_x509_crt_t ca_cert;
     gnutls_privkey_t abs_key;
     
       /* load the PKCS #11 key and certificates */
       gnutls_pkcs11_privkey_init(&amp;ca_key);
       gnutls_pkcs11_privkey_import_url(ca_key, key_url);
     
       gnutls_x509_crt_init(&amp;ca_cert);
       gnutls_x509_crt_import_pkcs11_url(&amp;ca_cert, cert_url);
     
       /* initialize the abstract key */
       gnutls_privkey_init(&amp;abs_key);
       gnutls_privkey_import_pkcs11(abs_key, ca_key);
     
       /* sign the certificate to be signed */
       gnutls_x509_crt_privkey_sign(to_be_signed, ca_cert, ca_key,
                                    GNUTLS_DIG_SHA256, 0);
     }
</pre>
<ul class="menu">
<li><a accesskey="1" href="#Abstract-public-keys">Abstract public keys</a>
<li><a accesskey="2" href="#Abstract-private-keys">Abstract private keys</a>
<li><a accesskey="3" href="#Operations">Operations</a>
</ul>

<div class="node">
<a name="Abstract-public-keys"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Abstract-private-keys">Abstract private keys</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Abstract-key-types">Abstract key types</a>

</div>

<h4 class="subsection">6.6.1 Public keys</h4>

<p>An abstract <code>gnutls_pubkey_t</code> can be initialized
using the functions below. It can be imported through
an existing structure like <code>gnutls_x509_crt_t</code>,
or through an ASN.1 encoding of the X.509 <code>SubjectPublicKeyInfo</code>
sequence.

     <ul>
<li><a href="#gnutls_005fpubkey_005fimport_005fx509">gnutls_pubkey_import_x509</a>
</ul>

     <ul>
<li><a href="#gnutls_005fpubkey_005fimport_005fopenpgp">gnutls_pubkey_import_openpgp</a>
<li><a href="#gnutls_005fpubkey_005fimport_005fpkcs11">gnutls_pubkey_import_pkcs11</a>
<li><a href="#gnutls_005fpubkey_005fimport_005fpkcs11_005furl">gnutls_pubkey_import_pkcs11_url</a>
<li><a href="#gnutls_005fpubkey_005fimport_005fprivkey">gnutls_pubkey_import_privkey</a>
</ul>

<p>Additional functions are available that will return
information over a public key.

     <ul>
<li><a href="#gnutls_005fpubkey_005fget_005fpk_005falgorithm">gnutls_pubkey_get_pk_algorithm</a>
<li><a href="#gnutls_005fpubkey_005fget_005fpreferred_005fhash_005falgorithm">gnutls_pubkey_get_preferred_hash_algorithm</a>
<li><a href="#gnutls_005fpubkey_005fget_005fkey_005fid">gnutls_pubkey_get_key_id</a>
</ul>

<div class="node">
<a name="Abstract-private-keys"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Operations">Operations</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Abstract-public-keys">Abstract public keys</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Abstract-key-types">Abstract key types</a>

</div>

<h4 class="subsection">6.6.2 Private keys</h4>

<p>An abstract <code>gnutls_privkey_t</code> can be initialized
using the functions below. It can be imported through
an existing structure like <code>gnutls_x509_privkey_t</code>,
but unlike public keys it cannot be exported. That is
to allow abstraction over <acronym>PKCS</acronym> #11 keys that
are not extractable.

     <ul>
<li><a href="#gnutls_005fprivkey_005fimport_005fx509">gnutls_privkey_import_x509</a>
<li><a href="#gnutls_005fprivkey_005fimport_005fopenpgp">gnutls_privkey_import_openpgp</a>
<li><a href="#gnutls_005fprivkey_005fimport_005fpkcs11">gnutls_privkey_import_pkcs11</a>
<li><a href="#gnutls_005fprivkey_005fimport_005fext">gnutls_privkey_import_ext</a>
</ul>

     <ul>
<li><a href="#gnutls_005fprivkey_005fget_005fpk_005falgorithm">gnutls_privkey_get_pk_algorithm</a>
<li><a href="#gnutls_005fprivkey_005fget_005ftype">gnutls_privkey_get_type</a>
</ul>

<div class="node">
<a name="Operations"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Abstract-private-keys">Abstract private keys</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Abstract-key-types">Abstract key types</a>

</div>

<h4 class="subsection">6.6.3 Operations</h4>

<p>The abstract key types can be used to access signing and
signature verification operations with the underlying keys.

     <ul>
<li><a href="#gnutls_005fpubkey_005fverify_005fdata2">gnutls_pubkey_verify_data2</a>
</ul>

     <ul>
<li><a href="#gnutls_005fpubkey_005fverify_005fhash">gnutls_pubkey_verify_hash</a>
</ul>

     <ul>
<li><a href="#gnutls_005fprivkey_005fsign_005fdata">gnutls_privkey_sign_data</a>
</ul>

     <ul>
<li><a href="#gnutls_005fprivkey_005fsign_005fhash">gnutls_privkey_sign_hash</a>
</ul>

<p>Signing existing structures, such as certificates, CRLs,
or certificate requests, as well as associating public
keys with structures is also possible using the
key abstractions.

     <ul>
<li><a href="#gnutls_005fx509_005fcrq_005fset_005fpubkey">gnutls_x509_crq_set_pubkey</a>
</ul>

     <ul>
<li><a href="#gnutls_005fx509_005fcrt_005fset_005fpubkey">gnutls_x509_crt_set_pubkey</a>
</ul>

     <ul>
<li><a href="#gnutls_005fx509_005fcrt_005fprivkey_005fsign">gnutls_x509_crt_privkey_sign</a>
<li><a href="#gnutls_005fx509_005fcrl_005fprivkey_005fsign">gnutls_x509_crl_privkey_sign</a>
<li><a href="#gnutls_005fx509_005fcrq_005fprivkey_005fsign">gnutls_x509_crq_privkey_sign</a>
</ul>

<div class="node">
<a name="How-to-use-GnuTLS-in-applications"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#GnuTLS-application-examples">GnuTLS application examples</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#More-on-certificate-authentication">More on certificate authentication</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">7 How to use <acronym>GnuTLS</acronym> in applications</h2>

<ul class="menu">
<li><a accesskey="1" href="#Introduction-to-the-library">Introduction to the library</a>
<li><a accesskey="2" href="#Preparation">Preparation</a>
<li><a accesskey="3" href="#Session-initialization">Session initialization</a>
<li><a accesskey="4" href="#Associating-the-credentials">Associating the credentials</a>
<li><a accesskey="5" href="#Setting-up-the-transport-layer">Setting up the transport layer</a>
<li><a accesskey="6" href="#TLS-handshake">TLS handshake</a>
<li><a accesskey="7" href="#Data-transfer-and-termination">Data transfer and termination</a>
<li><a accesskey="8" href="#Priority-Strings">Priority Strings</a>
<li><a accesskey="9" href="#Advanced-and-other-topics">Advanced and other topics</a>
<li><a href="#Using-the-cryptographic-library">Using the cryptographic library</a>
<li><a href="#Selecting-cryptographic-key-sizes">Selecting cryptographic key sizes</a>
</ul>

<div class="node">
<a name="Introduction-to-the-library"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Preparation">Preparation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#How-to-use-GnuTLS-in-applications">How to use GnuTLS in applications</a>

</div>

<h3 class="section">7.1 Introduction</h3>

<ul class="menu">
<li><a accesskey="1" href="#General-idea">General idea</a>
<li><a accesskey="2" href="#Error-handling">Error handling</a>
<li><a accesskey="3" href="#Debugging-and-auditing">Debugging and auditing</a>
<li><a accesskey="4" href="#Thread-safety">Thread safety</a>
<li><a accesskey="5" href="#Callback-functions">Callback functions</a>
</ul>

<div class="node">
<a name="General-idea"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Error-handling">Error handling</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction-to-the-library">Introduction to the library</a>

</div>

<h4 class="subsection">7.1.1 General idea</h4>

<p>A brief description of how <acronym>GnuTLS</acronym> works internally is shown
at <a href="#fig_003agnutls_002ddesign">fig:gnutls-design</a>. This section may become more clear after
having read the rest of this section. 
As shown in the figure, there is a read-only global state that is
initialized once by the global initialization function.  This global
structure, among others, contains the memory allocation functions
used, and structures needed for the <acronym>ASN.1</acronym> parser.  This
structure is never modified by any <acronym>GnuTLS</acronym> function, except
for the deinitialization function which frees all allocated memory
and is called after the program has permanently
finished using <acronym>GnuTLS</acronym>.

<div class="float">
<a name="fig_003agnutls_002ddesign"></a><img src="gnutls-internals.png" alt="gnutls-internals.png">

<p><strong class="float-caption">Figure 7.1: High level design of GnuTLS.</strong></p></div>

<p>The credentials structures are used by the authentication methods, such
as certificate authentication. They store certificates, privates keys,
and other information that is needed to prove the identity to the peer,
and/or verify the indentity of the peer. The information stored in
the credentials structures is initialized once and then can be
shared by many <acronym>TLS</acronym> sessions.

<p>A <acronym>GnuTLS</acronym> session contains all the required information
to handle one secure connection. The session communicates with the
peers using the provided functions of the transport layer. 
Every session has a unique session ID shared with the peer.

<p>Since TLS sessions can be resumed, servers need a
database back-end to hold the session's parameters.  Every
<acronym>GnuTLS</acronym> session after a successful handshake calls the
appropriate back-end function (see <a href="#resume">resume</a>)
to store the newly negotiated session. The session
database is examined by the server just after having received the
client hello<a rel="footnote" href="#fn-12" name="fnd-12"><sup>12</sup></a>,
and if the session ID sent by the client, matches a stored session,
the stored session will be retrieved, and the new session will be a
resumed one, and will share the same session ID with the previous one.

<div class="node">
<a name="Error-handling"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Debugging-and-auditing">Debugging and auditing</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#General-idea">General idea</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction-to-the-library">Introduction to the library</a>

</div>

<h4 class="subsection">7.1.2 Error handling</h4>

<p>In <acronym>GnuTLS</acronym> most functions return an integer type as a result. 
In almost all cases a zero or a positive number means success, and a
negative number indicates failure, or a situation that some action has
to be taken. Thus negative error codes may be fatal or not.

<p>Fatal errors terminate the connection immediately and further sends
and receives will be disallowed.  Such an example is
<code>GNUTLS_E_DECRYPTION_FAILED</code>. Non-fatal errors may warn about
something, i.e., a warning alert was received, or indicate the some
action has to be taken. This is the case with the error code
<code>GNUTLS_E_REHANDSHAKE</code> returned by <a href="#gnutls_005frecord_005frecv">gnutls_record_recv</a>. 
This error code indicates that the server requests a re-handshake. The
client may ignore this request, or may reply with an alert.  You can
test if an error code is a fatal one by using the
<a href="#gnutls_005ferror_005fis_005ffatal">gnutls_error_is_fatal</a>.

<p>If any non fatal errors, that require an action, are to be returned by
a function, these error codes will be documented in the function's
reference.  See <a href="#Error-codes">Error codes</a>, for a description of the available
error codes.

<div class="node">
<a name="Debugging-and-auditing"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Thread-safety">Thread safety</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Error-handling">Error handling</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction-to-the-library">Introduction to the library</a>

</div>

<h4 class="subsection">7.1.3 Debugging and auditing</h4>

<p>In many cases things may not go as expected and further information,
to assist debugging, from <acronym>GnuTLS</acronym> is desired. 
Those are the cases where the <a href="#gnutls_005fglobal_005fset_005flog_005flevel">gnutls_global_set_log_level</a> and
<a href="#gnutls_005fglobal_005fset_005flog_005ffunction">gnutls_global_set_log_function</a> are to be used. Those will print
verbose information on the <acronym>GnuTLS</acronym> functions internal flow.

     <ul>
<li><a href="#gnutls_005fglobal_005fset_005flog_005flevel">gnutls_global_set_log_level</a>
<li><a href="#gnutls_005fglobal_005fset_005flog_005ffunction">gnutls_global_set_log_function</a>
</ul>

<p>When debugging is not required, important issues, such as detected
attacks on the protocol still need to be logged. This is provided
by the logging function set by
<a href="#gnutls_005fglobal_005fset_005faudit_005flog_005ffunction">gnutls_global_set_audit_log_function</a>. The provided function
will receive an message and the corresponding
TLS session. The session information might be used to derive IP addresses
or other information about the peer involved.

     <ul>
<li><a href="#gnutls_005fglobal_005fset_005faudit_005flog_005ffunction">gnutls_global_set_audit_log_function</a>
</ul>

<div class="node">
<a name="Thread-safety"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Callback-functions">Callback functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Debugging-and-auditing">Debugging and auditing</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction-to-the-library">Introduction to the library</a>

</div>

<h4 class="subsection">7.1.4 Thread safety</h4>

<p><a name="index-thread-safety-55"></a>
The <acronym>GnuTLS</acronym> library is thread safe by design, meaning that
objects of the library such as TLS sessions, can be safely divided across
threads as long as a single thread accesses a single object. This is
sufficient to support a server which handles several sessions per thread. 
If, however, an object needs to be shared across threads then access must be
protected with a mutex. Read-only access to objects, for example the
credentials holding structures (see <a href="#Authentication">Authentication</a>), is also thread-safe.

<p>The random generator of the cryptographic back-end, is not thread safe and requires
mutex locks which are setup by <acronym>GnuTLS</acronym>. 
Applications can either call <a href="#gnutls_005fglobal_005finit">gnutls_global_init</a> which will initialize the default
operating system provided locks (i.e. <code>pthreads</code> on GNU/Linux and
<code>CriticalSection</code> on Windows), or specify manually the locking system using
the function <a href="#gnutls_005fglobal_005fset_005fmutex">gnutls_global_set_mutex</a> before calling <a href="#gnutls_005fglobal_005finit">gnutls_global_init</a>. 
Setting manually mutexes is recommended
only to applications that have full control of the underlying libraries. If this
is not the case, the use of the operating system defaults is recommended. An example of
non-native thread usage is shown below.

<pre class="example">     #include &lt;gnutls.h&gt;
     
     /* Other thread packages
      */
     
     int main()
     {
        gnutls_global_set_mutex (mutex_init, mutex_deinit,
                                 mutex_lock, mutex_unlock);
        gnutls_global_init();
     }
</pre>
     <ul>
<li><a href="#gnutls_005fglobal_005fset_005fmutex">gnutls_global_set_mutex</a>
</ul>

<div class="node">
<a name="Callback-functions"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Thread-safety">Thread safety</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction-to-the-library">Introduction to the library</a>

</div>

<h4 class="subsection">7.1.5 Callback functions</h4>

<p><a name="index-callback-functions-56"></a>
There are several cases where <acronym>GnuTLS</acronym> may need out of
band input from your program. This is now implemented using some
callback functions, which your program is expected to register.

<p>An example of this type of functions are the push and pull callbacks
which are used to specify the functions that will retrieve and send
data to the transport layer.

     <ul>
<li><a href="#gnutls_005ftransport_005fset_005fpush_005ffunction">gnutls_transport_set_push_function</a>
<li><a href="#gnutls_005ftransport_005fset_005fpull_005ffunction">gnutls_transport_set_pull_function</a>
</ul>

<p>Other callback functions may require more complicated input and data
to be allocated. Such an example is
<a href="#gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffunction">gnutls_srp_set_server_credentials_function</a>. 
All callbacks should allocate and free memory using
<code>gnutls_malloc</code> and <code>gnutls_free</code>.

<div class="node">
<a name="Preparation"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Session-initialization">Session initialization</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction-to-the-library">Introduction to the library</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#How-to-use-GnuTLS-in-applications">How to use GnuTLS in applications</a>

</div>

<h3 class="section">7.2 Preparation</h3>

<p>To use <acronym>GnuTLS</acronym>, you have to perform some changes to your
sources and your build system. The necessary changes are explained in
the following subsections.

<ul class="menu">
<li><a accesskey="1" href="#Headers">Headers</a>
<li><a accesskey="2" href="#Initialization">Initialization</a>
<li><a accesskey="3" href="#Version-check">Version check</a>
<li><a accesskey="4" href="#Building-the-source">Building the source</a>
</ul>

<div class="node">
<a name="Headers"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Initialization">Initialization</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Preparation">Preparation</a>

</div>

<h4 class="subsection">7.2.1 Headers</h4>

<p>All the data types and functions of the <acronym>GnuTLS</acronym> library are
defined in the header file <samp><span class="file">gnutls/gnutls.h</span></samp>.  This must be
included in all programs that make use of the <acronym>GnuTLS</acronym>
library.

<div class="node">
<a name="Initialization"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Version-check">Version check</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Headers">Headers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Preparation">Preparation</a>

</div>

<h4 class="subsection">7.2.2 Initialization</h4>

<p>GnuTLS must be initialized before it can be used.  The library is
initialized by calling <a href="#gnutls_005fglobal_005finit">gnutls_global_init</a>.  The resources
allocated by the initialization process can be released if the
application no longer has a need to call GnuTLS functions, this is
done by calling <a href="#gnutls_005fglobal_005fdeinit">gnutls_global_deinit</a>.

<p>In order to take advantage of the internationalization features in
GnuTLS, such as translated error messages, the application must set
the current locale using <code>setlocale</code> before initializing GnuTLS.

<div class="node">
<a name="Version-check"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Building-the-source">Building the source</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Initialization">Initialization</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Preparation">Preparation</a>

</div>

<h4 class="subsection">7.2.3 Version check</h4>

<p>It is often desirable to check that the version of `gnutls' used is
indeed one which fits all requirements.  Even with binary
compatibility new features may have been introduced but due to problem
with the dynamic linker an old version is actually used.  So you may
want to check that the version is okay right after program start-up. 
See the function <a href="#gnutls_005fcheck_005fversion">gnutls_check_version</a>.

<div class="node">
<a name="Building-the-source"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Version-check">Version check</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Preparation">Preparation</a>

</div>

<h4 class="subsection">7.2.4 Building the source</h4>

<p>If you want to compile a source file including the
<samp><span class="file">gnutls/gnutls.h</span></samp> header file, you must make sure that the
compiler can find it in the directory hierarchy.  This is accomplished
by adding the path to the directory in which the header file is
located to the compilers include file search path (via the <samp><span class="option">-I</span></samp>
option).

<p>However, the path to the include file is determined at the time the
source is configured.  To solve this problem, the library uses the
external package <samp><span class="command">pkg-config</span></samp> that knows the path to the
include file and other configuration options.  The options that need
to be added to the compiler invocation at compile time are output by
the <samp><span class="option">--cflags</span></samp> option to <samp><span class="command">pkg-config gnutls</span></samp>.  The
following example shows how it can be used at the command line:

<pre class="smallexample">     gcc -c foo.c `pkg-config gnutls --cflags`
</pre>
<p>Adding the output of &lsquo;<samp><span class="samp">pkg-config gnutls --cflags</span></samp>&rsquo; to the
compilers command line will ensure that the compiler can find the
<samp><span class="file">gnutls/gnutls.h</span></samp> header file.

<p>A similar problem occurs when linking the program with the library. 
Again, the compiler has to find the library files.  For this to work,
the path to the library files has to be added to the library search
path (via the <samp><span class="option">-L</span></samp> option).  For this, the option
<samp><span class="option">--libs</span></samp> to <samp><span class="command">pkg-config gnutls</span></samp> can be used.  For
convenience, this option also outputs all other options that are
required to link the program with the library (for instance, the
&lsquo;<samp><span class="samp">-ltasn1</span></samp>&rsquo; option).  The example shows how to link <samp><span class="file">foo.o</span></samp>
with the library to a program <samp><span class="command">foo</span></samp>.

<pre class="smallexample">     gcc -o foo foo.o `pkg-config gnutls --libs`
</pre>
<p>Of course you can also combine both examples to a single command by
specifying both options to <samp><span class="command">pkg-config</span></samp>:

<pre class="smallexample">     gcc -o foo foo.c `pkg-config gnutls --cflags --libs`
</pre>
<div class="node">
<a name="Session-initialization"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Associating-the-credentials">Associating the credentials</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Preparation">Preparation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#How-to-use-GnuTLS-in-applications">How to use GnuTLS in applications</a>

</div>

<h3 class="section">7.3 Session initialization</h3>

<p>In the previous sections we have discussed the global initialization
required for GnuTLS as well as the initialization required for each
authentication method's credentials (see <a href="#Authentication">Authentication</a>). 
In this section we elaborate on the TLS or DTLS session initiation. 
Each session is initialized using <a href="#gnutls_005finit">gnutls_init</a> which among
others is used to specify the type of the connection (server or client),
and the underlying protocol type, i.e., datagram (UDP) or reliable (TCP).

     <ul>
<li><a href="#gnutls_005finit">gnutls_init</a>
</ul>

<p>After the session initialization details on the allowed ciphersuites
and protocol versions should be set using the priority functions
such as <a href="#gnutls_005fpriority_005fset_005fdirect">gnutls_priority_set_direct</a>. We elaborate on them
in <a href="#Priority-Strings">Priority Strings</a>. 
The credentials used for the key exchange method, such as certificates
or usernames and passwords should also be associated with the session
current session using <a href="#gnutls_005fcredentials_005fset">gnutls_credentials_set</a>.

     <ul>
<li><a href="#gnutls_005fcredentials_005fset">gnutls_credentials_set</a>
</ul>

<div class="node">
<a name="Associating-the-credentials"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Setting-up-the-transport-layer">Setting up the transport layer</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Session-initialization">Session initialization</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#How-to-use-GnuTLS-in-applications">How to use GnuTLS in applications</a>

</div>

<h3 class="section">7.4 Associating the credentials</h3>

<ul class="menu">
<li><a accesskey="1" href="#Certificate-credentials">Certificate credentials</a>
<li><a accesskey="2" href="#SRP-credentials">SRP credentials</a>
<li><a accesskey="3" href="#PSK-credentials">PSK credentials</a>
<li><a accesskey="4" href="#Anonymous-credentials">Anonymous credentials</a>
</ul>

<div class="node">
<a name="Certificate-credentials"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#SRP-credentials">SRP credentials</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Associating-the-credentials">Associating the credentials</a>

</div>

<h4 class="subsection">7.4.1 Certificates</h4>

<h5 class="subsubheading">Server certificate authentication</h5>

<p>When using certificates the server is required to have at least one
certificate and private key pair. Clients may not hold such
a pair, but a server could require it. On this section we discuss
general issues applying to both client and server certificates. The next
section will elaborate on issues arising from client authentication only.

     <ul>
<li><a href="#gnutls_005fcertificate_005fallocate_005fcredentials">gnutls_certificate_allocate_credentials</a>
<li><a href="#gnutls_005fcertificate_005ffree_005fcredentials">gnutls_certificate_free_credentials</a>
</ul>

<p>After the credentials structures are initialized, the certificate
and key pair must be loaded. This occurs before any <acronym>TLS</acronym>
session is initialized, and the same structures are reused for multiple sessions. 
Depending on the certificate type different loading functions
are available, as shown below. 
For <acronym>X.509</acronym> certificates, the functions will
accept and use a certificate chain that leads to a trusted
authority. The certificate chain must be ordered in such way that every
certificate certifies the one before it. The trusted authority's
certificate need not to be included since the peer should possess it
already.

     <ul>
<li><a href="#gnutls_005fcertificate_005fset_005fx509_005fkey_005fmem">gnutls_certificate_set_x509_key_mem</a>
<li><a href="#gnutls_005fcertificate_005fset_005fx509_005fkey">gnutls_certificate_set_x509_key</a>
<li><a href="#gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile">gnutls_certificate_set_x509_key_file</a>
</ul>

     <ul>
<li><a href="#gnutls_005fcertificate_005fset_005fopenpgp_005fkey_005fmem">gnutls_certificate_set_openpgp_key_mem</a>
<li><a href="#gnutls_005fcertificate_005fset_005fopenpgp_005fkey">gnutls_certificate_set_openpgp_key</a>
<li><a href="#gnutls_005fcertificate_005fset_005fopenpgp_005fkey_005ffile">gnutls_certificate_set_openpgp_key_file</a>
<li><a href="#gnutls_005fcertificate_005fset_005fkey">gnutls_certificate_set_key</a>
</ul>

<p>As an alternative to loading from files or buffers, a callback may be used for the
server or the client to specify the certificate and the key at the handshake time. 
In that case a certificate should be selected according the peer's signature
algorithm preferences. To get those preferences use
<a href="#gnutls_005fsign_005falgorithm_005fget_005frequested">gnutls_sign_algorithm_get_requested</a>. Both functions are shown below.

     <ul>
<li><a href="#gnutls_005fcertificate_005fset_005fretrieve_005ffunction">gnutls_certificate_set_retrieve_function</a>
<li><a href="#gnutls_005fsign_005falgorithm_005fget_005frequested">gnutls_sign_algorithm_get_requested</a>
</ul>

<p>Certificate verification is possible by loading the trusted
authorities into the credentials structure by using
the following functions, applicable to X.509 and OpenPGP certificates.

     <ul>
<li><a href="#gnutls_005fcertificate_005fset_005fx509_005ftrust_005ffile">gnutls_certificate_set_x509_trust_file</a>
<li><a href="#gnutls_005fcertificate_005fset_005fopenpgp_005fkeyring_005ffile">gnutls_certificate_set_openpgp_keyring_file</a>
</ul>

<p>Note however that the peer's certificate is not automatically
verified, you should call <a href="#gnutls_005fcertificate_005fverify_005fpeers2">gnutls_certificate_verify_peers2</a>,
after a successful handshake or during if <a href="#gnutls_005fcertificate_005fset_005fverify_005ffunction">gnutls_certificate_set_verify_function</a>
has been used, to verify the certificate's signature. 
An alternative way, which reports a more detailed
verification output, is to use <a href="#gnutls_005fcertificate_005fget_005fpeers">gnutls_certificate_get_peers</a> to
obtain the raw certificate of the peer and verify it using the
functions discussed in <a href="#X_002e509-certificates">X.509 certificates</a>.

     <ul>
<li><a href="#gnutls_005fcertificate_005fverify_005fpeers2">gnutls_certificate_verify_peers2</a>
</ul>

<p>In a handshake, the negotiated cipher suite also depends on the
certificate's parameters, so some key exchange methods might not be
available with some certificates. <acronym>GnuTLS</acronym> will disable
ciphersuites that are not compatible with the key, or the enabled
authentication methods.  For example keys marked as sign-only, will
not be able to access the plain RSA ciphersuites, that require
decryption. It is not recommended to use RSA keys for both
signing and encryption. If possible use a different key for the
<code>DHE_RSA</code> which uses signing and <code>RSA</code> that requires decryption. 
All the key exchange methods shown in <a href="#tab_003akey_002dexchange">Table 3.4</a> are
available in certificate authentication.

     <ul>
<li><a href="#gnutls_005fcertificate_005fset_005fverify_005ffunction">gnutls_certificate_set_verify_function</a>
</ul>

<p>Note that the DHE key exchange methods are generally
slower<a rel="footnote" href="#fn-13" name="fnd-13"><sup>13</sup></a> than the elliptic curves counterpart
(ECDHE). Moreover the plain Diffie-Hellman key exchange
requires parameters to be generated and associated with a credentials
structure by the server (see <a href="#Parameter-generation">Parameter generation</a>).

<h5 class="subsubheading">Client certificate authentication</h5>

<p>If a certificate is to be requested from the client during the handshake, the server
will send a certificate request message. This behavior is controlled <a href="#gnutls_005fcertificate_005fserver_005fset_005frequest">gnutls_certificate_server_set_request</a>. 
The request contains a list of the acceptable by the server certificate signers. This list
is constructed using the trusted certificate authorities of the server. 
In cases where the server supports a large number of certificate authorities
it makes sense not to advertise all of the names to save bandwidth. That can
be controlled using the function <a href="#gnutls_005fcertificate_005fsend_005fx509_005frdn_005fsequence">gnutls_certificate_send_x509_rdn_sequence</a>. 
This however will have the side-effect of not restricting the client to certificates
signed by server's acceptable signers.

     <ul>
<li><a href="#gnutls_005fcertificate_005fserver_005fset_005frequest">gnutls_certificate_server_set_request</a>
</ul>

     <ul>
<li><a href="#gnutls_005fcertificate_005fsend_005fx509_005frdn_005fsequence">gnutls_certificate_send_x509_rdn_sequence</a>
</ul>

<div class="node">
<a name="SRP-credentials"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#PSK-credentials">PSK credentials</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Certificate-credentials">Certificate credentials</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Associating-the-credentials">Associating the credentials</a>

</div>

<h4 class="subsection">7.4.2 SRP</h4>

<p>The initialization functions in SRP credentials differ between
client and server. 
Clients supporting <acronym>SRP</acronym> should set the username and password
prior to connection, to the credentials structure. 
Alternatively <a href="#gnutls_005fsrp_005fset_005fclient_005fcredentials_005ffunction">gnutls_srp_set_client_credentials_function</a>
may be used instead, to specify a callback function that should return the
SRP username and password. 
The callback is called once during the <acronym>TLS</acronym> handshake.

     <ul>
<li><a href="#gnutls_005fsrp_005fallocate_005fserver_005fcredentials">gnutls_srp_allocate_server_credentials</a>
<li><a href="#gnutls_005fsrp_005fallocate_005fclient_005fcredentials">gnutls_srp_allocate_client_credentials</a>
<li><a href="#gnutls_005fsrp_005ffree_005fserver_005fcredentials">gnutls_srp_free_server_credentials</a>
<li><a href="#gnutls_005fsrp_005ffree_005fclient_005fcredentials">gnutls_srp_free_client_credentials</a>
<li><a href="#gnutls_005fsrp_005fset_005fclient_005fcredentials">gnutls_srp_set_client_credentials</a>
</ul>

     <ul>
<li><a href="#gnutls_005fsrp_005fset_005fclient_005fcredentials_005ffunction">gnutls_srp_set_client_credentials_function</a>
</ul>

<p>In server side the default behavior of <acronym>GnuTLS</acronym> is to read
the usernames and <acronym>SRP</acronym> verifiers from password files. These
password file format is compatible the with the <em>Stanford srp libraries</em>
format.  If a different password file format is to be used, then
<a href="#gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffunction">gnutls_srp_set_server_credentials_function</a> should be called,
to set an appropriate callback.

     <ul>
<li><a href="#gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffile">gnutls_srp_set_server_credentials_file</a>
</ul>

     <ul>
<li><a href="#gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffunction">gnutls_srp_set_server_credentials_function</a>
</ul>

<div class="node">
<a name="PSK-credentials"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Anonymous-credentials">Anonymous credentials</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#SRP-credentials">SRP credentials</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Associating-the-credentials">Associating the credentials</a>

</div>

<h4 class="subsection">7.4.3 PSK</h4>

<p>The initialization functions in PSK credentials differ between
client and server.

     <ul>
<li><a href="#gnutls_005fpsk_005fallocate_005fserver_005fcredentials">gnutls_psk_allocate_server_credentials</a>
<li><a href="#gnutls_005fpsk_005fallocate_005fclient_005fcredentials">gnutls_psk_allocate_client_credentials</a>
<li><a href="#gnutls_005fpsk_005ffree_005fserver_005fcredentials">gnutls_psk_free_server_credentials</a>
<li><a href="#gnutls_005fpsk_005ffree_005fclient_005fcredentials">gnutls_psk_free_client_credentials</a>
</ul>

<p>Clients supporting <acronym>PSK</acronym> should supply the username and key
before a TLS session is established.  Alternatively
<a href="#gnutls_005fpsk_005fset_005fclient_005fcredentials_005ffunction">gnutls_psk_set_client_credentials_function</a> can be used to
specify a callback function. This has the
advantage that the callback will be called only if <acronym>PSK</acronym> has
been negotiated.

     <ul>
<li><a href="#gnutls_005fpsk_005fset_005fclient_005fcredentials">gnutls_psk_set_client_credentials</a>
</ul>

     <ul>
<li><a href="#gnutls_005fpsk_005fset_005fclient_005fcredentials_005ffunction">gnutls_psk_set_client_credentials_function</a>
</ul>

<p>In server side the default behavior of <acronym>GnuTLS</acronym> is to read
the usernames and <acronym>PSK</acronym> keys from a password file. The
password file should contain usernames and keys in hexadecimal
format. The name of the password file can be stored to the credentials
structure by calling <a href="#gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffile">gnutls_psk_set_server_credentials_file</a>.  If
a different password file format is to be used, then
a callback should be set instead by <a href="#gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffunction">gnutls_psk_set_server_credentials_function</a>.

<p>The server can help the client chose a suitable username and password,
by sending a hint. Note that there is no common profile for the PSK hint and applications
are discouraged to use it. 
A server, may specify the hint by calling
<a href="#gnutls_005fpsk_005fset_005fserver_005fcredentials_005fhint">gnutls_psk_set_server_credentials_hint</a>.  The client can retrieve
the hint, for example in the callback function, using
<a href="#gnutls_005fpsk_005fclient_005fget_005fhint">gnutls_psk_client_get_hint</a>.

     <ul>
<li><a href="#gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffile">gnutls_psk_set_server_credentials_file</a>
</ul>

     <ul>
<li><a href="#gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffunction">gnutls_psk_set_server_credentials_function</a>
<li><a href="#gnutls_005fpsk_005fset_005fserver_005fcredentials_005fhint">gnutls_psk_set_server_credentials_hint</a>
<li><a href="#gnutls_005fpsk_005fclient_005fget_005fhint">gnutls_psk_client_get_hint</a>
</ul>

<div class="node">
<a name="Anonymous-credentials"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#PSK-credentials">PSK credentials</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Associating-the-credentials">Associating the credentials</a>

</div>

<h4 class="subsection">7.4.4 Anonymous</h4>

<p>The initialization functions for the credentials are shown below.

     <ul>
<li><a href="#gnutls_005fanon_005fallocate_005fserver_005fcredentials">gnutls_anon_allocate_server_credentials</a>
<li><a href="#gnutls_005fanon_005fallocate_005fclient_005fcredentials">gnutls_anon_allocate_client_credentials</a>
<li><a href="#gnutls_005fanon_005ffree_005fserver_005fcredentials">gnutls_anon_free_server_credentials</a>
<li><a href="#gnutls_005fanon_005ffree_005fclient_005fcredentials">gnutls_anon_free_client_credentials</a>
</ul>

<p>Note that the key exchange methods for anonymous authentication
require Diffie-Hellman parameters to be generated by the server and
associated with an anonymous credentials structure. Check
<a href="#Parameter-generation">Parameter generation</a> for more information.

<div class="node">
<a name="Setting-up-the-transport-layer"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#TLS-handshake">TLS handshake</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Associating-the-credentials">Associating the credentials</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#How-to-use-GnuTLS-in-applications">How to use GnuTLS in applications</a>

</div>

<h3 class="section">7.5 Setting up the transport layer</h3>

<p>The next step is to setup the underlying transport layer details. The
Berkeley sockets are implicitly used by GnuTLS, thus a
call to <a href="#gnutls_005ftransport_005fset_005fptr2">gnutls_transport_set_ptr2</a> would be sufficient to
specify the socket descriptor.

     <ul>
<li><a href="#gnutls_005ftransport_005fset_005fptr2">gnutls_transport_set_ptr2</a>
</ul>

     <ul>
<li><a href="#gnutls_005ftransport_005fset_005fptr">gnutls_transport_set_ptr</a>
</ul>

<p>If however another transport layer than TCP is selected, then
the following functions have to be specified.

     <ul>
<li><a href="#gnutls_005ftransport_005fset_005fpush_005ffunction">gnutls_transport_set_push_function</a>
</ul>

     <ul>
<li><a href="#gnutls_005ftransport_005fset_005fvec_005fpush_005ffunction">gnutls_transport_set_vec_push_function</a>
</ul>

     <ul>
<li><a href="#gnutls_005ftransport_005fset_005fpull_005ffunction">gnutls_transport_set_pull_function</a>
</ul>

<p>The functions above accept a callback function which
should return the number of bytes written, or -1 on
error and should set <code>errno</code> appropriately. 
In some environments, setting <code>errno</code> is unreliable. For example
Windows have several errno variables in different CRTs, or in other
systems it may be a non thread-local variable.  If this is a concern to
you, call <a href="#gnutls_005ftransport_005fset_005ferrno">gnutls_transport_set_errno</a> with the intended errno
value instead of setting <code>errno</code> directly.

     <ul>
<li><a href="#gnutls_005ftransport_005fset_005ferrno">gnutls_transport_set_errno</a>
</ul>

<p><acronym>GnuTLS</acronym> currently only interprets the EINTR and EAGAIN errno
values and returns the corresponding <acronym>GnuTLS</acronym> error codes:
     <ul>
<li><code>GNUTLS_E_INTERRUPTED</code>
<li><code>GNUTLS_E_AGAIN</code>
</ul>
The EINTR and EAGAIN values are returned by interrupted system calls,
or when non blocking IO is used.  All <acronym>GnuTLS</acronym> functions can be
resumed (called again), if any of the above error codes is returned.

<p>In the case of DTLS it is also desirable to override the generic
transport functions with functions that emulate the operation
of <code>recvfrom</code> and <code>sendto</code>. In addition
<acronym>DTLS</acronym> requires timers during the receive of a handshake
message. This requires the <a href="#gnutls_005ftransport_005fset_005fpull_005ftimeout_005ffunction">gnutls_transport_set_pull_timeout_function</a> function to be used.

     <ul>
<li><a href="#gnutls_005ftransport_005fset_005fpull_005ftimeout_005ffunction">gnutls_transport_set_pull_timeout_function</a>
</ul>

<ul class="menu">
<li><a accesskey="1" href="#Asynchronous-operation">Asynchronous operation</a>
<li><a accesskey="2" href="#DTLS-sessions">DTLS sessions</a>
</ul>

<div class="node">
<a name="Asynchronous-operation"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#DTLS-sessions">DTLS sessions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Setting-up-the-transport-layer">Setting up the transport layer</a>

</div>

<h4 class="subsection">7.5.1 Asynchronous operation</h4>

<p><acronym>GnuTLS</acronym> can be used with asynchronous socket or event-driven programming. 
During a TLS protocol session <acronym>GnuTLS</acronym> does not block for anything except
calculations. The only blocking operations are due to the transport layer (sockets) functions. 
Those, however, in an asynchronous scenario are typically set to
non-blocking mode, which forces them to return <code>EAGAIN</code> error code instead of blocking. 
In that case <acronym>GnuTLS</acronym> functions
will return the <code>GNUTLS_E_AGAIN</code> error code and can be resumed the
same way as a system call would. The only exception is <a href="#gnutls_005frecord_005fsend">gnutls_record_send</a>,
which if interrupted subsequent calls need not to include the data to be
sent (can be called with NULL argument).

<p>The <code>select</code> system call can also be used in combination with the
<acronym>GnuTLS</acronym> functions. <code>select</code> allows monitoring of sockets
and notifies on them being ready for reading or writing data. Note however
that this system call cannot notify on data present in <acronym>GnuTLS</acronym>
read buffers, it is only applicable to the kernel sockets API. Thus if
you are using it for reading from a <acronym>GnuTLS</acronym> session, make sure
the session is read completely. That can be achieved by checking there
are no data waiting to be read (using <a href="#gnutls_005frecord_005fcheck_005fpending">gnutls_record_check_pending</a>),
either before the <code>select</code> system call, or after a call to
<a href="#gnutls_005frecord_005frecv">gnutls_record_recv</a>. <acronym>GnuTLS</acronym> does not keep a write buffer,
thus when writing <code>select</code> need only to be consulted.

<p>In the DTLS, however, <acronym>GnuTLS</acronym> might block due to timers
required by the protocol. To prevent those timers from blocking a DTLS handshake,
the <a href="#gnutls_005finit">gnutls_init</a> should be called with the
<code>GNUTLS_NONBLOCK</code> flag (see <a href="#Session-initialization">Session initialization</a>).

<div class="node">
<a name="DTLS-sessions"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Asynchronous-operation">Asynchronous operation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Setting-up-the-transport-layer">Setting up the transport layer</a>

</div>

<h4 class="subsection">7.5.2 DTLS sessions</h4>

<p>Because datagram TLS can operate over connections where the peer
of a server cannot be reliably verified, functionality is available to prevent
denial of service attacks. <acronym>GnuTLS</acronym> requires a server
to generate a secret key that is used to sign a cookie<a rel="footnote" href="#fn-14" name="fnd-14"><sup>14</sup></a>. 
That cookie is sent to the client using <a href="#gnutls_005fdtls_005fcookie_005fsend">gnutls_dtls_cookie_send</a>, and
the client must reply using the correct cookie. The server side
should verify the initial message sent by client using <a href="#gnutls_005fdtls_005fcookie_005fverify">gnutls_dtls_cookie_verify</a>. 
If successful the session should be initialized and associated with
the cookie using <a href="#gnutls_005fdtls_005fprestate_005fset">gnutls_dtls_prestate_set</a>, before proceeding to
the handshake.

     <ul>
<li><a href="#gnutls_005fkey_005fgenerate">gnutls_key_generate</a>
<li><a href="#gnutls_005fdtls_005fcookie_005fsend">gnutls_dtls_cookie_send</a>
<li><a href="#gnutls_005fdtls_005fcookie_005fverify">gnutls_dtls_cookie_verify</a>
<li><a href="#gnutls_005fdtls_005fprestate_005fset">gnutls_dtls_prestate_set</a>
</ul>

<p>Note that the above apply to server side only and they are not mandatory to be
used. Not using them, however, allows denial of service attacks. 
The client side cookie handling is part of <a href="#gnutls_005fhandshake">gnutls_handshake</a>.

<p>Datagrams are typically restricted by a maximum transfer unit (MTU). For that
both client and server side should set the correct maximum transfer unit for
the layer underneath <acronym>GnuTLS</acronym>. This will allow proper fragmentation
of DTLS messages and prevent messages from being silently discarded by the
transport layer. The &ldquo;correct&rdquo; maximum transfer unit can be obtained through
a path MTU discovery mechanism [<em>RFC4821</em>].

     <ul>
<li><a href="#gnutls_005fdtls_005fset_005fmtu">gnutls_dtls_set_mtu</a>
<li><a href="#gnutls_005fdtls_005fget_005fmtu">gnutls_dtls_get_mtu</a>
<li><a href="#gnutls_005fdtls_005fget_005fdata_005fmtu">gnutls_dtls_get_data_mtu</a>
</ul>

<div class="node">
<a name="TLS-handshake"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Data-transfer-and-termination">Data transfer and termination</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Setting-up-the-transport-layer">Setting up the transport layer</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#How-to-use-GnuTLS-in-applications">How to use GnuTLS in applications</a>

</div>

<h3 class="section">7.6 TLS handshake</h3>

<p>Once a session has been initialized and a network
connection has been set up, TLS and DTLS protocols
perform a handshake. The handshake is the actual key
exchange.

     <ul>
<li><a href="#gnutls_005fhandshake">gnutls_handshake</a>
</ul>

<p>The handshake process doesn't ensure the verification
of the peer's identity. When certificates are in use,
this can be done, either after the handshake is complete, or during
the handshake if <a href="#gnutls_005fcertificate_005fset_005fverify_005ffunction">gnutls_certificate_set_verify_function</a>
has been used. In both cases the <a href="#gnutls_005fcertificate_005fverify_005fpeers2">gnutls_certificate_verify_peers2</a> function can be
used to verify the peer's certificate (see <a href="#Certificate-authentication">Certificate authentication</a>
for more information).

     <ul>
<li><a href="#gnutls_005fcertificate_005fverify_005fpeers2">gnutls_certificate_verify_peers2</a>
</ul>

<div class="node">
<a name="Data-transfer-and-termination"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Priority-Strings">Priority Strings</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#TLS-handshake">TLS handshake</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#How-to-use-GnuTLS-in-applications">How to use GnuTLS in applications</a>

</div>

<h3 class="section">7.7 Data transfer and termination</h3>

<p>Once the handshake is complete and peer's identity
has been verified data can be exchanged. The available
functions resemble the POSIX <code>recv</code> and <code>send</code>
functions. It is suggested to use <a href="#gnutls_005ferror_005fis_005ffatal">gnutls_error_is_fatal</a>
to check whether the error codes returned by these functions are
fatal for the protocol or can be ignored.

     <ul>
<li><a href="#gnutls_005frecord_005fsend">gnutls_record_send</a>
</ul>

     <ul>
<li><a href="#gnutls_005frecord_005frecv">gnutls_record_recv</a>
</ul>

     <ul>
<li><a href="#gnutls_005ferror_005fis_005ffatal">gnutls_error_is_fatal</a>
</ul>

<p>In DTLS it is adviceable to use the extended receive
function shown below, because it allows the extraction
of the sequence number. This is required in DTLS because
messages may arrive out of order.

     <ul>
<li><a href="#gnutls_005frecord_005frecv_005fseq">gnutls_record_recv_seq</a>
</ul>

<p>The <a href="#gnutls_005frecord_005fcheck_005fpending">gnutls_record_check_pending</a> helper function is available to
allow checking whether data are available to be read in a <acronym>GnuTLS</acronym> session
buffers. Note that this function complements but does not replace <code>select</code>,
i.e., <a href="#gnutls_005frecord_005fcheck_005fpending">gnutls_record_check_pending</a> reports no data to be read, <code>select</code>
should be called to check for data in the network buffers.

     <ul>
<li><a href="#gnutls_005frecord_005fcheck_005fpending">gnutls_record_check_pending</a>
</ul>

     <ul>
<li><a href="#gnutls_005frecord_005fget_005fdirection">gnutls_record_get_direction</a>
</ul>

<p>Once a TLS or DTLS session is no longer needed, it is
recommended to use <a href="#gnutls_005fbye">gnutls_bye</a> to terminate the
session. That way the peer is notified securely about the
intention of termination, which allows distinguishing it
from a malicious connection termination. 
A session can be deinitialized with the <a href="#gnutls_005fdeinit">gnutls_deinit</a> function.

     <ul>
<li><a href="#gnutls_005fbye">gnutls_bye</a>
</ul>

     <ul>
<li><a href="#gnutls_005fdeinit">gnutls_deinit</a>
</ul>

<div class="node">
<a name="Priority-Strings"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Advanced-and-other-topics">Advanced and other topics</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Data-transfer-and-termination">Data transfer and termination</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#How-to-use-GnuTLS-in-applications">How to use GnuTLS in applications</a>

</div>

<h3 class="section">7.8 Priority strings</h3>

<p>In order to specify cipher suite preferences on a TLS session
there are priority functions that accept a string
specifying the enabled for the handshake algorithms. 
That string may contain a high level keyword such as
in <a href="#tab_003aprio_002dkeywords">tab:prio-keywords</a> or combination of a high level
keyword, additional algorithm keywords and special keywords.

     <ul>
<li><a href="#gnutls_005fpriority_005fset_005fdirect">gnutls_priority_set_direct</a>
<li><a href="#gnutls_005fpriority_005fset">gnutls_priority_set</a>
</ul>

<div class="float">
<a name="tab_003aprio_002dkeywords"></a>
<p><table summary=""><tr align="left"><th valign="top" width="20%">Keyword </th><th valign="top" width="70%">Description
<br></th></tr><tr align="left"><td valign="top" width="20%">PERFORMANCE </td><td valign="top" width="70%">
All the "secure" ciphersuites are enabled,
limited to 128 bit ciphers and sorted by terms of speed
performance.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">NORMAL </td><td valign="top" width="70%">
Means all "secure" ciphersuites. The 256-bit ciphers are
included as a fallback only.  The ciphers are sorted by security
margin.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">SECURE128 </td><td valign="top" width="70%">
Means all "secure" ciphersuites of security level 128-bit
or more.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">SECURE192 </td><td valign="top" width="70%">
Means all "secure" ciphersuites of security level 192-bit
or more.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">SECURE256 </td><td valign="top" width="70%">
Currently alias for SECURE192.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">SUITEB128 </td><td valign="top" width="70%">
Means all the NSA Suite B cryptography (RFC5430) ciphersuites
with an 128 bit security level.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">SUITEB192 </td><td valign="top" width="70%">
Means all the NSA Suite B cryptography (RFC5430) ciphersuites
with an 192 bit security level.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">EXPORT </td><td valign="top" width="70%">
Means all ciphersuites are enabled, including the
low-security 40 bit ciphers.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">NONE </td><td valign="top" width="70%">
Means nothing is enabled.  This disables even protocols and
compression methods. It should be followed by the
algorithms to be enabled.

<br></td></tr></table>

<p><strong class="float-caption">Table 7.1: Supported priority string keywords.</strong></p></div>

<p>Unless the first keyword is "NONE" the defaults (in preference
order) are for TLS protocols TLS 1.2, TLS1.1, TLS1.0, SSL3.0; for
compression NULL; for certificate types X.509. 
In key exchange algorithms when in NORMAL or SECURE levels the
perfect forward secrecy algorithms take precedence of the other
protocols.  In all cases all the supported key exchange algorithms
 are enabled (except for the RSA-EXPORT which is only enabled in
EXPORT level). 
The NONE keyword, if used, must followed by the algorithms to be enabled,
and is used to provide the exact list of requested algorithms<a rel="footnote" href="#fn-15" name="fnd-15"><sup>15</sup></a>. The order with which every algorithm
is specified is significant. Similar algorithms specified before others
will take precedence. The individual algorithms are shown in <a href="#tab_003aprio_002dalgorithms">tab:prio-algorithms</a>
and special keywords are in <a href="#tab_003aprio_002dspecial">tab:prio-special</a>. 
The prefixes for individual algorithms are:
     <dl>
<dt>'!' or '-'<dd>appended with an algorithm will remove this algorithm. 
<br><dt>"+"<dd>appended with an algorithm will add this algorithm. 
</dl>

<div class="float">
<a name="tab_003aprio_002dalgorithms"></a>
<p><table summary=""><tr align="left"><th valign="top" width="20%">Type </th><th valign="top" width="70%">Keywords
<br></th></tr><tr align="left"><td valign="top" width="20%">Ciphers </td><td valign="top" width="70%">
AES-128-CBC, AES-256-CBC, AES-128-GCM, CAMELLIA-128-CBC,
CAMELLIA-256-CBC, ARCFOUR-128, 3DES-CBC ARCFOUR-40. Catch all
name is CIPHER-ALL which will add all the algorithms from NORMAL
priority.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">Key exchange </td><td valign="top" width="70%">
RSA, DHE-RSA, DHE-DSS, SRP, SRP-RSA, SRP-DSS,
PSK, DHE-PSK, ECDHE-RSA, ANON-ECDH, ANON-DH, RSA-EXPORT. The
Catch all name is KX-ALL which will add all the algorithms from NORMAL
priority.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">MAC </td><td valign="top" width="70%">
MD5, SHA1, SHA256, AEAD (used with
GCM ciphers only). All algorithms from NORMAL priority can be accessed with MAC-ALL.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">Compression algorithms </td><td valign="top" width="70%">
COMP-NULL, COMP-DEFLATE. Catch all is COMP-ALL.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">TLS versions </td><td valign="top" width="70%">
VERS-SSL3.0, VERS-TLS1.0, VERS-TLS1.1,
VERS-TLS1.2. Catch all is VERS-TLS-ALL.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">Signature algorithms </td><td valign="top" width="70%">
SIGN-RSA-SHA1, SIGN-RSA-SHA224,
SIGN-RSA-SHA256, SIGN-RSA-SHA384, SIGN-RSA-SHA512, SIGN-DSA-SHA1,
SIGN-DSA-SHA224, SIGN-DSA-SHA256, SIGN-RSA-MD5. Catch all
is SIGN-ALL. This is only valid for TLS 1.2 and later.

<p><br></td></tr><tr align="left"><td valign="top" width="20%">Elliptic curves </td><td valign="top" width="70%">
CURVE-SECP224R1, CURVE-SECP256R1, CURVE-SECP384R1, CURVE-SECP521R1. Catch all is CURVE-ALL.

<br></td></tr></table>

<p><strong class="float-caption">Table 7.2: The supported algorithm keywords in priority strings.</strong></p></div>

<div class="float">
<a name="tab_003aprio_002dspecial"></a>
<p><table summary=""><tr align="left"><th valign="top" width="45%">Keyword </th><th valign="top" width="45%">Description

<p><br></th></tr><tr align="left"><td valign="top" width="45%">%COMPAT </td><td valign="top" width="45%">
will enable compatibility mode. It might mean that violations
of the protocols are allowed as long as maximum compatibility with
problematic clients and servers is achieved.

<p><br></td></tr><tr align="left"><td valign="top" width="45%">%NO_EXTENSIONS </td><td valign="top" width="45%">
will prevent the sending of any TLS extensions in client side. Note
that TLS 1.2 requires extensions to be used, as well as safe
renegotiation thus this option must be used with care.

<p><br></td></tr><tr align="left"><td valign="top" width="45%">%SERVER_PRECEDENCE </td><td valign="top" width="45%">
The ciphersuite will be selected according to server priorities
and not the client's.

<p><br></td></tr><tr align="left"><td valign="top" width="45%">%DISABLE_SAFE_RENEGOTIATION </td><td valign="top" width="45%">
will disable safe renegotiation
completely.  Do not use unless you know what you are doing. 
Testing purposes only.

<p><br></td></tr><tr align="left"><td valign="top" width="45%">%UNSAFE_RENEGOTIATION </td><td valign="top" width="45%">
will allow handshakes and re-handshakes
without the safe renegotiation extension.  Note that for clients
this mode is insecure (you may be under attack), and for servers it
will allow insecure clients to connect (which could be fooled by an
attacker).  Do not use unless you know what you are doing and want
maximum compatibility.

<p><br></td></tr><tr align="left"><td valign="top" width="45%">%PARTIAL_RENEGOTIATION </td><td valign="top" width="45%">
will allow initial handshakes to proceed,
but not re-handshakes.  This leaves the client vulnerable to attack,
and servers will be compatible with non-upgraded clients for
initial handshakes.  This is currently the default for clients and
servers, for compatibility reasons.

<p><br></td></tr><tr align="left"><td valign="top" width="45%">%SAFE_RENEGOTIATION </td><td valign="top" width="45%">
will enforce safe renegotiation.  Clients and
servers will refuse to talk to an insecure peer.  Currently this
causes interoperability problems, but is required for full protection.

<p><br></td></tr><tr align="left"><td valign="top" width="45%">%SSL3_RECORD_VERSION </td><td valign="top" width="45%">
will use SSL3.0 record version in client hello. 
This is the default.

<p><br></td></tr><tr align="left"><td valign="top" width="45%">%LATEST_RECORD_VERSION </td><td valign="top" width="45%">
will use the latest TLS version record version in client hello.

<p><br></td></tr><tr align="left"><td valign="top" width="45%">%VERIFY_ALLOW_SIGN_RSA_MD5 </td><td valign="top" width="45%">
will allow RSA-MD5 signatures in certificate chains.

<p><br></td></tr><tr align="left"><td valign="top" width="45%">%VERIFY_ALLOW_X509_V1_CA_CRT </td><td valign="top" width="45%">
will allow V1 CAs in chains.

<br></td></tr></table>

<p><strong class="float-caption">Table 7.3: Special priority string keywords.</strong></p></div>

<div class="node">
<a name="Advanced-and-other-topics"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-the-cryptographic-library">Using the cryptographic library</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Priority-Strings">Priority Strings</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#How-to-use-GnuTLS-in-applications">How to use GnuTLS in applications</a>

</div>

<h3 class="section">7.9 Advanced and other topics</h3>

<ul class="menu">
<li><a accesskey="1" href="#Session-resumption">Session resumption</a>
<li><a accesskey="2" href="#Parameter-generation">Parameter generation</a>
<li><a accesskey="3" href="#Keying-Material-Exporters">Keying Material Exporters</a>
<li><a accesskey="4" href="#Channel-Bindings">Channel Bindings</a>
<li><a accesskey="5" href="#Interoperability">Interoperability</a>
<li><a accesskey="6" href="#Compatibility-with-the-OpenSSL-library">Compatibility with the OpenSSL library</a>
</ul>

<div class="node">
<a name="Session-resumption"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Parameter-generation">Parameter generation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Advanced-and-other-topics">Advanced and other topics</a>

</div>

<h4 class="subsection">7.9.1 Session resumption</h4>

<p><a name="index-resuming-sessions-57"></a><a name="index-session-resumption-58"></a>

<h5 class="subsubheading">Client side</h5>

<p>To reduce time and roundtrips spent in a handshake the client can
utilize session resumption. This requires the client to retrieve and store
the session parameters. On new sessions to the same server the parameters must
be re-associated with sessions using <a href="#gnutls_005fsession_005fset_005fdata">gnutls_session_set_data</a>.

     <ul>
<li><a href="#gnutls_005fsession_005fget_005fdata">gnutls_session_get_data</a>
<li><a href="#gnutls_005fsession_005fget_005fid">gnutls_session_get_id</a>
<li><a href="#gnutls_005fsession_005fset_005fdata">gnutls_session_set_data</a>
</ul>

<p>Keep in mind that sessions might be expired after some time,
and it may be normal for a server not to resume a session
even it was requested.  That is to prevent temporal session keys
from becoming long-term keys. Also note that as a client you must enable, using the
priority functions, at least the algorithms used in the last session.

<p>It is highly recommended clients to enable the session ticket extension using
<a href="#gnutls_005fsession_005fticket_005fenable_005fclient">gnutls_session_ticket_enable_client</a> in order to allow resumption with
servers that do not store any state.

     <ul>
<li><a href="#gnutls_005fsession_005fticket_005fenable_005fclient">gnutls_session_ticket_enable_client</a>
</ul>

<h5 class="subsubheading">Server side</h5>

<p>In order to support resumption a server might do it either by storing
the session security parameters in a local database or by using session
tickets (see <a href="#Session-tickets">Session tickets</a>) to delegate storage to the client. Because
session tickets might not be supported by all clients, servers
might combine the two methods.

<p>A storing server needs to specify callback functions to store, retrieve and delete session data. These can be
registered with the functions below. The stored sessions in the database can be checked using <a href="#gnutls_005fdb_005fcheck_005fentry">gnutls_db_check_entry</a>
for expiration.

     <ul>
<li><a href="#gnutls_005fdb_005fset_005fretrieve_005ffunction">gnutls_db_set_retrieve_function</a>
<li><a href="#gnutls_005fdb_005fset_005fstore_005ffunction">gnutls_db_set_store_function</a>
<li><a href="#gnutls_005fdb_005fset_005fptr">gnutls_db_set_ptr</a>
<li><a href="#gnutls_005fdb_005fset_005fremove_005ffunction">gnutls_db_set_remove_function</a>
</ul>

     <ul>
<li><a href="#gnutls_005fdb_005fcheck_005fentry">gnutls_db_check_entry</a>
</ul>

<p>A server utilizing tickets should use
<a href="#gnutls_005fsession_005fticket_005fkey_005fgenerate">gnutls_session_ticket_key_generate</a> to generate a ticket encryption key and
call <a href="#gnutls_005fsession_005fticket_005fenable_005fserver">gnutls_session_ticket_enable_server</a> to enable the extension.

     <ul>
<li><a href="#gnutls_005fsession_005fticket_005fenable_005fserver">gnutls_session_ticket_enable_server</a>
</ul>

     <ul>
<li><a href="#gnutls_005fsession_005fticket_005fkey_005fgenerate">gnutls_session_ticket_key_generate</a>
</ul>

<div class="node">
<a name="Parameter-generation"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Keying-Material-Exporters">Keying Material Exporters</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Session-resumption">Session resumption</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Advanced-and-other-topics">Advanced and other topics</a>

</div>

<h4 class="subsection">7.9.2 Parameter generation</h4>

<p><a name="index-parameter-generation-59"></a><a name="index-generating-parameters-60"></a>
Several TLS ciphersuites require additional parameters that
need to be generated or provided by the application. The
Diffie-Hellman based ciphersuites (ANON-DH or DHE), require
the group parameters to be provided. Those can either be
be generated on the fly using <a href="#gnutls_005fdh_005fparams_005fgenerate2">gnutls_dh_params_generate2</a>
or imported from pregenerated data using <a href="#gnutls_005fdh_005fparams_005fimport_005fpkcs3">gnutls_dh_params_import_pkcs3</a>. 
The parameters can be used in a <acronym>TLS</acronym> session by calling
<a href="#gnutls_005fcertificate_005fset_005fdh_005fparams">gnutls_certificate_set_dh_params</a> or
<a href="#gnutls_005fanon_005fset_005fserver_005fdh_005fparams">gnutls_anon_set_server_dh_params</a> for anonymous sessions.

     <ul>
<li><a href="#gnutls_005fdh_005fparams_005fgenerate2">gnutls_dh_params_generate2</a>
<li><a href="#gnutls_005fdh_005fparams_005fimport_005fpkcs3">gnutls_dh_params_import_pkcs3</a>
<li><a href="#gnutls_005fcertificate_005fset_005fdh_005fparams">gnutls_certificate_set_dh_params</a>
<li><a href="#gnutls_005fanon_005fset_005fserver_005fdh_005fparams">gnutls_anon_set_server_dh_params</a>
</ul>

<p>Due to the time-consuming calculations required for the generation
of Diffie-Hellman parameters we suggest against performing generation
of them within an application. The <code>certtool</code> tool can be used to
generate or export known safe values that can be stored in code
or in a configuration file to provide the ability to replace. We also
recommend the usage of <a href="#gnutls_005fsec_005fparam_005fto_005fpk_005fbits">gnutls_sec_param_to_pk_bits</a> (see <a href="#Selecting-cryptographic-key-sizes">Selecting cryptographic key sizes</a>) to determine
the bit size of the generated parameters.

<p>The ciphersuites that involve the RSA-EXPORT key exchange require
additional parameters. Those ciphersuites are rarely used today
because they are by design insecure, thus if you have no requirement
for them, the rest of this section can be skipped. The RSA-EXPORT key exchange
requires 512-bit RSA keys to be generated. It is recommended those
parameters to be refreshed (regenerated) in short intervals. The
following functions can be used for these parameters.

     <ul>
<li><a href="#gnutls_005frsa_005fparams_005fgenerate2">gnutls_rsa_params_generate2</a>
<li><a href="#gnutls_005fcertificate_005fset_005frsa_005fexport_005fparams">gnutls_certificate_set_rsa_export_params</a>
<li><a href="#gnutls_005frsa_005fparams_005fimport_005fpkcs1">gnutls_rsa_params_import_pkcs1</a>
<li><a href="#gnutls_005frsa_005fparams_005fexport_005fpkcs1">gnutls_rsa_params_export_pkcs1</a>
</ul>

<p>To allow renewal of the parameters within an application without
accessing the credentials, which are a shared structure,
an alternative interface is available using a callback function.

     <ul>
<li><a href="#gnutls_005fcertificate_005fset_005fparams_005ffunction">gnutls_certificate_set_params_function</a>
</ul>

<div class="node">
<a name="Keying-Material-Exporters"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Channel-Bindings">Channel Bindings</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Parameter-generation">Parameter generation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Advanced-and-other-topics">Advanced and other topics</a>

</div>

<h4 class="subsection">7.9.3 Keying material exporters</h4>

<p><a name="index-keying-material-exporters-61"></a><a name="index-exporting-keying-material-62"></a>
The TLS PRF can be used by other protocols to derive data.  The API to
use is <a href="#gnutls_005fprf">gnutls_prf</a>.  The function needs to be provided with the
label in the parameter <code>label</code>, and the extra data to mix in the
<code>extra</code> parameter.  Depending on whether you want to mix in the
client or server random data first, you can set the
<code>server_random_first</code> parameter.

<p>For example, after establishing a TLS session using
<a href="#gnutls_005fhandshake">gnutls_handshake</a>, you can invoke the TLS PRF with this call:

<pre class="smallexample">     #define MYLABEL "EXPORTER-FOO"
     #define MYCONTEXT "some context data"
     char out[32];
     rc = gnutls_prf (session, strlen (MYLABEL), MYLABEL, 0,
                      strlen (MYCONTEXT), MYCONTEXT, 32, out);
</pre>
<p>If you don't want to mix in the client/server random, there is a more
low-level TLS PRF interface called <a href="#gnutls_005fprf_005fraw">gnutls_prf_raw</a>.

<div class="node">
<a name="Channel-Bindings"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Interoperability">Interoperability</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Keying-Material-Exporters">Keying Material Exporters</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Advanced-and-other-topics">Advanced and other topics</a>

</div>

<h4 class="subsection">7.9.4 Channel bindings</h4>

<p><a name="index-channel-bindings-63"></a>
In user authentication protocols (e.g., EAP or SASL mechanisms) it is
useful to have a unique string that identifies the secure channel that
is used, to bind together the user authentication with the secure
channel.  This can protect against man-in-the-middle attacks in some
situations.  That unique string is called a &ldquo;channel binding&rdquo;.  For
background and discussion see [<em>RFC5056</em>].

<p>In <acronym>GnuTLS</acronym> you can extract a channel binding using the
<a href="#gnutls_005fsession_005fchannel_005fbinding">gnutls_session_channel_binding</a> function.  Currently only the
type <code>GNUTLS_CB_TLS_UNIQUE</code> is supported, which corresponds to
the <code>tls-unique</code> channel binding for TLS defined in
[<em>RFC5929</em>].

<p>The following example describes how to print the channel binding data. 
Note that it must be run after a successful TLS handshake.

<pre class="smallexample">     {
       gnutls_datum_t cb;
       int rc;
     
       rc = gnutls_session_channel_binding (session,
                                            GNUTLS_CB_TLS_UNIQUE,
                                            &amp;cb);
       if (rc)
         fprintf (stderr, "Channel binding error: %s\n",
                  gnutls_strerror (rc));
       else
         {
           size_t i;
           printf ("- Channel binding 'tls-unique': ");
           for (i = 0; i &lt; cb.size; i++)
             printf ("%02x", cb.data[i]);
           printf ("\n");
         }
     }
</pre>
<div class="node">
<a name="Interoperability"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Compatibility-with-the-OpenSSL-library">Compatibility with the OpenSSL library</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Channel-Bindings">Channel Bindings</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Advanced-and-other-topics">Advanced and other topics</a>

</div>

<h4 class="subsection">7.9.5 Interoperability</h4>

<p>The <acronym>TLS</acronym> protocols support many ciphersuites, extensions and version
numbers. As a result, few implementations are
not able to properly interoperate once faced with extensions or version protocols
they do not support and understand. The <acronym>TLS</acronym> protocol allows for a
graceful downgrade to the commonly supported options, but practice shows
it is not always implemented correctly.

<p>Because there is no way to achieve maximum interoperability with broken peers
without sacrificing security, <acronym>GnuTLS</acronym> ignores such peers by default. 
This might not be acceptable in cases where maximum compatibility
is required. Thus we allow enabling compatibility with broken peers using
priority strings (see <a href="#Priority-Strings">Priority Strings</a>). An example priority string that
is known to provide wide compatibility even with broken peers
is shown below:
<pre class="verbatim">NORMAL:-VERS-TLS-ALL:+VERS-TLS1.0:+VERS-SSL3.0:%COMPAT
</pre>
This priority string will only enable SSL 3.0 and TLS 1.0 as protocols and
will disable, via the <code>%COMPAT</code> keyword, several <acronym>TLS</acronym> protocol
options that are known to cause compatibility problems. Note however that
there are known attacks against those protocol versions and
this mode trades security for compatibility.

<div class="node">
<a name="Compatibility-with-the-OpenSSL-library"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Interoperability">Interoperability</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Advanced-and-other-topics">Advanced and other topics</a>

</div>

<h4 class="subsection">7.9.6 Compatibility with the OpenSSL library</h4>

<p><a name="index-OpenSSL-64"></a>
To ease <acronym>GnuTLS</acronym>' integration with existing applications, a
compatibility layer with the OpenSSL library is included
in the <code>gnutls-openssl</code> library. This compatibility layer is not
complete and it is not intended to completely re-implement the OpenSSL
API with <acronym>GnuTLS</acronym>.  It only provides limited source-level
compatibility.

<p>The prototypes for the compatibility functions are in the
<samp><span class="file">gnutls/openssl.h</span></samp> header file. The limitations
imposed by the compatibility layer include:

     <ul>
<li>Error handling is not thread safe.

</ul>

<div class="node">
<a name="Using-the-cryptographic-library"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Selecting-cryptographic-key-sizes">Selecting cryptographic key sizes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Advanced-and-other-topics">Advanced and other topics</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#How-to-use-GnuTLS-in-applications">How to use GnuTLS in applications</a>

</div>

<h3 class="section">7.10 Using the cryptographic library</h3>

<p><acronym>GnuTLS</acronym> is not a low-level cryptographic library, i.e.,
it does not provide access to basic cryptographic primitives. However
it abstracts the internal cryptographic back-end (see <a href="#Cryptographic-Backend">Cryptographic Backend</a>),
providing symmetric crypto, hash and HMAC algorithms, as well access
to the random number generation.

<ul class="menu">
<li><a accesskey="1" href="#Symmetric-cryptography">Symmetric cryptography</a>
<li><a accesskey="2" href="#Hash-and-HMAC-functions">Hash and HMAC functions</a>
<li><a accesskey="3" href="#Random-number-generation">Random number generation</a>
</ul>

<div class="node">
<a name="Symmetric-cryptography"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Hash-and-HMAC-functions">Hash and HMAC functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Using-the-cryptographic-library">Using the cryptographic library</a>

</div>

<h4 class="subsection">7.10.1 Symmetric cryptography</h4>

<p><a name="index-symmetric-cryptography-65"></a>
The available functions to access symmetric crypto algorithms operations
are shown below. The supported algorithms are the algorithms required by the TLS protocol. 
They are listed in <a href="#tab_003aciphers">Table 3.1</a>.

     <ul>
<li><a href="#gnutls_005fcipher_005finit">gnutls_cipher_init</a>
<li><a href="#gnutls_005fcipher_005fencrypt2">gnutls_cipher_encrypt2</a>
<li><a href="#gnutls_005fcipher_005fdecrypt2">gnutls_cipher_decrypt2</a>
<li><a href="#gnutls_005fcipher_005fset_005fiv">gnutls_cipher_set_iv</a>
<li><a href="#gnutls_005fcipher_005fdeinit">gnutls_cipher_deinit</a>
</ul>

<p>In order to support authenticated encryption with associated data (AEAD) algorithms the following
functions are provided to set the associated data and retrieve the authentication tag.

     <ul>
<li><a href="#gnutls_005fcipher_005fadd_005fauth">gnutls_cipher_add_auth</a>
<li><a href="#gnutls_005fcipher_005ftag">gnutls_cipher_tag</a>
</ul>

<div class="node">
<a name="Hash-and-HMAC-functions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Random-number-generation">Random number generation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Symmetric-cryptography">Symmetric cryptography</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Using-the-cryptographic-library">Using the cryptographic library</a>

</div>

<h4 class="subsection">7.10.2 Hash and HMAC functions</h4>

<p><a name="index-hash-functions-66"></a><a name="index-HMAC-functions-67"></a>
The available operations to access hash functions and hash-MAC (HMAC) algorithms
are shown below. HMAC algorithms provided keyed hash functionality. They supported HMAC algorithms are listed in <a href="#tab_003amacs">Table 3.2</a>.

     <ul>
<li><a href="#gnutls_005fhmac_005finit">gnutls_hmac_init</a>
<li><a href="#gnutls_005fhmac">gnutls_hmac</a>
<li><a href="#gnutls_005fhmac_005foutput">gnutls_hmac_output</a>
<li><a href="#gnutls_005fhmac_005fdeinit">gnutls_hmac_deinit</a>
<li><a href="#gnutls_005fhmac_005fget_005flen">gnutls_hmac_get_len</a>
<li><a href="#gnutls_005fhmac_005ffast">gnutls_hmac_fast</a>
</ul>

<p>The available functions to access hash functions are shown below. The supported hash functions
are the same as the HMAC algorithms.

     <ul>
<li><a href="#gnutls_005fhash_005finit">gnutls_hash_init</a>
<li><a href="#gnutls_005fhash">gnutls_hash</a>
<li><a href="#gnutls_005fhash_005foutput">gnutls_hash_output</a>
<li><a href="#gnutls_005fhash_005fdeinit">gnutls_hash_deinit</a>
<li><a href="#gnutls_005fhash_005fget_005flen">gnutls_hash_get_len</a>
<li><a href="#gnutls_005fhash_005ffast">gnutls_hash_fast</a>
</ul>

<div class="node">
<a name="Random-number-generation"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Hash-and-HMAC-functions">Hash and HMAC functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Using-the-cryptographic-library">Using the cryptographic library</a>

</div>

<h4 class="subsection">7.10.3 Random number generation</h4>

<p><a name="index-random-numbers-68"></a>
Access to the random number generator is provided using the <a href="#gnutls_005frnd">gnutls_rnd</a>
function. It allows obtaining random data of various levels.

<div class="float">
<a name="gnutls_005frnd_005flevel_005ft"></a>
     <ul>
<li>GNUTLS_RND_NONCE
Non-predictable random number.  Fatal in parts
of session if broken, i.e., vulnerable to statistical analysis. 
<li>GNUTLS_RND_RANDOM
Pseudo-random cryptographic random number. 
Fatal in session if broken. 
<li>GNUTLS_RND_KEY
Fatal in many sessions if broken. 
</ul>
<p><strong class="float-caption">Table 7.4</strong></p></div>

     <ul>
<li><a href="#gnutls_005frnd">gnutls_rnd</a>
</ul>

<div class="node">
<a name="Selecting-cryptographic-key-sizes"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-the-cryptographic-library">Using the cryptographic library</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#How-to-use-GnuTLS-in-applications">How to use GnuTLS in applications</a>

</div>

<h3 class="section">7.11 Selecting cryptographic key sizes</h3>

<p><a name="index-key-sizes-69"></a>
Because many algorithms are involved in TLS, it is not easy to set
a consistent security level.  For this reason in <a href="#tab_003akey_002dsizes">tab:key-sizes</a> we
present some correspondence between key sizes of symmetric algorithms
and public key algorithms based on [<em>ECRYPT</em>]. 
Those can be used to generate certificates with
appropriate key sizes as well as select parameters for Diffie-Hellman and SRP
authentication.

<div class="float">
<a name="tab_003akey_002dsizes"></a>
<p><table summary="">
<tr align="left"><th valign="top" width="10%">Security bits </th><th valign="top" width="12%">RSA, DH and SRP parameter size </th><th valign="top" width="10%">ECC key size </th><th valign="top" width="20%">Security parameter </th><th valign="top" width="32%">Description

<p><br></th></tr><tr align="left"><td valign="top" width="10%">64
</td><td valign="top" width="12%">816
</td><td valign="top" width="10%">128
</td><td valign="top" width="20%"><code>WEAK</code>
</td><td valign="top" width="32%">Very short term protection against small organizations

<p><br></td></tr><tr align="left"><td valign="top" width="10%">80
</td><td valign="top" width="12%">1248
</td><td valign="top" width="10%">160
</td><td valign="top" width="20%"><code>LOW</code>
</td><td valign="top" width="32%">Very short term protection against agencies

<p><br></td></tr><tr align="left"><td valign="top" width="10%">112
</td><td valign="top" width="12%">2432
</td><td valign="top" width="10%">224
</td><td valign="top" width="20%"><code>NORMAL</code>
</td><td valign="top" width="32%">Medium-term protection

<p><br></td></tr><tr align="left"><td valign="top" width="10%">128
</td><td valign="top" width="12%">3248
</td><td valign="top" width="10%">256
</td><td valign="top" width="20%"><code>HIGH</code>
</td><td valign="top" width="32%">Long term protection

<p><br></td></tr><tr align="left"><td valign="top" width="10%">256
</td><td valign="top" width="12%">15424
</td><td valign="top" width="10%">512
</td><td valign="top" width="20%"><code>ULTRA</code>
</td><td valign="top" width="32%">Foreseeable future

<br></td></tr></table>

<p><strong class="float-caption">Table 7.5: Key sizes and security parameters.</strong></p></div>

<p>The first column  provides a security parameter in a number of bits. This
gives an indication of the number of combinations to be tried by an adversary
to brute force a key. For example to test all possible keys in a 112 bit security parameter
2^112 combinations have to be tried. For today's technology this is infeasible. 
The next two columns correlate the security
parameter with actual bit sizes of parameters for DH, RSA, SRP and ECC algorithms. 
A mapping to <code>gnutls_sec_param_t</code> value is given for each security parameter, on
the next column, and finally a brief description of the level.

<!-- @showenumdesc{gnutls_sec_param_t,The @code{gnutls_sec_@-param_t} enumeration.} -->
<p>Note, however, that the values suggested here are nothing more than an
educated guess that is valid today. There are no guarantees that an
algorithm will remain unbreakable or that these values will remain
constant in time. There could be scientific breakthroughs that cannot
be predicted or total failure of the current public key systems by
quantum computers. On the other hand though the cryptosystems used in
TLS are selected in a conservative way and such catastrophic
breakthroughs or failures are believed to be unlikely. 
The NIST publication SP 800-57 [<em>NISTSP80057</em>] contains a similar
table.

<p>When using <acronym>GnuTLS</acronym> and a decision on bit sizes for a public
key algorithm is required, use of the following functions is
recommended:

     <ul>
<li><a href="#gnutls_005fsec_005fparam_005fto_005fpk_005fbits">gnutls_sec_param_to_pk_bits</a>
</ul>

     <ul>
<li><a href="#gnutls_005fpk_005fbits_005fto_005fsec_005fparam">gnutls_pk_bits_to_sec_param</a>
</ul>

<p>Those functions will convert a human understandable security parameter
of <code>gnutls_sec_param_t</code> type, to a number of bits suitable for a public
key algorithm.

<div class="node">
<a name="GnuTLS-application-examples"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Other-included-programs">Other included programs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#How-to-use-GnuTLS-in-applications">How to use GnuTLS in applications</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">8 GnuTLS application examples</h2>

<p><a name="examples"></a><a name="index-example-programs-70"></a><a name="index-examples-71"></a>

<ul class="menu">
<li><a accesskey="1" href="#Client-examples">Client examples</a>
<li><a accesskey="2" href="#Server-examples">Server examples</a>
<li><a accesskey="3" href="#Miscellaneous-examples">Miscellaneous examples</a>
</ul>

<div class="node">
<a name="Client-examples"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Server-examples">Server examples</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#GnuTLS-application-examples">GnuTLS application examples</a>

</div>

<h3 class="section">8.1 Client examples</h3>

<p>This section contains examples of <acronym>TLS</acronym> and <acronym>SSL</acronym>
clients, using <acronym>GnuTLS</acronym>.  Note that these examples contain
little or no error checking.  Some of the examples require functions
implemented by another example.

<ul class="menu">
<li><a accesskey="1" href="#Simple-client-example-with-anonymous-authentication">Simple client example with anonymous authentication</a>
<li><a accesskey="2" href="#Simple-client-example-with-X_002e509-certificate-support">Simple client example with X.509 certificate support</a>
<li><a accesskey="3" href="#Simple-Datagram-TLS-client-example">Simple Datagram TLS client example</a>
<li><a accesskey="4" href="#Obtaining-session-information">Obtaining session information</a>
<li><a accesskey="5" href="#Using-a-callback-to-select-the-certificate-to-use">Using a callback to select the certificate to use</a>
<li><a accesskey="6" href="#Verifying-a-certificate">Verifying a certificate</a>
<li><a accesskey="7" href="#Client-using-a-PKCS-11-token-with-TLS">Client using a PKCS 11 token with TLS</a>
<li><a accesskey="8" href="#Client-with-Resume-capability-example">Client with Resume capability example</a>
<li><a accesskey="9" href="#Simple-client-example-with-SRP-authentication">Simple client example with SRP authentication</a>
<li><a href="#Simple-client-example-in-C_002b_002b">Simple client example in C++</a>
<li><a href="#Helper-function-for-TCP-connections">Helper function for TCP connections</a>
</ul>

<div class="node">
<a name="Simple-client-example-with-anonymous-authentication"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Simple-client-example-with-X_002e509-certificate-support">Simple client example with X.509 certificate support</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Client-examples">Client examples</a>

</div>

<h4 class="subsection">8.1.1 Simple client example with anonymous authentication</h4>

<p>The simplest client using TLS is the one that doesn't do any
authentication.  This means no external certificates or passwords are
needed to set up the connection.  As could be expected, the connection
is vulnerable to man-in-the-middle (active or redirection) attacks. 
However, the data is integrity and privacy protected.

<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h>
#endif

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#include &lt;sys/types.h>
#include &lt;sys/socket.h>
#include &lt;arpa/inet.h>
#include &lt;unistd.h>
#include &lt;gnutls/gnutls.h>

/* A very basic TLS client, with anonymous authentication.
 */

#define MAX_BUF 1024
#define MSG "GET / HTTP/1.0\r\n\r\n"

extern int tcp_connect (void);
extern void tcp_close (int sd);

int
main (void)
{
  int ret, sd, ii;
  gnutls_session_t session;
  char buffer[MAX_BUF + 1];
  gnutls_anon_client_credentials_t anoncred;
  /* Need to enable anonymous KX specifically. */

  gnutls_global_init ();

  gnutls_anon_allocate_client_credentials (&amp;anoncred);

  /* Initialize TLS session 
   */
  gnutls_init (&amp;session, GNUTLS_CLIENT);

  /* Use default priorities */
  gnutls_priority_set_direct (session, "PERFORMANCE:+ANON-ECDH:+ANON-DH",
                              NULL);

  /* put the anonymous credentials to the current session
   */
  gnutls_credentials_set (session, GNUTLS_CRD_ANON, anoncred);

  /* connect to the peer
   */
  sd = tcp_connect ();

  gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) sd);

  /* Perform the TLS handshake
   */
  ret = gnutls_handshake (session);

  if (ret &lt; 0)
    {
      fprintf (stderr, "*** Handshake failed\n");
      gnutls_perror (ret);
      goto end;
    }
  else
    {
      printf ("- Handshake was completed\n");
    }

  gnutls_record_send (session, MSG, strlen (MSG));

  ret = gnutls_record_recv (session, buffer, MAX_BUF);
  if (ret == 0)
    {
      printf ("- Peer has closed the TLS connection\n");
      goto end;
    }
  else if (ret &lt; 0)
    {
      fprintf (stderr, "*** Error: %s\n", gnutls_strerror (ret));
      goto end;
    }

  printf ("- Received %d bytes: ", ret);
  for (ii = 0; ii &lt; ret; ii++)
    {
      fputc (buffer[ii], stdout);
    }
  fputs ("\n", stdout);

  gnutls_bye (session, GNUTLS_SHUT_RDWR);

end:

  tcp_close (sd);

  gnutls_deinit (session);

  gnutls_anon_free_client_credentials (anoncred);

  gnutls_global_deinit ();

  return 0;
}
</pre>
<div class="node">
<a name="Simple-client-example-with-X.509-certificate-support"></a>
<a name="Simple-client-example-with-X_002e509-certificate-support"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Simple-Datagram-TLS-client-example">Simple Datagram TLS client example</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Simple-client-example-with-anonymous-authentication">Simple client example with anonymous authentication</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Client-examples">Client examples</a>

</div>

<h4 class="subsection">8.1.2 Simple client example with <acronym>X.509</acronym> certificate support</h4>

<p><a name="ex_003averify"></a>Let's assume now that we want to create a TCP client which
communicates with servers that use <acronym>X.509</acronym> or
<acronym>OpenPGP</acronym> certificate authentication. The following client is
a very simple <acronym>TLS</acronym> client, which uses the high level verification
functions for certificates, but does not support session
resumption.

<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h>
#endif

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#include &lt;gnutls/gnutls.h>
#include &lt;gnutls/x509.h>
#include "examples.h"

/* A very basic TLS client, with X.509 authentication and server certificate
 * verification.
 */

#define MAX_BUF 1024
#define CAFILE "ca.pem"
#define MSG "GET / HTTP/1.0\r\n\r\n"

extern int tcp_connect (void);
extern void tcp_close (int sd);
static int _verify_certificate_callback (gnutls_session_t session);

int main (void)
{
  int ret, sd, ii;
  gnutls_session_t session;
  char buffer[MAX_BUF + 1];
  const char *err;
  gnutls_certificate_credentials_t xcred;

  gnutls_global_init ();

  /* X509 stuff */
  gnutls_certificate_allocate_credentials (&amp;xcred);

  /* sets the trusted cas file
   */
  gnutls_certificate_set_x509_trust_file (xcred, CAFILE, GNUTLS_X509_FMT_PEM);
  gnutls_certificate_set_verify_function (xcred, _verify_certificate_callback);

  /* Initialize TLS session 
   */
  gnutls_init (&amp;session, GNUTLS_CLIENT);

  gnutls_session_set_ptr (session, (void *) "my_host_name");

  /* Use default priorities */
  ret = gnutls_priority_set_direct (session, "NORMAL", &amp;err);
  if (ret &lt; 0)
    {
      if (ret == GNUTLS_E_INVALID_REQUEST)
        {
          fprintf (stderr, "Syntax error at: %s\n", err);
        }
      exit (1);
    }

  /* put the x509 credentials to the current session
   */
  gnutls_credentials_set (session, GNUTLS_CRD_CERTIFICATE, xcred);

  /* connect to the peer
   */
  sd = tcp_connect ();

  gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) sd);

  /* Perform the TLS handshake
   */
  ret = gnutls_handshake (session);

  if (ret &lt; 0)
    {
      fprintf (stderr, "*** Handshake failed\n");
      gnutls_perror (ret);
      goto end;
    }
  else
    {
      printf ("- Handshake was completed\n");
    }

  gnutls_record_send (session, MSG, strlen (MSG));

  ret = gnutls_record_recv (session, buffer, MAX_BUF);
  if (ret == 0)
    {
      printf ("- Peer has closed the TLS connection\n");
      goto end;
    }
  else if (ret &lt; 0)
    {
      fprintf (stderr, "*** Error: %s\n", gnutls_strerror (ret));
      goto end;
    }

  printf ("- Received %d bytes: ", ret);
  for (ii = 0; ii &lt; ret; ii++)
    {
      fputc (buffer[ii], stdout);
    }
  fputs ("\n", stdout);

  gnutls_bye (session, GNUTLS_SHUT_RDWR);

end:

  tcp_close (sd);

  gnutls_deinit (session);

  gnutls_certificate_free_credentials (xcred);

  gnutls_global_deinit ();

  return 0;
}

/* This function will verify the peer's certificate, and check
 * if the hostname matches, as well as the activation, expiration dates.
 */
static int
_verify_certificate_callback (gnutls_session_t session)
{
  unsigned int status;
  const gnutls_datum_t *cert_list;
  unsigned int cert_list_size;
  int ret;
  gnutls_x509_crt_t cert;
  const char *hostname;

  /* read hostname */
  hostname = gnutls_session_get_ptr (session);

  /* This verification function uses the trusted CAs in the credentials
   * structure. So you must have installed one or more CA certificates.
   */
  ret = gnutls_certificate_verify_peers2 (session, &amp;status);
  if (ret &lt; 0)
    {
      printf ("Error\n");
      return GNUTLS_E_CERTIFICATE_ERROR;
    }

  if (status &amp; GNUTLS_CERT_INVALID)
    printf ("The certificate is not trusted.\n");

  if (status &amp; GNUTLS_CERT_SIGNER_NOT_FOUND)
    printf ("The certificate hasn't got a known issuer.\n");

  if (status &amp; GNUTLS_CERT_REVOKED)
    printf ("The certificate has been revoked.\n");

  if (status &amp; GNUTLS_CERT_EXPIRED)
    printf ("The certificate has expired\n");

  if (status &amp; GNUTLS_CERT_NOT_ACTIVATED)
    printf ("The certificate is not yet activated\n");

  /* Up to here the process is the same for X.509 certificates and
   * OpenPGP keys. From now on X.509 certificates are assumed. This can
   * be easily extended to work with openpgp keys as well.
   */
  if (gnutls_certificate_type_get (session) != GNUTLS_CRT_X509)
    return GNUTLS_E_CERTIFICATE_ERROR;

  if (gnutls_x509_crt_init (&amp;cert) &lt; 0)
    {
      printf ("error in initialization\n");
      return GNUTLS_E_CERTIFICATE_ERROR;
    }

  cert_list = gnutls_certificate_get_peers (session, &amp;cert_list_size);
  if (cert_list == NULL)
    {
      printf ("No certificate was found!\n");
      return GNUTLS_E_CERTIFICATE_ERROR;
    }

  /* This is not a real world example, since we only check the first 
   * certificate in the given chain.
   */
  if (gnutls_x509_crt_import (cert, &amp;cert_list[0], GNUTLS_X509_FMT_DER) &lt; 0)
    {
      printf ("error parsing certificate\n");
      return GNUTLS_E_CERTIFICATE_ERROR;
    }


  if (!gnutls_x509_crt_check_hostname (cert, hostname))
    {
      printf ("The certificate's owner does not match hostname '%s'\n",
              hostname);
      return GNUTLS_E_CERTIFICATE_ERROR;
    }

  gnutls_x509_crt_deinit (cert);

  /* notify gnutls to continue handshake normally */
  return 0;
}

</pre>
<div class="node">
<a name="Simple-Datagram-TLS-client-example"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Obtaining-session-information">Obtaining session information</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Simple-client-example-with-X_002e509-certificate-support">Simple client example with X.509 certificate support</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Client-examples">Client examples</a>

</div>

<h4 class="subsection">8.1.3 Simple datagram <acronym>TLS</acronym> client example</h4>

<p>This is a client that uses <acronym>UDP</acronym> to connect to a
server. This is the <acronym>DTLS</acronym> equivalent to the example
in <a href="#Simple-client-example-with-X_002e509-certificate-support">Simple client example with X.509 certificate support</a>.

<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h>
#endif

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#include &lt;sys/types.h>
#include &lt;sys/socket.h>
#include &lt;arpa/inet.h>
#include &lt;unistd.h>
#include &lt;gnutls/gnutls.h>
#include &lt;gnutls/dtls.h>

/* A very basic Datagram TLS client, over UDP with X.509 authentication.
 */

#define MAX_BUF 1024
#define CAFILE "ca.pem"
#define MSG "GET / HTTP/1.0\r\n\r\n"

extern int udp_connect (void);
extern void udp_close (int sd);
extern int verify_certificate_callback (gnutls_session_t session);

int
main (void)
{
  int ret, sd, ii;
  gnutls_session_t session;
  char buffer[MAX_BUF + 1];
  const char *err;
  gnutls_certificate_credentials_t xcred;

  gnutls_global_init ();

  /* X509 stuff */
  gnutls_certificate_allocate_credentials (&amp;xcred);

  /* sets the trusted cas file */
  gnutls_certificate_set_x509_trust_file (xcred, CAFILE, GNUTLS_X509_FMT_PEM);
  gnutls_certificate_set_verify_function (xcred, verify_certificate_callback);

  /* Initialize TLS session */
  gnutls_init (&amp;session, GNUTLS_CLIENT | GNUTLS_DATAGRAM);

  /* Use default priorities */
  ret = gnutls_priority_set_direct (session, "NORMAL", &amp;err);
  if (ret &lt; 0)
    {
      if (ret == GNUTLS_E_INVALID_REQUEST)
        {
          fprintf (stderr, "Syntax error at: %s\n", err);
        }
      exit (1);
    }

  /* put the x509 credentials to the current session */
  gnutls_credentials_set (session, GNUTLS_CRD_CERTIFICATE, xcred);

  /* connect to the peer */
  sd = udp_connect ();

  gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) sd);

  /* set the connection MTU */
  gnutls_dtls_set_mtu (session, 1000);

  /* Perform the TLS handshake */
  ret = gnutls_handshake (session);

  if (ret &lt; 0)
    {
      fprintf (stderr, "*** Handshake failed\n");
      gnutls_perror (ret);
      goto end;
    }
  else
    {
      printf ("- Handshake was completed\n");
    }

  gnutls_record_send (session, MSG, strlen (MSG));

  ret = gnutls_record_recv (session, buffer, MAX_BUF);
  if (ret == 0)
    {
      printf ("- Peer has closed the TLS connection\n");
      goto end;
    }
  else if (ret &lt; 0)
    {
      fprintf (stderr, "*** Error: %s\n", gnutls_strerror (ret));
      goto end;
    }

  printf ("- Received %d bytes: ", ret);
  for (ii = 0; ii &lt; ret; ii++)
    {
      fputc (buffer[ii], stdout);
    }
  fputs ("\n", stdout);

  /* It is suggested not to use GNUTLS_SHUT_RDWR in DTLS
   * connections because the peer's closure message might
   * be lost */
  gnutls_bye (session, GNUTLS_SHUT_WR);

end:

  udp_close (sd);

  gnutls_deinit (session);

  gnutls_certificate_free_credentials (xcred);

  gnutls_global_deinit ();

  return 0;
}
</pre>
<div class="node">
<a name="Obtaining-session-information"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Using-a-callback-to-select-the-certificate-to-use">Using a callback to select the certificate to use</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Simple-Datagram-TLS-client-example">Simple Datagram TLS client example</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Client-examples">Client examples</a>

</div>

<h4 class="subsection">8.1.4 Obtaining session information</h4>

<p>Most of the times it is desirable to know the security properties of
the current established session.  This includes the underlying ciphers
and the protocols involved.  That is the purpose of the following
function.  Note that this function will print meaningful values only
if called after a successful <a href="#gnutls_005fhandshake">gnutls_handshake</a>.

<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h>
#endif

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;gnutls/gnutls.h>
#include &lt;gnutls/x509.h>

#include "examples.h"

/* This function will print some details of the
 * given session.
 */
int
print_info (gnutls_session_t session)
{
  const char *tmp;
  gnutls_credentials_type_t cred;
  gnutls_kx_algorithm_t kx;
  int dhe, ecdh;

  dhe = ecdh = 0;

  /* print the key exchange's algorithm name
   */
  kx = gnutls_kx_get (session);
  tmp = gnutls_kx_get_name (kx);
  printf ("- Key Exchange: %s\n", tmp);

  /* Check the authentication type used and switch
   * to the appropriate.
   */
  cred = gnutls_auth_get_type (session);
  switch (cred)
    {
    case GNUTLS_CRD_IA:
      printf ("- TLS/IA session\n");
      break;


#ifdef ENABLE_SRP
    case GNUTLS_CRD_SRP:
      printf ("- SRP session with username %s\n",
              gnutls_srp_server_get_username (session));
      break;
#endif

    case GNUTLS_CRD_PSK:
      /* This returns NULL in server side.
       */
      if (gnutls_psk_client_get_hint (session) != NULL)
        printf ("- PSK authentication. PSK hint '%s'\n",
                gnutls_psk_client_get_hint (session));
      /* This returns NULL in client side.
       */
      if (gnutls_psk_server_get_username (session) != NULL)
        printf ("- PSK authentication. Connected as '%s'\n",
                gnutls_psk_server_get_username (session));

      if (kx == GNUTLS_KX_ECDHE_PSK)
        ecdh = 1;
      else if (kx == GNUTLS_KX_DHE_PSK)
        dhe = 1;
      break;

    case GNUTLS_CRD_ANON:      /* anonymous authentication */

      printf ("- Anonymous authentication.\n");
      if (kx == GNUTLS_KX_ANON_ECDH)
        ecdh = 1;
      else if (kx == GNUTLS_KX_ANON_DH)
        dhe = 1;
      break;

    case GNUTLS_CRD_CERTIFICATE:       /* certificate authentication */

      /* Check if we have been using ephemeral Diffie-Hellman.
       */
      if (kx == GNUTLS_KX_DHE_RSA || kx == GNUTLS_KX_DHE_DSS)
        dhe = 1;
      else if (kx == GNUTLS_KX_ECDHE_RSA || kx == GNUTLS_KX_ECDHE_ECDSA)
        ecdh = 1;

      /* if the certificate list is available, then
       * print some information about it.
       */
      print_x509_certificate_info (session);

    }                           /* switch */

  if (ecdh != 0)
    printf ("- Ephemeral ECDH using curve %s\n",
            gnutls_ecc_curve_get_name (gnutls_ecc_curve_get (session)));
  else if (dhe != 0)
    printf ("- Ephemeral DH using prime of %d bits\n",
            gnutls_dh_get_prime_bits (session));

  /* print the protocol's name (ie TLS 1.0) 
   */
  tmp = gnutls_protocol_get_name (gnutls_protocol_get_version (session));
  printf ("- Protocol: %s\n", tmp);

  /* print the certificate type of the peer.
   * ie X.509
   */
  tmp =
    gnutls_certificate_type_get_name (gnutls_certificate_type_get (session));

  printf ("- Certificate Type: %s\n", tmp);

  /* print the compression algorithm (if any)
   */
  tmp = gnutls_compression_get_name (gnutls_compression_get (session));
  printf ("- Compression: %s\n", tmp);

  /* print the name of the cipher used.
   * ie 3DES.
   */
  tmp = gnutls_cipher_get_name (gnutls_cipher_get (session));
  printf ("- Cipher: %s\n", tmp);

  /* Print the MAC algorithms name.
   * ie SHA1
   */
  tmp = gnutls_mac_get_name (gnutls_mac_get (session));
  printf ("- MAC: %s\n", tmp);

  return 0;
}
</pre>
<div class="node">
<a name="Using-a-callback-to-select-the-certificate-to-use"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Verifying-a-certificate">Verifying a certificate</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Obtaining-session-information">Obtaining session information</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Client-examples">Client examples</a>

</div>

<h4 class="subsection">8.1.5 Using a callback to select the certificate to use</h4>

<p>There are cases where a client holds several certificate and key
pairs, and may not want to load all of them in the credentials
structure.  The following example demonstrates the use of the
certificate selection callback.

<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h>
#endif

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#include &lt;sys/types.h>
#include &lt;sys/socket.h>
#include &lt;arpa/inet.h>
#include &lt;unistd.h>
#include &lt;gnutls/gnutls.h>
#include &lt;gnutls/x509.h>
#include &lt;gnutls/abstract.h>
#include &lt;sys/types.h>
#include &lt;sys/stat.h>
#include &lt;fcntl.h>

/* A TLS client that loads the certificate and key.
 */

#define MAX_BUF 1024
#define MSG "GET / HTTP/1.0\r\n\r\n"

#define CERT_FILE "cert.pem"
#define KEY_FILE "key.pem"
#define CAFILE "ca.pem"

extern int tcp_connect (void);
extern void tcp_close (int sd);

static int
cert_callback (gnutls_session_t session,
               const gnutls_datum_t * req_ca_rdn, int nreqs,
               const gnutls_pk_algorithm_t * sign_algos,
               int sign_algos_length, gnutls_pcert_st ** pcert,
               unsigned int *pcert_length, gnutls_privkey_t * pkey);

gnutls_pcert_st crt;
gnutls_privkey_t key;

/* Helper functions to load a certificate and key
 * files into memory.
 */
static gnutls_datum_t
load_file (const char *file)
{
  FILE *f;
  gnutls_datum_t loaded_file = { NULL, 0 };
  long filelen;
  void *ptr;

  if (!(f = fopen (file, "r"))
      || fseek (f, 0, SEEK_END) != 0
      || (filelen = ftell (f)) &lt; 0
      || fseek (f, 0, SEEK_SET) != 0
      || !(ptr = malloc ((size_t) filelen))
      || fread (ptr, 1, (size_t) filelen, f) &lt; (size_t) filelen)
    {
      return loaded_file;
    }

  loaded_file.data = ptr;
  loaded_file.size = (unsigned int) filelen;
  return loaded_file;
}

static void
unload_file (gnutls_datum_t data)
{
  free (data.data);
}

/* Load the certificate and the private key.
 */
static void
load_keys (void)
{
  int ret;
  gnutls_datum_t data;
  gnutls_x509_privkey_t x509_key;

  data = load_file (CERT_FILE);
  if (data.data == NULL)
    {
      fprintf (stderr, "*** Error loading certificate file.\n");
      exit (1);
    }

  ret = gnutls_pcert_import_x509_raw (&amp;crt, &amp;data, GNUTLS_X509_FMT_PEM, 0);
  if (ret &lt; 0)
    {
      fprintf (stderr, "*** Error loading certificate file: %s\n",
               gnutls_strerror (ret));
      exit (1);
    }

  unload_file (data);

  data = load_file (KEY_FILE);
  if (data.data == NULL)
    {
      fprintf (stderr, "*** Error loading key file.\n");
      exit (1);
    }

  gnutls_x509_privkey_init (&amp;x509_key);

  ret = gnutls_x509_privkey_import (x509_key, &amp;data, GNUTLS_X509_FMT_PEM);
  if (ret &lt; 0)
    {
      fprintf (stderr, "*** Error loading key file: %s\n",
               gnutls_strerror (ret));
      exit (1);
    }

  gnutls_privkey_init (&amp;key);

  ret =
    gnutls_privkey_import_x509 (key, x509_key,
                                GNUTLS_PRIVKEY_IMPORT_AUTO_RELEASE);
  if (ret &lt; 0)
    {
      fprintf (stderr, "*** Error importing key: %s\n",
               gnutls_strerror (ret));
      exit (1);
    }

  unload_file (data);
}

int
main (void)
{
  int ret, sd, ii;
  gnutls_session_t session;
  gnutls_priority_t priorities_cache;
  char buffer[MAX_BUF + 1];
  gnutls_certificate_credentials_t xcred;
  /* Allow connections to servers that have OpenPGP keys as well.
   */

  gnutls_global_init ();

  load_keys ();

  /* X509 stuff */
  gnutls_certificate_allocate_credentials (&amp;xcred);

  /* priorities */
  gnutls_priority_init (&amp;priorities_cache, "NORMAL", NULL);


  /* sets the trusted cas file
   */
  gnutls_certificate_set_x509_trust_file (xcred, CAFILE, GNUTLS_X509_FMT_PEM);

  gnutls_certificate_set_retrieve_function2 (xcred, cert_callback);

  /* Initialize TLS session 
   */
  gnutls_init (&amp;session, GNUTLS_CLIENT);

  /* Use default priorities */
  gnutls_priority_set (session, priorities_cache);

  /* put the x509 credentials to the current session
   */
  gnutls_credentials_set (session, GNUTLS_CRD_CERTIFICATE, xcred);

  /* connect to the peer
   */
  sd = tcp_connect ();

  gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) sd);

  /* Perform the TLS handshake
   */
  ret = gnutls_handshake (session);

  if (ret &lt; 0)
    {
      fprintf (stderr, "*** Handshake failed\n");
      gnutls_perror (ret);
      goto end;
    }
  else
    {
      printf ("- Handshake was completed\n");
    }

  gnutls_record_send (session, MSG, strlen (MSG));

  ret = gnutls_record_recv (session, buffer, MAX_BUF);
  if (ret == 0)
    {
      printf ("- Peer has closed the TLS connection\n");
      goto end;
    }
  else if (ret &lt; 0)
    {
      fprintf (stderr, "*** Error: %s\n", gnutls_strerror (ret));
      goto end;
    }

  printf ("- Received %d bytes: ", ret);
  for (ii = 0; ii &lt; ret; ii++)
    {
      fputc (buffer[ii], stdout);
    }
  fputs ("\n", stdout);

  gnutls_bye (session, GNUTLS_SHUT_RDWR);

end:

  tcp_close (sd);

  gnutls_deinit (session);

  gnutls_certificate_free_credentials (xcred);
  gnutls_priority_deinit (priorities_cache);

  gnutls_global_deinit ();

  return 0;
}



/* This callback should be associated with a session by calling
 * gnutls_certificate_client_set_retrieve_function( session, cert_callback),
 * before a handshake.
 */

static int
cert_callback (gnutls_session_t session,
               const gnutls_datum_t * req_ca_rdn, int nreqs,
               const gnutls_pk_algorithm_t * sign_algos,
               int sign_algos_length, gnutls_pcert_st ** pcert,
               unsigned int *pcert_length, gnutls_privkey_t * pkey)
{
  char issuer_dn[256];
  int i, ret;
  size_t len;
  gnutls_certificate_type_t type;

  /* Print the server's trusted CAs
   */
  if (nreqs > 0)
    printf ("- Server's trusted authorities:\n");
  else
    printf ("- Server did not send us any trusted authorities names.\n");

  /* print the names (if any) */
  for (i = 0; i &lt; nreqs; i++)
    {
      len = sizeof (issuer_dn);
      ret = gnutls_x509_rdn_get (&amp;req_ca_rdn[i], issuer_dn, &amp;len);
      if (ret >= 0)
        {
          printf ("   [%d]: ", i);
          printf ("%s\n", issuer_dn);
        }
    }

  /* Select a certificate and return it.
   * The certificate must be of any of the "sign algorithms"
   * supported by the server.
   */
  type = gnutls_certificate_type_get (session);
  if (type == GNUTLS_CRT_X509)
    {
      *pcert_length = 1;
      *pcert = &amp;crt;
      *pkey = key;
    }
  else
    {
      return -1;
    }

  return 0;

}
</pre>
<div class="node">
<a name="Verifying-a-certificate"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Client-using-a-PKCS-11-token-with-TLS">Client using a PKCS 11 token with TLS</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Using-a-callback-to-select-the-certificate-to-use">Using a callback to select the certificate to use</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Client-examples">Client examples</a>

</div>

<h4 class="subsection">8.1.6 Verifying a certificate</h4>

<p><a name="ex_003averify2"></a>An example is listed below which uses the high level verification
functions to verify a given certificate list.

<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h>
#endif

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#include &lt;gnutls/gnutls.h>
#include &lt;gnutls/x509.h>

#include "examples.h"

/* All the available CRLs
 */
gnutls_x509_crl_t *crl_list;
int crl_list_size;

/* All the available trusted CAs
 */
gnutls_x509_crt_t *ca_list;
int ca_list_size;

static int print_details_func (gnutls_x509_crt_t cert,
                               gnutls_x509_crt_t issuer,
                               gnutls_x509_crl_t crl,
                               unsigned int verification_output);

/* This function will try to verify the peer's certificate chain, and
 * also check if the hostname matches.
 */
void
verify_certificate_chain (const char *hostname,
                          const gnutls_datum_t * cert_chain,
                          int cert_chain_length)
{
  int i;
  gnutls_x509_trust_list_t tlist;
  gnutls_x509_crt_t *cert;

  unsigned int output;

  /* Initialize the trusted certificate list. This should be done
   * once on initialization. gnutls_x509_crt_list_import2() and
   * gnutls_x509_crl_list_import2() can be used to load them.
   */
  gnutls_x509_trust_list_init (&amp;tlist, 0);

  gnutls_x509_trust_list_add_cas (tlist, ca_list, ca_list_size, 0);
  gnutls_x509_trust_list_add_crls (tlist, crl_list, crl_list_size,
                                   GNUTLS_TL_VERIFY_CRL, 0);

  cert = malloc (sizeof (*cert) * cert_chain_length);

  /* Import all the certificates in the chain to
   * native certificate format.
   */
  for (i = 0; i &lt; cert_chain_length; i++)
    {
      gnutls_x509_crt_init (&amp;cert[i]);
      gnutls_x509_crt_import (cert[i], &amp;cert_chain[i], GNUTLS_X509_FMT_DER);
    }

  gnutls_x509_trust_list_verify_named_crt (tlist, cert[0], hostname,
                                           strlen (hostname),
                                           GNUTLS_VERIFY_DISABLE_CRL_CHECKS,
                                           &amp;output, print_details_func);

  /* if this certificate is not explicitly trusted verify against CAs 
   */
  if (output != 0)
    {
      gnutls_x509_trust_list_verify_crt (tlist, cert, cert_chain_length, 0,
                                         &amp;output, print_details_func);
    }

  if (output &amp; GNUTLS_CERT_INVALID)
    {
      fprintf (stderr, "Not trusted");

      if (output &amp; GNUTLS_CERT_SIGNER_NOT_FOUND)
        fprintf (stderr, ": no issuer was found");
      if (output &amp; GNUTLS_CERT_SIGNER_NOT_CA)
        fprintf (stderr, ": issuer is not a CA");
      if (output &amp; GNUTLS_CERT_NOT_ACTIVATED)
        fprintf (stderr, ": not yet activated\n");
      if (output &amp; GNUTLS_CERT_EXPIRED)
        fprintf (stderr, ": expired\n");

      fprintf (stderr, "\n");
    }
  else
    fprintf (stderr, "Trusted\n");

  /* Check if the name in the first certificate matches our destination!
   */
  if (!gnutls_x509_crt_check_hostname (cert[0], hostname))
    {
      printf ("The certificate's owner does not match hostname '%s'\n",
              hostname);
    }

  gnutls_x509_trust_list_deinit (tlist, 1);

  return;
}

static int
print_details_func (gnutls_x509_crt_t cert,
                    gnutls_x509_crt_t issuer, gnutls_x509_crl_t crl,
                    unsigned int verification_output)
{
  char name[512];
  char issuer_name[512];
  size_t name_size;
  size_t issuer_name_size;

  issuer_name_size = sizeof (issuer_name);
  gnutls_x509_crt_get_issuer_dn (cert, issuer_name, &amp;issuer_name_size);

  name_size = sizeof (name);
  gnutls_x509_crt_get_dn (cert, name, &amp;name_size);

  fprintf (stdout, "\tSubject: %s\n", name);
  fprintf (stdout, "\tIssuer: %s\n", issuer_name);

  if (issuer != NULL)
    {
      issuer_name_size = sizeof (issuer_name);
      gnutls_x509_crt_get_dn (issuer, issuer_name, &amp;issuer_name_size);

      fprintf (stdout, "\tVerified against: %s\n", issuer_name);
    }

  if (crl != NULL)
    {
      issuer_name_size = sizeof (issuer_name);
      gnutls_x509_crl_get_issuer_dn (crl, issuer_name, &amp;issuer_name_size);

      fprintf (stdout, "\tVerified against CRL of: %s\n", issuer_name);
    }

  fprintf (stdout, "\tVerification output: %x\n\n", verification_output);

  return 0;
}
</pre>
<div class="node">
<a name="Client-using-a-PKCS-11-token-with-TLS"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Client-with-Resume-capability-example">Client with Resume capability example</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Verifying-a-certificate">Verifying a certificate</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Client-examples">Client examples</a>

</div>

<h4 class="subsection">8.1.7 Using a <acronym>PKCS</acronym> #11 token with TLS</h4>

<p><a name="ex_003apkcs11_002dclient"></a>This example will demonstrate how to load keys and certificates
from a <acronym>PKCS</acronym> #11 token, and use it with a TLS connection.

<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h>
#endif

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#include &lt;sys/types.h>
#include &lt;sys/socket.h>
#include &lt;arpa/inet.h>
#include &lt;unistd.h>
#include &lt;gnutls/gnutls.h>
#include &lt;gnutls/x509.h>
#include &lt;gnutls/pkcs11.h>
#include &lt;sys/types.h>
#include &lt;sys/stat.h>
#include &lt;fcntl.h>
#include &lt;getpass.h> /* for getpass() */

/* A TLS client that loads the certificate and key.
 */

#define MAX_BUF 1024
#define MSG "GET / HTTP/1.0\r\n\r\n"
#define MIN(x,y) (((x)&lt;(y))?(x):(y))

#define CAFILE "ca.pem"

/* The URLs of the objects can be obtained
 * using p11tool --list-all --login
 */
#define KEY_URL "pkcs11:manufacturer=SomeManufacturer;object=Private%20Key" \
  ";objecttype=private;id=%db%5b%3e%b5%72%33"
#define CERT_URL "pkcs11:manufacturer=SomeManufacturer;object=Certificate;" \
  "objecttype=cert;id=db%5b%3e%b5%72%33"

extern int tcp_connect (void);
extern void tcp_close (int sd);

static int
pin_callback (void *user, int attempt, const char *token_url,
              const char *token_label, unsigned int flags, char *pin,
              size_t pin_max)
{
  const char *password;
  int len;

  printf ("PIN required for token '%s' with URL '%s'\n", token_label,
          token_url);
  if (flags &amp; GNUTLS_PKCS11_PIN_FINAL_TRY)
    printf ("*** This is the final try before locking!\n");
  if (flags &amp; GNUTLS_PKCS11_PIN_COUNT_LOW)
    printf ("*** Only few tries left before locking!\n");
  if (flags &amp; GNUTLS_PKCS11_PIN_WRONG)
    printf ("*** Wrong PIN\n");

  password = getpass ("Enter pin: ");
  if (password == NULL || password[0] == 0)
    {
      fprintf (stderr, "No password given\n");
      exit (1);
    }

  len = MIN (pin_max, strlen (password));
  memcpy (pin, password, len);
  pin[len] = 0;

  return 0;
}

int
main (void)
{
  int ret, sd, ii;
  gnutls_session_t session;
  gnutls_priority_t priorities_cache;
  char buffer[MAX_BUF + 1];
  gnutls_certificate_credentials_t xcred;
  /* Allow connections to servers that have OpenPGP keys as well.
   */

  gnutls_global_init ();
  /* PKCS11 private key operations might require PIN.
   * Register a callback.
   */
  gnutls_pkcs11_set_pin_function (pin_callback, NULL);

  /* X509 stuff */
  gnutls_certificate_allocate_credentials (&amp;xcred);

  /* priorities */
  gnutls_priority_init (&amp;priorities_cache, "NORMAL", NULL);

  /* sets the trusted cas file
   */
  gnutls_certificate_set_x509_trust_file (xcred, CAFILE, GNUTLS_X509_FMT_PEM);

  gnutls_certificate_set_x509_key_file (xcred, CERT_URL, KEY_URL, GNUTLS_X509_FMT_DER);

  /* Initialize TLS session
   */
  gnutls_init (&amp;session, GNUTLS_CLIENT);

  /* Use default priorities */
  gnutls_priority_set (session, priorities_cache);

  /* put the x509 credentials to the current session
   */
  gnutls_credentials_set (session, GNUTLS_CRD_CERTIFICATE, xcred);

  /* connect to the peer
   */
  sd = tcp_connect ();

  gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) sd);

  /* Perform the TLS handshake
   */
  ret = gnutls_handshake (session);

  if (ret &lt; 0)
    {
      fprintf (stderr, "*** Handshake failed\n");
      gnutls_perror (ret);
      goto end;
    }
  else
    {
      printf ("- Handshake was completed\n");
    }

  gnutls_record_send (session, MSG, strlen (MSG));

  ret = gnutls_record_recv (session, buffer, MAX_BUF);
  if (ret == 0)
    {
      printf ("- Peer has closed the TLS connection\n");
      goto end;
    }
  else if (ret &lt; 0)
    {
      fprintf (stderr, "*** Error: %s\n", gnutls_strerror (ret));
      goto end;
    }

  printf ("- Received %d bytes: ", ret);
  for (ii = 0; ii &lt; ret; ii++)
    {
      fputc (buffer[ii], stdout);
    }
  fputs ("\n", stdout);

  gnutls_bye (session, GNUTLS_SHUT_RDWR);

end:

  tcp_close (sd);

  gnutls_deinit (session);

  gnutls_certificate_free_credentials (xcred);
  gnutls_priority_deinit (priorities_cache);

  gnutls_global_deinit ();

  return 0;
}
</pre>

<div class="node">
<a name="Client-with-Resume-capability-example"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Simple-client-example-with-SRP-authentication">Simple client example with SRP authentication</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Client-using-a-PKCS-11-token-with-TLS">Client using a PKCS 11 token with TLS</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Client-examples">Client examples</a>

</div>

<h4 class="subsection">8.1.8 Client with resume capability example</h4>

<p><a name="ex_003aresume_002dclient"></a>This is a modification of the simple client example. Here we
demonstrate the use of session resumption. The client tries to connect
once using <acronym>TLS</acronym>, close the connection and then try to
establish a new connection using the previously negotiated data.

<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h>
#endif

#include &lt;string.h>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;gnutls/gnutls.h>

/* Those functions are defined in other examples.
 */
extern void check_alert (gnutls_session_t session, int ret);
extern int tcp_connect (void);
extern void tcp_close (int sd);

#define MAX_BUF 1024
#define CAFILE "ca.pem"
#define MSG "GET / HTTP/1.0\r\n\r\n"

int
main (void)
{
  int ret;
  int sd, ii;
  gnutls_session_t session;
  char buffer[MAX_BUF + 1];
  gnutls_certificate_credentials_t xcred;

  /* variables used in session resuming 
   */
  int t;
  char *session_data = NULL;
  size_t session_data_size = 0;

  gnutls_global_init ();

  /* X509 stuff */
  gnutls_certificate_allocate_credentials (&amp;xcred);

  gnutls_certificate_set_x509_trust_file (xcred, CAFILE, GNUTLS_X509_FMT_PEM);

  for (t = 0; t &lt; 2; t++)
    {                           /* connect 2 times to the server */

      sd = tcp_connect ();

      gnutls_init (&amp;session, GNUTLS_CLIENT);

      gnutls_priority_set_direct (session, "PERFORMANCE:!ARCFOUR-128", NULL);

      gnutls_credentials_set (session, GNUTLS_CRD_CERTIFICATE, xcred);

      if (t > 0)
        {
          /* if this is not the first time we connect */
          gnutls_session_set_data (session, session_data, session_data_size);
          free (session_data);
        }

      gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) sd);

      /* Perform the TLS handshake
       */
      ret = gnutls_handshake (session);

      if (ret &lt; 0)
        {
          fprintf (stderr, "*** Handshake failed\n");
          gnutls_perror (ret);
          goto end;
        }
      else
        {
          printf ("- Handshake was completed\n");
        }

      if (t == 0)
        {                       /* the first time we connect */
          /* get the session data size */
          gnutls_session_get_data (session, NULL, &amp;session_data_size);
          session_data = malloc (session_data_size);

          /* put session data to the session variable */
          gnutls_session_get_data (session, session_data, &amp;session_data_size);

        }
      else
        {                       /* the second time we connect */

          /* check if we actually resumed the previous session */
          if (gnutls_session_is_resumed (session) != 0)
            {
              printf ("- Previous session was resumed\n");
            }
          else
            {
              fprintf (stderr, "*** Previous session was NOT resumed\n");
            }
        }

      /* This function was defined in a previous example
       */
      /* print_info(session); */

      gnutls_record_send (session, MSG, strlen (MSG));

      ret = gnutls_record_recv (session, buffer, MAX_BUF);
      if (ret == 0)
        {
          printf ("- Peer has closed the TLS connection\n");
          goto end;
        }
      else if (ret &lt; 0)
        {
          fprintf (stderr, "*** Error: %s\n", gnutls_strerror (ret));
          goto end;
        }

      printf ("- Received %d bytes: ", ret);
      for (ii = 0; ii &lt; ret; ii++)
        {
          fputc (buffer[ii], stdout);
        }
      fputs ("\n", stdout);

      gnutls_bye (session, GNUTLS_SHUT_RDWR);

    end:

      tcp_close (sd);

      gnutls_deinit (session);

    }                           /* for() */

  gnutls_certificate_free_credentials (xcred);

  gnutls_global_deinit ();

  return 0;
}
</pre>

<div class="node">
<a name="Simple-client-example-with-SRP-authentication"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Simple-client-example-in-C_002b_002b">Simple client example in C++</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Client-with-Resume-capability-example">Client with Resume capability example</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Client-examples">Client examples</a>

</div>

<h4 class="subsection">8.1.9 Simple client example with <acronym>SRP</acronym> authentication</h4>

<p>The following client is a very simple <acronym>SRP</acronym> <acronym>TLS</acronym>
client which connects to a server and authenticates using a
<em>username</em> and a <em>password</em>. The server may authenticate
itself using a certificate, and in that case it has to be verified.

<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h>
#endif

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#include &lt;gnutls/gnutls.h>

/* Those functions are defined in other examples.
 */
extern void check_alert (gnutls_session_t session, int ret);
extern int tcp_connect (void);
extern void tcp_close (int sd);

#define MAX_BUF 1024
#define USERNAME "user"
#define PASSWORD "pass"
#define CAFILE "ca.pem"
#define MSG "GET / HTTP/1.0\r\n\r\n"

int
main (void)
{
  int ret;
  int sd, ii;
  gnutls_session_t session;
  char buffer[MAX_BUF + 1];
  gnutls_srp_client_credentials_t srp_cred;
  gnutls_certificate_credentials_t cert_cred;

  gnutls_global_init ();

  gnutls_srp_allocate_client_credentials (&amp;srp_cred);
  gnutls_certificate_allocate_credentials (&amp;cert_cred);

  gnutls_certificate_set_x509_trust_file (cert_cred, CAFILE,
                                          GNUTLS_X509_FMT_PEM);
  gnutls_srp_set_client_credentials (srp_cred, USERNAME, PASSWORD);

  /* connects to server
   */
  sd = tcp_connect ();

  /* Initialize TLS session
   */
  gnutls_init (&amp;session, GNUTLS_CLIENT);


  /* Set the priorities.
   */
  gnutls_priority_set_direct (session, "NORMAL:+SRP:+SRP-RSA:+SRP-DSS", NULL);

  /* put the SRP credentials to the current session
   */
  gnutls_credentials_set (session, GNUTLS_CRD_SRP, srp_cred);
  gnutls_credentials_set (session, GNUTLS_CRD_CERTIFICATE, cert_cred);

  gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) sd);

  /* Perform the TLS handshake
   */
  ret = gnutls_handshake (session);

  if (ret &lt; 0)
    {
      fprintf (stderr, "*** Handshake failed\n");
      gnutls_perror (ret);
      goto end;
    }
  else
    {
      printf ("- Handshake was completed\n");
    }

  gnutls_record_send (session, MSG, strlen (MSG));

  ret = gnutls_record_recv (session, buffer, MAX_BUF);
  if (gnutls_error_is_fatal (ret) == 1 || ret == 0)
    {
      if (ret == 0)
        {
          printf ("- Peer has closed the GnuTLS connection\n");
          goto end;
        }
      else
        {
          fprintf (stderr, "*** Error: %s\n", gnutls_strerror (ret));
          goto end;
        }
    }
  else
    check_alert (session, ret);

  if (ret > 0)
    {
      printf ("- Received %d bytes: ", ret);
      for (ii = 0; ii &lt; ret; ii++)
        {
          fputc (buffer[ii], stdout);
        }
      fputs ("\n", stdout);
    }
  gnutls_bye (session, GNUTLS_SHUT_RDWR);

end:

  tcp_close (sd);

  gnutls_deinit (session);

  gnutls_srp_free_client_credentials (srp_cred);
  gnutls_certificate_free_credentials (cert_cred);

  gnutls_global_deinit ();

  return 0;
}
</pre>
<div class="node">
<a name="Simple-client-example-in-C++"></a>
<a name="Simple-client-example-in-C_002b_002b"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Helper-function-for-TCP-connections">Helper function for TCP connections</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Simple-client-example-with-SRP-authentication">Simple client example with SRP authentication</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Client-examples">Client examples</a>

</div>

<h4 class="subsection">8.1.10 Simple client example using the C++ API</h4>

<p>The following client is a simple example of a client client utilizing
the GnuTLS C++ API.

<pre class="verbatim">#include &lt;config.h>
#include &lt;iostream>
#include &lt;stdexcept>
#include &lt;gnutls/gnutls.h>
#include &lt;gnutls/gnutlsxx.h>
#include &lt;cstring> /* for strlen */

/* A very basic TLS client, with anonymous authentication.
 * written by Eduardo Villanueva Che.
 */

#define MAX_BUF 1024
#define SA struct sockaddr

#define CAFILE "ca.pem"
#define MSG "GET / HTTP/1.0\r\n\r\n"

extern "C"
{
    int tcp_connect(void);
    void tcp_close(int sd);
}


int main(void)
{
    int sd = -1;
    gnutls_global_init();

    try
    {

        /* Allow connections to servers that have OpenPGP keys as well.
         */
        gnutls::client_session session;

        /* X509 stuff */
        gnutls::certificate_credentials credentials;


        /* sets the trusted cas file
         */
        credentials.set_x509_trust_file(CAFILE, GNUTLS_X509_FMT_PEM);
        /* put the x509 credentials to the current session
         */
        session.set_credentials(credentials);

        /* Use default priorities */
        session.set_priority ("NORMAL", NULL);

        /* connect to the peer
         */
        sd = tcp_connect();
        session.set_transport_ptr((gnutls_transport_ptr_t) sd);

        /* Perform the TLS handshake
         */
        int ret = session.handshake();
        if (ret &lt; 0)
        {
            throw std::runtime_error("Handshake failed");
        }
        else
        {
            std::cout &lt;&lt; "- Handshake was completed" &lt;&lt; std::endl;
        }

        session.send(MSG, strlen(MSG));
        char buffer[MAX_BUF + 1];
        ret = session.recv(buffer, MAX_BUF);
        if (ret == 0)
        {
            throw std::runtime_error("Peer has closed the TLS connection");
        }
        else if (ret &lt; 0)
        {
            throw std::runtime_error(gnutls_strerror(ret));
        }

        std::cout &lt;&lt; "- Received " &lt;&lt; ret &lt;&lt; " bytes:" &lt;&lt; std::endl;
        std::cout.write(buffer, ret);
        std::cout &lt;&lt; std::endl;

        session.bye(GNUTLS_SHUT_RDWR);
    }
    catch (std::exception &amp;ex)
    {
        std::cerr &lt;&lt; "Exception caught: " &lt;&lt; ex.what() &lt;&lt; std::endl;
    }

    if (sd != -1)
        tcp_close(sd);

    gnutls_global_deinit();

    return 0;
}
</pre>
<div class="node">
<a name="Helper-function-for-TCP-connections"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Simple-client-example-in-C_002b_002b">Simple client example in C++</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Client-examples">Client examples</a>

</div>

<h4 class="subsection">8.1.11 Helper function for TCP connections</h4>

<p>This helper function abstracts away TCP connection handling from the
other examples.  It is required to build some examples.

<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h>
#endif

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#include &lt;sys/types.h>
#include &lt;sys/socket.h>
#include &lt;arpa/inet.h>
#include &lt;netinet/in.h>
#include &lt;unistd.h>

#define SA struct sockaddr

/* tcp.c */
int tcp_connect (void);
void tcp_close (int sd);

/* Connects to the peer and returns a socket
 * descriptor.
 */
extern int
tcp_connect (void)
{
  const char *PORT = "5556";
  const char *SERVER = "127.0.0.1";
  int err, sd;
  struct sockaddr_in sa;

  /* connects to server
   */
  sd = socket (AF_INET, SOCK_STREAM, 0);

  memset (&amp;sa, '\0', sizeof (sa));
  sa.sin_family = AF_INET;
  sa.sin_port = htons (atoi (PORT));
  inet_pton (AF_INET, SERVER, &amp;sa.sin_addr);

  err = connect (sd, (SA *) &amp; sa, sizeof (sa));
  if (err &lt; 0)
    {
      fprintf (stderr, "Connect error\n");
      exit (1);
    }

  return sd;
}

/* closes the given socket descriptor.
 */
extern void
tcp_close (int sd)
{
  shutdown (sd, SHUT_RDWR);     /* no more receptions */
  close (sd);
}
</pre>
<div class="node">
<a name="Server-examples"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Miscellaneous-examples">Miscellaneous examples</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Client-examples">Client examples</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#GnuTLS-application-examples">GnuTLS application examples</a>

</div>

<h3 class="section">8.2 Server examples</h3>

<p>This section contains examples of <acronym>TLS</acronym> and <acronym>SSL</acronym>
servers, using <acronym>GnuTLS</acronym>.

<ul class="menu">
<li><a accesskey="1" href="#Echo-Server-with-X_002e509-authentication">Echo Server with X.509 authentication</a>
<li><a accesskey="2" href="#Echo-Server-with-OpenPGP-authentication">Echo Server with OpenPGP authentication</a>
<li><a accesskey="3" href="#Echo-Server-with-SRP-authentication">Echo Server with SRP authentication</a>
<li><a accesskey="4" href="#Echo-Server-with-anonymous-authentication">Echo Server with anonymous authentication</a>
</ul>

<div class="node">
<a name="Echo-Server-with-X.509-authentication"></a>
<a name="Echo-Server-with-X_002e509-authentication"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Echo-Server-with-OpenPGP-authentication">Echo Server with OpenPGP authentication</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Server-examples">Server examples</a>

</div>

<h4 class="subsection">8.2.1 Echo server with <acronym>X.509</acronym> authentication</h4>

<p>This example is a very simple echo server which supports
<acronym>X.509</acronym> authentication, using the RSA ciphersuites.

<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h>
#endif

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;errno.h>
#include &lt;sys/types.h>
#include &lt;sys/socket.h>
#include &lt;arpa/inet.h>
#include &lt;netinet/in.h>
#include &lt;string.h>
#include &lt;unistd.h>
#include &lt;gnutls/gnutls.h>

#define KEYFILE "key.pem"
#define CERTFILE "cert.pem"
#define CAFILE "ca.pem"
#define CRLFILE "crl.pem"

/* This is a sample TLS 1.0 echo server, using X.509 authentication.
 */


#define SA struct sockaddr
#define SOCKET_ERR(err,s) if(err==-1) {perror(s);return(1);}
#define MAX_BUF 1024
#define PORT 5556               /* listen to 5556 port */
#define DH_BITS 1024

/* These are global */
gnutls_certificate_credentials_t x509_cred;
gnutls_priority_t priority_cache;

static gnutls_session_t
initialize_tls_session (void)
{
  gnutls_session_t session;

  gnutls_init (&amp;session, GNUTLS_SERVER);

  gnutls_priority_set (session, priority_cache);

  gnutls_credentials_set (session, GNUTLS_CRD_CERTIFICATE, x509_cred);

  /* request client certificate if any.
   */
  gnutls_certificate_server_set_request (session, GNUTLS_CERT_REQUEST);

  /* Set maximum compatibility mode. This is only suggested on public webservers
   * that need to trade security for compatibility
   */
  gnutls_session_enable_compatibility_mode (session);

  return session;
}

static gnutls_dh_params_t dh_params;

static int
generate_dh_params (void)
{

  /* Generate Diffie-Hellman parameters - for use with DHE
   * kx algorithms. When short bit length is used, it might
   * be wise to regenerate parameters.
   *
   * Check the ex-serv-export.c example for using static
   * parameters.
   */
  gnutls_dh_params_init (&amp;dh_params);
  gnutls_dh_params_generate2 (dh_params, DH_BITS);

  return 0;
}

int
main (void)
{
  int err, listen_sd;
  int sd, ret;
  struct sockaddr_in sa_serv;
  struct sockaddr_in sa_cli;
  int client_len;
  char topbuf[512];
  gnutls_session_t session;
  char buffer[MAX_BUF + 1];
  int optval = 1;

  /* this must be called once in the program
   */
  gnutls_global_init ();

  gnutls_certificate_allocate_credentials (&amp;x509_cred);
  gnutls_certificate_set_x509_trust_file (x509_cred, CAFILE,
                                          GNUTLS_X509_FMT_PEM);

  gnutls_certificate_set_x509_crl_file (x509_cred, CRLFILE,
                                        GNUTLS_X509_FMT_PEM);

  gnutls_certificate_set_x509_key_file (x509_cred, CERTFILE, KEYFILE,
                                        GNUTLS_X509_FMT_PEM);

  generate_dh_params ();

  gnutls_priority_init (&amp;priority_cache, "NORMAL", NULL);


  gnutls_certificate_set_dh_params (x509_cred, dh_params);

  /* Socket operations
   */
  listen_sd = socket (AF_INET, SOCK_STREAM, 0);
  SOCKET_ERR (listen_sd, "socket");

  memset (&amp;sa_serv, '\0', sizeof (sa_serv));
  sa_serv.sin_family = AF_INET;
  sa_serv.sin_addr.s_addr = INADDR_ANY;
  sa_serv.sin_port = htons (PORT);      /* Server Port number */

  setsockopt (listen_sd, SOL_SOCKET, SO_REUSEADDR, (void *) &amp;optval,
              sizeof (int));

  err = bind (listen_sd, (SA *) &amp; sa_serv, sizeof (sa_serv));
  SOCKET_ERR (err, "bind");
  err = listen (listen_sd, 1024);
  SOCKET_ERR (err, "listen");

  printf ("Server ready. Listening to port '%d'.\n\n", PORT);

  client_len = sizeof (sa_cli);
  for (;;)
    {
      session = initialize_tls_session ();

      sd = accept (listen_sd, (SA *) &amp; sa_cli, &amp;client_len);

      printf ("- connection from %s, port %d\n",
              inet_ntop (AF_INET, &amp;sa_cli.sin_addr, topbuf,
                         sizeof (topbuf)), ntohs (sa_cli.sin_port));

      gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) sd);
      ret = gnutls_handshake (session);
      if (ret &lt; 0)
        {
          close (sd);
          gnutls_deinit (session);
          fprintf (stderr, "*** Handshake has failed (%s)\n\n",
                   gnutls_strerror (ret));
          continue;
        }
      printf ("- Handshake was completed\n");

      /* see the Getting peer's information example */
      /* print_info(session); */

      for (;;)
        {
          memset (buffer, 0, MAX_BUF + 1);
          ret = gnutls_record_recv (session, buffer, MAX_BUF);

          if (ret == 0)
            {
              printf ("\n- Peer has closed the GnuTLS connection\n");
              break;
            }
          else if (ret &lt; 0)
            {
              fprintf (stderr, "\n*** Received corrupted "
                       "data(%d). Closing the connection.\n\n", ret);
              break;
            }
          else if (ret > 0)
            {
              /* echo data back to the client
               */
              gnutls_record_send (session, buffer, strlen (buffer));
            }
        }
      printf ("\n");
      /* do not wait for the peer to close the connection.
       */
      gnutls_bye (session, GNUTLS_SHUT_WR);

      close (sd);
      gnutls_deinit (session);

    }
  close (listen_sd);

  gnutls_certificate_free_credentials (x509_cred);
  gnutls_priority_deinit (priority_cache);

  gnutls_global_deinit ();

  return 0;

}
</pre>
<div class="node">
<a name="Echo-Server-with-OpenPGP-authentication"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Echo-Server-with-SRP-authentication">Echo Server with SRP authentication</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Echo-Server-with-X_002e509-authentication">Echo Server with X.509 authentication</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Server-examples">Server examples</a>

</div>

<h4 class="subsection">8.2.2 Echo server with <acronym>OpenPGP</acronym> authentication</h4>

<p><a name="index-OpenPGP-server-72"></a>
The following example is an echo server which supports
<acronym>OpenPGP</acronym> key authentication. You can easily combine
this functionality &mdash;that is have a server that supports both
<acronym>X.509</acronym> and <acronym>OpenPGP</acronym> certificates&mdash; but we separated
them to keep these examples as simple as possible.

<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h>
#endif

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;errno.h>
#include &lt;sys/types.h>
#include &lt;sys/socket.h>
#include &lt;arpa/inet.h>
#include &lt;netinet/in.h>
#include &lt;string.h>
#include &lt;unistd.h>
#include &lt;gnutls/gnutls.h>
#include &lt;gnutls/openpgp.h>

#define KEYFILE "secret.asc"
#define CERTFILE "public.asc"
#define RINGFILE "ring.gpg"

/* This is a sample TLS 1.0-OpenPGP echo server.
 */


#define SA struct sockaddr
#define SOCKET_ERR(err,s) if(err==-1) {perror(s);return(1);}
#define MAX_BUF 1024
#define PORT 5556               /* listen to 5556 port */
#define DH_BITS 1024

/* These are global */
gnutls_certificate_credentials_t cred;
gnutls_dh_params_t dh_params;

static int
generate_dh_params (void)
{

  /* Generate Diffie-Hellman parameters - for use with DHE
   * kx algorithms. These should be discarded and regenerated
   * once a day, once a week or once a month. Depending on the
   * security requirements.
   */
  gnutls_dh_params_init (&amp;dh_params);
  gnutls_dh_params_generate2 (dh_params, DH_BITS);

  return 0;
}

static gnutls_session_t
initialize_tls_session (void)
{
  gnutls_session_t session;

  gnutls_init (&amp;session, GNUTLS_SERVER);

  gnutls_priority_set_direct (session, "NORMAL:+CTYPE-OPENPGP", NULL);

  /* request client certificate if any.
   */
  gnutls_certificate_server_set_request (session, GNUTLS_CERT_REQUEST);

  gnutls_dh_set_prime_bits (session, DH_BITS);

  return session;
}

int
main (void)
{
  int err, listen_sd;
  int sd, ret;
  struct sockaddr_in sa_serv;
  struct sockaddr_in sa_cli;
  int client_len;
  char topbuf[512];
  gnutls_session_t session;
  char buffer[MAX_BUF + 1];
  int optval = 1;
  char name[256];

  strcpy (name, "Echo Server");

  /* this must be called once in the program
   */
  gnutls_global_init ();

  gnutls_certificate_allocate_credentials (&amp;cred);
  gnutls_certificate_set_openpgp_keyring_file (cred, RINGFILE,
                                               GNUTLS_OPENPGP_FMT_BASE64);

  gnutls_certificate_set_openpgp_key_file (cred, CERTFILE, KEYFILE,
                                           GNUTLS_OPENPGP_FMT_BASE64);

  generate_dh_params ();

  gnutls_certificate_set_dh_params (cred, dh_params);

  /* Socket operations
   */
  listen_sd = socket (AF_INET, SOCK_STREAM, 0);
  SOCKET_ERR (listen_sd, "socket");

  memset (&amp;sa_serv, '\0', sizeof (sa_serv));
  sa_serv.sin_family = AF_INET;
  sa_serv.sin_addr.s_addr = INADDR_ANY;
  sa_serv.sin_port = htons (PORT);      /* Server Port number */

  setsockopt (listen_sd, SOL_SOCKET, SO_REUSEADDR, (void *) &amp;optval,
              sizeof (int));

  err = bind (listen_sd, (SA *) &amp; sa_serv, sizeof (sa_serv));
  SOCKET_ERR (err, "bind");
  err = listen (listen_sd, 1024);
  SOCKET_ERR (err, "listen");

  printf ("%s ready. Listening to port '%d'.\n\n", name, PORT);

  client_len = sizeof (sa_cli);
  for (;;)
    {
      session = initialize_tls_session ();

      sd = accept (listen_sd, (SA *) &amp; sa_cli, &amp;client_len);

      printf ("- connection from %s, port %d\n",
              inet_ntop (AF_INET, &amp;sa_cli.sin_addr, topbuf,
                         sizeof (topbuf)), ntohs (sa_cli.sin_port));

      gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) sd);
      ret = gnutls_handshake (session);
      if (ret &lt; 0)
        {
          close (sd);
          gnutls_deinit (session);
          fprintf (stderr, "*** Handshake has failed (%s)\n\n",
                   gnutls_strerror (ret));
          continue;
        }
      printf ("- Handshake was completed\n");

      /* see the Getting peer's information example */
      /* print_info(session); */

      for (;;)
        {
          memset (buffer, 0, MAX_BUF + 1);
          ret = gnutls_record_recv (session, buffer, MAX_BUF);

          if (ret == 0)
            {
              printf ("\n- Peer has closed the GnuTLS connection\n");
              break;
            }
          else if (ret &lt; 0)
            {
              fprintf (stderr, "\n*** Received corrupted "
                       "data(%d). Closing the connection.\n\n", ret);
              break;
            }
          else if (ret > 0)
            {
              /* echo data back to the client
               */
              gnutls_record_send (session, buffer, strlen (buffer));
            }
        }
      printf ("\n");
      /* do not wait for the peer to close the connection.
       */
      gnutls_bye (session, GNUTLS_SHUT_WR);

      close (sd);
      gnutls_deinit (session);

    }
  close (listen_sd);

  gnutls_certificate_free_credentials (cred);

  gnutls_global_deinit ();

  return 0;

}
</pre>
<div class="node">
<a name="Echo-Server-with-SRP-authentication"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Echo-Server-with-anonymous-authentication">Echo Server with anonymous authentication</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Echo-Server-with-OpenPGP-authentication">Echo Server with OpenPGP authentication</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Server-examples">Server examples</a>

</div>

<h4 class="subsection">8.2.3 Echo server with <acronym>SRP</acronym> authentication</h4>

<p>This is a server which supports <acronym>SRP</acronym> authentication. It is
also possible to combine this functionality with a certificate
server. Here it is separate for simplicity.

<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h>
#endif

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;errno.h>
#include &lt;sys/types.h>
#include &lt;sys/socket.h>
#include &lt;arpa/inet.h>
#include &lt;netinet/in.h>
#include &lt;string.h>
#include &lt;unistd.h>
#include &lt;gnutls/gnutls.h>

#define SRP_PASSWD "tpasswd"
#define SRP_PASSWD_CONF "tpasswd.conf"

#define KEYFILE "key.pem"
#define CERTFILE "cert.pem"
#define CAFILE "ca.pem"

/* This is a sample TLS-SRP echo server.
 */

#define SA struct sockaddr
#define SOCKET_ERR(err,s) if(err==-1) {perror(s);return(1);}
#define MAX_BUF 1024
#define PORT 5556               /* listen to 5556 port */

/* These are global */
gnutls_srp_server_credentials_t srp_cred;
gnutls_certificate_credentials_t cert_cred;

static gnutls_session_t
initialize_tls_session (void)
{
  gnutls_session_t session;

  gnutls_init (&amp;session, GNUTLS_SERVER);

  gnutls_priority_set_direct (session, "NORMAL:-KX-ALL:+SRP:+SRP-DSS:+SRP-RSA", NULL);

  gnutls_credentials_set (session, GNUTLS_CRD_SRP, srp_cred);
  /* for the certificate authenticated ciphersuites.
   */
  gnutls_credentials_set (session, GNUTLS_CRD_CERTIFICATE, cert_cred);

  /* request client certificate if any.
   */
  gnutls_certificate_server_set_request (session, GNUTLS_CERT_IGNORE);

  return session;
}

int
main (void)
{
  int err, listen_sd;
  int sd, ret;
  struct sockaddr_in sa_serv;
  struct sockaddr_in sa_cli;
  int client_len;
  char topbuf[512];
  gnutls_session_t session;
  char buffer[MAX_BUF + 1];
  int optval = 1;
  char name[256];

  strcpy (name, "Echo Server");

  gnutls_global_init ();

  /* SRP_PASSWD a password file (created with the included srptool utility) 
   */
  gnutls_srp_allocate_server_credentials (&amp;srp_cred);
  gnutls_srp_set_server_credentials_file (srp_cred, SRP_PASSWD,
                                          SRP_PASSWD_CONF);

  gnutls_certificate_allocate_credentials (&amp;cert_cred);
  gnutls_certificate_set_x509_trust_file (cert_cred, CAFILE,
                                          GNUTLS_X509_FMT_PEM);
  gnutls_certificate_set_x509_key_file (cert_cred, CERTFILE, KEYFILE,
                                        GNUTLS_X509_FMT_PEM);

  /* TCP socket operations
   */
  listen_sd = socket (AF_INET, SOCK_STREAM, 0);
  SOCKET_ERR (listen_sd, "socket");

  memset (&amp;sa_serv, '\0', sizeof (sa_serv));
  sa_serv.sin_family = AF_INET;
  sa_serv.sin_addr.s_addr = INADDR_ANY;
  sa_serv.sin_port = htons (PORT);      /* Server Port number */

  setsockopt (listen_sd, SOL_SOCKET, SO_REUSEADDR, (void *) &amp;optval,
              sizeof (int));

  err = bind (listen_sd, (SA *) &amp; sa_serv, sizeof (sa_serv));
  SOCKET_ERR (err, "bind");
  err = listen (listen_sd, 1024);
  SOCKET_ERR (err, "listen");

  printf ("%s ready. Listening to port '%d'.\n\n", name, PORT);

  client_len = sizeof (sa_cli);
  for (;;)
    {
      session = initialize_tls_session ();

      sd = accept (listen_sd, (SA *) &amp; sa_cli, &amp;client_len);

      printf ("- connection from %s, port %d\n",
              inet_ntop (AF_INET, &amp;sa_cli.sin_addr, topbuf,
                         sizeof (topbuf)), ntohs (sa_cli.sin_port));

      gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) sd);
      ret = gnutls_handshake (session);
      if (ret &lt; 0)
        {
          close (sd);
          gnutls_deinit (session);
          fprintf (stderr, "*** Handshake has failed (%s)\n\n",
                   gnutls_strerror (ret));
          continue;
        }
      printf ("- Handshake was completed\n");
      printf ("- User %s was connected\n", gnutls_srp_server_get_username(session));

      /* print_info(session); */

      for (;;)
        {
          memset (buffer, 0, MAX_BUF + 1);
          ret = gnutls_record_recv (session, buffer, MAX_BUF);

          if (ret == 0)
            {
              printf ("\n- Peer has closed the GnuTLS connection\n");
              break;
            }
          else if (ret &lt; 0)
            {
              fprintf (stderr, "\n*** Received corrupted "
                       "data(%d). Closing the connection.\n\n", ret);
              break;
            }
          else if (ret > 0)
            {
              /* echo data back to the client
               */
              gnutls_record_send (session, buffer, strlen (buffer));
            }
        }
      printf ("\n");
      /* do not wait for the peer to close the connection. */
      gnutls_bye (session, GNUTLS_SHUT_WR);

      close (sd);
      gnutls_deinit (session);

    }
  close (listen_sd);

  gnutls_srp_free_server_credentials (srp_cred);
  gnutls_certificate_free_credentials (cert_cred);

  gnutls_global_deinit ();

  return 0;

}
</pre>
<div class="node">
<a name="Echo-Server-with-anonymous-authentication"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Echo-Server-with-SRP-authentication">Echo Server with SRP authentication</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Server-examples">Server examples</a>

</div>

<h4 class="subsection">8.2.4 Echo Server with anonymous authentication</h4>

<p>This example server support anonymous authentication, and could be
used to serve the example client for anonymous authentication.

<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h>
#endif

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;errno.h>
#include &lt;sys/types.h>
#include &lt;sys/socket.h>
#include &lt;arpa/inet.h>
#include &lt;netinet/in.h>
#include &lt;string.h>
#include &lt;unistd.h>
#include &lt;gnutls/gnutls.h>

/* This is a sample TLS 1.0 echo server, for anonymous authentication only.
 */


#define SA struct sockaddr
#define SOCKET_ERR(err,s) if(err==-1) {perror(s);return(1);}
#define MAX_BUF 1024
#define PORT 5556               /* listen to 5556 port */
#define DH_BITS 1024

/* These are global */
gnutls_anon_server_credentials_t anoncred;

static gnutls_session_t
initialize_tls_session (void)
{
  gnutls_session_t session;

  gnutls_init (&amp;session, GNUTLS_SERVER);

  gnutls_priority_set_direct (session, "NORMAL:+ANON-ECDH:+ANON-DH", NULL);

  gnutls_credentials_set (session, GNUTLS_CRD_ANON, anoncred);

  gnutls_dh_set_prime_bits (session, DH_BITS);

  return session;
}

static gnutls_dh_params_t dh_params;

static int
generate_dh_params (void)
{

  /* Generate Diffie-Hellman parameters - for use with DHE
   * kx algorithms. These should be discarded and regenerated
   * once a day, once a week or once a month. Depending on the
   * security requirements.
   */
  gnutls_dh_params_init (&amp;dh_params);
  gnutls_dh_params_generate2 (dh_params, DH_BITS);

  return 0;
}

int
main (void)
{
  int err, listen_sd;
  int sd, ret;
  struct sockaddr_in sa_serv;
  struct sockaddr_in sa_cli;
  int client_len;
  char topbuf[512];
  gnutls_session_t session;
  char buffer[MAX_BUF + 1];
  int optval = 1;

  /* this must be called once in the program
   */
  gnutls_global_init ();

  gnutls_anon_allocate_server_credentials (&amp;anoncred);

  generate_dh_params ();

  gnutls_anon_set_server_dh_params (anoncred, dh_params);

  /* Socket operations
   */
  listen_sd = socket (AF_INET, SOCK_STREAM, 0);
  SOCKET_ERR (listen_sd, "socket");

  memset (&amp;sa_serv, '\0', sizeof (sa_serv));
  sa_serv.sin_family = AF_INET;
  sa_serv.sin_addr.s_addr = INADDR_ANY;
  sa_serv.sin_port = htons (PORT);      /* Server Port number */

  setsockopt (listen_sd, SOL_SOCKET, SO_REUSEADDR, (void *) &amp;optval,
              sizeof (int));

  err = bind (listen_sd, (SA *) &amp; sa_serv, sizeof (sa_serv));
  SOCKET_ERR (err, "bind");
  err = listen (listen_sd, 1024);
  SOCKET_ERR (err, "listen");

  printf ("Server ready. Listening to port '%d'.\n\n", PORT);

  client_len = sizeof (sa_cli);
  for (;;)
    {
      session = initialize_tls_session ();

      sd = accept (listen_sd, (SA *) &amp; sa_cli, &amp;client_len);

      printf ("- connection from %s, port %d\n",
              inet_ntop (AF_INET, &amp;sa_cli.sin_addr, topbuf,
                         sizeof (topbuf)), ntohs (sa_cli.sin_port));

      gnutls_transport_set_ptr (session, (gnutls_transport_ptr_t) sd);
      ret = gnutls_handshake (session);
      if (ret &lt; 0)
        {
          close (sd);
          gnutls_deinit (session);
          fprintf (stderr, "*** Handshake has failed (%s)\n\n",
                   gnutls_strerror (ret));
          continue;
        }
      printf ("- Handshake was completed\n");

      /* see the Getting peer's information example */
      /* print_info(session); */

      for (;;)
        {
          memset (buffer, 0, MAX_BUF + 1);
          ret = gnutls_record_recv (session, buffer, MAX_BUF);

          if (ret == 0)
            {
              printf ("\n- Peer has closed the GnuTLS connection\n");
              break;
            }
          else if (ret &lt; 0)
            {
              fprintf (stderr, "\n*** Received corrupted "
                       "data(%d). Closing the connection.\n\n", ret);
              break;
            }
          else if (ret > 0)
            {
              /* echo data back to the client
               */
              gnutls_record_send (session, buffer, strlen (buffer));
            }
        }
      printf ("\n");
      /* do not wait for the peer to close the connection.
       */
      gnutls_bye (session, GNUTLS_SHUT_WR);

      close (sd);
      gnutls_deinit (session);

    }
  close (listen_sd);

  gnutls_anon_free_server_credentials (anoncred);

  gnutls_global_deinit ();

  return 0;

}
</pre>
<div class="node">
<a name="Miscellaneous-examples"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Server-examples">Server examples</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#GnuTLS-application-examples">GnuTLS application examples</a>

</div>

<h3 class="section">8.3 Miscellaneous examples</h3>

<ul class="menu">
<li><a accesskey="1" href="#Checking-for-an-alert">Checking for an alert</a>
<li><a accesskey="2" href="#X_002e509-certificate-parsing-example">X.509 certificate parsing example</a>
</ul>

<div class="node">
<a name="Checking-for-an-alert"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#X_002e509-certificate-parsing-example">X.509 certificate parsing example</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Miscellaneous-examples">Miscellaneous examples</a>

</div>

<h4 class="subsection">8.3.1 Checking for an alert</h4>

<p>This is a function that checks if an alert has been received in the
current session.

<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h>
#endif

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;gnutls/gnutls.h>

#include "examples.h"

/* This function will check whether the given return code from
 * a gnutls function (recv/send), is an alert, and will print
 * that alert.
 */
void
check_alert (gnutls_session_t session, int ret)
{
  int last_alert;

  if (ret == GNUTLS_E_WARNING_ALERT_RECEIVED
      || ret == GNUTLS_E_FATAL_ALERT_RECEIVED)
    {
      last_alert = gnutls_alert_get (session);

      /* The check for renegotiation is only useful if we are 
       * a server, and we had requested a rehandshake.
       */
      if (last_alert == GNUTLS_A_NO_RENEGOTIATION &amp;&amp;
          ret == GNUTLS_E_WARNING_ALERT_RECEIVED)
        printf ("* Received NO_RENEGOTIATION alert. "
                "Client Does not support renegotiation.\n");
      else
        printf ("* Received alert '%d': %s.\n", last_alert,
                gnutls_alert_get_name (last_alert));
    }
}
</pre>
<div class="node">
<a name="X.509-certificate-parsing-example"></a>
<a name="X_002e509-certificate-parsing-example"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Checking-for-an-alert">Checking for an alert</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Miscellaneous-examples">Miscellaneous examples</a>

</div>

<h4 class="subsection">8.3.2 <acronym>X.509</acronym> certificate parsing example</h4>

<p><a name="ex_003ax509_002dinfo"></a>To demonstrate the <acronym>X.509</acronym> parsing capabilities an example program is
listed below.  That program reads the peer's certificate, and prints
information about it.

<pre class="verbatim">/* This example code is placed in the public domain. */

#ifdef HAVE_CONFIG_H
#include &lt;config.h>
#endif

#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;gnutls/gnutls.h>
#include &lt;gnutls/x509.h>

#include "examples.h"

static const char *
bin2hex (const void *bin, size_t bin_size)
{
  static char printable[110];
  const unsigned char *_bin = bin;
  char *print;
  size_t i;

  if (bin_size > 50)
    bin_size = 50;

  print = printable;
  for (i = 0; i &lt; bin_size; i++)
    {
      sprintf (print, "%.2x ", _bin[i]);
      print += 2;
    }

  return printable;
}

/* This function will print information about this session's peer
 * certificate.
 */
void
print_x509_certificate_info (gnutls_session_t session)
{
  char serial[40];
  char dn[256];
  size_t size;
  unsigned int algo, bits;
  time_t expiration_time, activation_time;
  const gnutls_datum_t *cert_list;
  unsigned int cert_list_size = 0;
  gnutls_x509_crt_t cert;
  gnutls_datum_t cinfo;

  /* This function only works for X.509 certificates.
   */
  if (gnutls_certificate_type_get (session) != GNUTLS_CRT_X509)
    return;

  cert_list = gnutls_certificate_get_peers (session, &amp;cert_list_size);

  printf ("Peer provided %d certificates.\n", cert_list_size);

  if (cert_list_size > 0)
    {
      int ret;

      /* we only print information about the first certificate.
       */
      gnutls_x509_crt_init (&amp;cert);

      gnutls_x509_crt_import (cert, &amp;cert_list[0], GNUTLS_X509_FMT_DER);

      printf ("Certificate info:\n");

      /* This is the preferred way of printing short information about
         a certificate. */

      ret = gnutls_x509_crt_print (cert, GNUTLS_CRT_PRINT_ONELINE, &amp;cinfo);
      if (ret == 0)
        {
          printf ("\t%s\n", cinfo.data);
          gnutls_free (cinfo.data);
        }

      /* If you want to extract fields manually for some other reason,
         below are popular example calls. */

      expiration_time = gnutls_x509_crt_get_expiration_time (cert);
      activation_time = gnutls_x509_crt_get_activation_time (cert);

      printf ("\tCertificate is valid since: %s", ctime (&amp;activation_time));
      printf ("\tCertificate expires: %s", ctime (&amp;expiration_time));

      /* Print the serial number of the certificate.
       */
      size = sizeof (serial);
      gnutls_x509_crt_get_serial (cert, serial, &amp;size);

      printf ("\tCertificate serial number: %s\n", bin2hex (serial, size));

      /* Extract some of the public key algorithm's parameters
       */
      algo = gnutls_x509_crt_get_pk_algorithm (cert, &amp;bits);

      printf ("Certificate public key: %s",
              gnutls_pk_algorithm_get_name (algo));

      /* Print the version of the X.509
       * certificate.
       */
      printf ("\tCertificate version: #%d\n",
              gnutls_x509_crt_get_version (cert));

      size = sizeof (dn);
      gnutls_x509_crt_get_dn (cert, dn, &amp;size);
      printf ("\tDN: %s\n", dn);

      size = sizeof (dn);
      gnutls_x509_crt_get_issuer_dn (cert, dn, &amp;size);
      printf ("\tIssuer's DN: %s\n", dn);

      gnutls_x509_crt_deinit (cert);

    }
}
</pre>

<div class="node">
<a name="Other-included-programs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Internal-architecture-of-GnuTLS">Internal architecture of GnuTLS</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#GnuTLS-application-examples">GnuTLS application examples</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">9 Other included programs</h2>

<p>Included with <acronym>GnuTLS</acronym> are also a few command line tools that
let you use the library for common tasks without writing an
application.  The applications are discussed in this chapter.

<ul class="menu">
<li><a accesskey="1" href="#The-gnutls_002dcli-tool">The gnutls-cli tool</a>
<li><a accesskey="2" href="#The-gnutls_002dserv-tool">The gnutls-serv tool</a>
<li><a accesskey="3" href="#The-gnutls_002dcli_002ddebug-tool">The gnutls-cli-debug tool</a>
</ul>

<div class="node">
<a name="The-gnutls-cli-tool"></a>
<a name="The-gnutls_002dcli-tool"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-gnutls_002dserv-tool">The gnutls-serv tool</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Other-included-programs">Other included programs</a>

</div>

<h3 class="section">9.1 The gnutls-cli tool</h3>

<p><a name="index-gnutls_002dcli-73"></a>
Simple client program to set up a TLS connection to some other
computer.  It sets up a TLS connection and forwards data from the
standard input to the secured socket and vice versa.

<pre class="example">     GnuTLS test client
     Usage:  gnutls-cli [options] hostname
     
          -d, --debug integer      Enable debugging
          -r, --resume             Connect, establish a session. Connect
                                   again and resume this session.
          -s, --starttls           Connect, establish a plain session and
                                   start TLS when EOF or a SIGALRM is
                                   received.
          --crlf                   Send CR LF instead of LF.
          --x509fmtder             Use DER format for certificates to read
                                   from.
          -f, --fingerprint        Send the openpgp fingerprint, instead
                                   of the key.
          --disable-extensions     Disable all the TLS extensions.
          --print-cert             Print the certificate in PEM format.
          --recordsize integer     The maximum record size to advertize.
          -V, --verbose            More verbose output.
          --ciphers cipher1 cipher2...
                                   Ciphers to enable.
          --protocols protocol1 protocol2...
                                   Protocols to enable.
          --comp comp1 comp2...    Compression methods to enable.
          --macs mac1 mac2...      MACs to enable.
          --kx kx1 kx2...          Key exchange methods to enable.
          --ctypes certType1 certType2...
                                   Certificate types to enable.
          --priority PRIORITY STRING
                                   Priorities string.
          --x509cafile FILE        Certificate file to use.
          --x509crlfile FILE       CRL file to use.
          --pgpkeyfile FILE        PGP Key file to use.
          --pgpkeyring FILE        PGP Key ring file to use.
          --pgpcertfile FILE       PGP Public Key (certificate) file to
                                   use.
          --pgpsubkey HEX|auto     PGP subkey to use.
          --x509keyfile FILE       X.509 key file to use.
          --x509certfile FILE      X.509 Certificate file to use.
          --srpusername NAME       SRP username to use.
          --srppasswd PASSWD       SRP password to use.
          --pskusername NAME       PSK username to use.
          --pskkey KEY             PSK key (in hex) to use.
          --opaque-prf-input DATA
                                   Use Opaque PRF Input DATA.
          -p, --port PORT          The port to connect to.
          --insecure               Don't abort program if server
                                   certificate can't be validated.
          -l, --list               Print a list of the supported
                                   algorithms and modes.
          -h, --help               prints this help
          -v, --version            prints the program's version number
</pre>
<ul class="menu">
<li><a accesskey="1" href="#Example-client-PSK-connection">Example client PSK connection</a>
</ul>

<div class="node">
<a name="Example-client-PSK-connection"></a>
<p><hr>
Up:&nbsp;<a rel="up" accesskey="u" href="#The-gnutls_002dcli-tool">The gnutls-cli tool</a>

</div>

<h4 class="subsection">9.1.1 Example client PSK connection</h4>

<p><a name="index-PSK-client-74"></a>
To connect to a server using PSK authentication, you need to enable
the choice of PSK by using a cipher priority parameter such as in the
example below.

<pre class="smallexample">     $ ./gnutls-cli -p 5556 localhost --pskusername psk_identity \
       --pskkey 88f3824b3e5659f52d00e959bacab954b6540344 \
       --priority NORMAL:-KX-ALL:+ECDHE-PSK:+DHE-PSK:+PSK
     Resolving 'localhost'...
     Connecting to '127.0.0.1:5556'...
     - PSK authentication.
     - Version: TLS1.1
     - Key Exchange: PSK
     - Cipher: AES-128-CBC
     - MAC: SHA1
     - Compression: NULL
     - Handshake was completed
     
     - Simple Client Mode:
</pre>
<p>By keeping the <code>--pskusername</code> parameter and removing the
<code>--pskkey</code> parameter, it will query only for the password during
the handshake.

<div class="node">
<a name="The-gnutls-serv-tool"></a>
<a name="The-gnutls_002dserv-tool"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-gnutls_002dcli_002ddebug-tool">The gnutls-cli-debug tool</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-gnutls_002dcli-tool">The gnutls-cli tool</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Other-included-programs">Other included programs</a>

</div>

<h3 class="section">9.2 The gnutls-serv tool</h3>

<p><a name="index-gnutls_002dserv-75"></a>
Simple server program that listens to incoming TLS connections.

<pre class="example">     GnuTLS test server
     Usage: gnutls-serv [options]
     
          -d, --debug integer      Enable debugging
          -g, --generate           Generate Diffie-Hellman Parameters.
          -p, --port integer       The port to connect to.
          -q, --quiet              Suppress some messages.
          --nodb                   Does not use the resume database.
          --http                   Act as an HTTP Server.
          --echo                   Act as an Echo Server.
          --dhparams FILE          DH params file to use.
          --x509fmtder             Use DER format for certificates
          --x509cafile FILE        Certificate file to use.
          --x509crlfile FILE       CRL file to use.
          --pgpkeyring FILE        PGP Key ring file to use.
          --pgpkeyfile FILE        PGP Key file to use.
          --pgpcertfile FILE       PGP Public Key (certificate) file to
                                   use.
          --pgpsubkey HEX|auto     PGP subkey to use.
          --x509keyfile FILE       X.509 key file to use.
          --x509certfile FILE      X.509 Certificate file to use.
          --x509dsakeyfile FILE    Alternative X.509 key file to use.
          --x509dsacertfile FILE   Alternative X.509 certificate file to
                                   use.
          -r, --require-cert       Require a valid certificate.
          -a, --disable-client-cert
                                   Disable request for a client
                                   certificate.
          --pskpasswd FILE         PSK password file to use.
          --pskhint HINT           PSK identity hint to use.
          --srppasswd FILE         SRP password file to use.
          --srppasswdconf FILE     SRP password conf file to use.
          --opaque-prf-input DATA
                                   Use Opaque PRF Input DATA.
          --ciphers cipher1 cipher2...
                                   Ciphers to enable.
          --protocols protocol1 protocol2...
                                   Protocols to enable.
          --comp comp1 comp2...    Compression methods to enable.
          --macs mac1 mac2...      MACs to enable.
          --kx kx1 kx2...          Key exchange methods to enable.
          --ctypes certType1 certType2...
                                   Certificate types to enable.
          --priority PRIORITY STRING
                                   Priorities string.
          -l, --list               Print a list of the supported
                                   algorithms  and modes.
          -h, --help               prints this help
          -v, --version            prints the program's version number
</pre>
<ul class="menu">
<li><a accesskey="1" href="#Setting-up-a-test-HTTPS-server">Setting up a test HTTPS server</a>
</ul>

<div class="node">
<a name="Setting-up-a-test-HTTPS-server"></a>
<p><hr>
Up:&nbsp;<a rel="up" accesskey="u" href="#The-gnutls_002dserv-tool">The gnutls-serv tool</a>

</div>

<h4 class="subsection">9.2.1 Setting up a test HTTPS server</h4>

<p><a name="index-HTTPS-server-76"></a><a name="index-debug-server-77"></a>
Running your own TLS server based on GnuTLS can be useful when
debugging clients and/or GnuTLS itself.  This section describes how to
use <code>gnutls-serv</code> as a simple HTTPS server.

<p>The most basic server can be started as:

<pre class="smallexample">     gnutls-serv --http
</pre>
<p>It will only support anonymous ciphersuites, which many TLS clients
refuse to use.

<p>The next step is to add support for X.509.  First we generate a CA:

<pre class="smallexample">     $ certtool --generate-privkey &gt; x509-ca-key.pem
     $ echo 'cn = GnuTLS test CA' &gt; ca.tmpl
     $ echo 'ca' &gt;&gt; ca.tmpl
     $ echo 'cert_signing_key' &gt;&gt; ca.tmpl
     $ certtool --generate-self-signed --load-privkey x509-ca-key.pem \
       --template ca.tmpl --outfile x509-ca.pem
     ...
</pre>
<p>Then generate a server certificate.  Remember to change the dns_name
value to the name of your server host, or skip that command to avoid
the field.

<pre class="example">     $ certtool --generate-privkey &gt; x509-server-key.pem
     $ echo 'organization = GnuTLS test server' &gt; server.tmpl
     $ echo 'cn = test.gnutls.org' &gt;&gt; server.tmpl
     $ echo 'tls_www_server' &gt;&gt; server.tmpl
     $ echo 'encryption_key' &gt;&gt; server.tmpl
     $ echo 'signing_key' &gt;&gt; server.tmpl
     $ echo 'dns_name = test.gnutls.org' &gt;&gt; server.tmpl
     $ certtool --generate-certificate --load-privkey x509-server-key.pem \
       --load-ca-certificate x509-ca.pem --load-ca-privkey x509-ca-key.pem \
       --template server.tmpl --outfile x509-server.pem
     ...
</pre>
<p>For use in the client, you may want to generate a client certificate
as well.

<pre class="example">     $ certtool --generate-privkey &gt; x509-client-key.pem
     $ echo 'cn = GnuTLS test client' &gt; client.tmpl
     $ echo 'tls_www_client' &gt;&gt; client.tmpl
     $ echo 'encryption_key' &gt;&gt; client.tmpl
     $ echo 'signing_key' &gt;&gt; client.tmpl
     $ certtool --generate-certificate --load-privkey x509-client-key.pem \
       --load-ca-certificate x509-ca.pem --load-ca-privkey x509-ca-key.pem \
       --template client.tmpl --outfile x509-client.pem
     ...
</pre>
<p>To be able to import the client key/certificate into some
applications, you will need to convert them into a PKCS#12 structure. 
This also encrypts the security sensitive key with a password.

<pre class="smallexample">     $ certtool --to-p12 --load-ca-certificate x509-ca.pem \
       --load-privkey x509-client-key.pem --load-certificate x509-client.pem \
       --outder --outfile x509-client.p12
</pre>
<p>For icing, we'll create a proxy certificate for the client too.

<pre class="smallexample">     $ certtool --generate-privkey &gt; x509-proxy-key.pem
     $ echo 'cn = GnuTLS test client proxy' &gt; proxy.tmpl
     $ certtool --generate-proxy --load-privkey x509-proxy-key.pem \
       --load-ca-certificate x509-client.pem --load-ca-privkey x509-client-key.pem \
       --load-certificate x509-client.pem --template proxy.tmpl \
       --outfile x509-proxy.pem
     ...
</pre>
<p>Then start the server again:

<pre class="smallexample">     $ gnutls-serv --http \
                 --x509cafile x509-ca.pem \
                 --x509keyfile x509-server-key.pem \
                 --x509certfile x509-server.pem
</pre>
<p>Try connecting to the server using your web browser.  Note that the
server listens to port 5556 by default.

<p>While you are at it, to allow connections using DSA, you can also
create a DSA key and certificate for the server.  These credentials
will be used in the final example below.

<pre class="smallexample">     $ certtool --generate-privkey --dsa &gt; x509-server-key-dsa.pem
     $ certtool --generate-certificate --load-privkey x509-server-key-dsa.pem \
       --load-ca-certificate x509-ca.pem --load-ca-privkey x509-ca-key.pem \
       --template server.tmpl --outfile x509-server-dsa.pem
     ...
</pre>
<p>The next step is to create OpenPGP credentials for the server.

<pre class="smallexample">     gpg --gen-key
     ...enter whatever details you want, use 'test.gnutls.org' as name...
</pre>
<p>Make a note of the OpenPGP key identifier of the newly generated key,
here it was <code>5D1D14D8</code>.  You will need to export the key for
GnuTLS to be able to use it.

<pre class="smallexample">     gpg -a --export 5D1D14D8 &gt; openpgp-server.txt
     gpg --export 5D1D14D8 &gt; openpgp-server.bin
     gpg --export-secret-keys 5D1D14D8 &gt; openpgp-server-key.bin
     gpg -a --export-secret-keys 5D1D14D8 &gt; openpgp-server-key.txt
</pre>
<p>Let's start the server with support for OpenPGP credentials:

<pre class="smallexample">     gnutls-serv --http \
                 --pgpkeyfile openpgp-server-key.txt \
                 --pgpcertfile openpgp-server.txt
</pre>
<p>The next step is to add support for SRP authentication. This requires
an SRP password file (see <a href="#Invoking-srptool">Invoking srptool</a>). 
To start the server with SRP support:

<pre class="smallexample">     gnutls-serv --http \
                 --srppasswdconf srp-tpasswd.conf \
                 --srppasswd srp-passwd.txt
</pre>
<p>Let's also start a server with support for PSK. This would require
a password file created with <code>psktool</code> (see <a href="#Invoking-psktool">Invoking psktool</a>).

<pre class="smallexample">     gnutls-serv --http \
                 --pskpasswd psk-passwd.txt
</pre>
<p>Finally, we start the server with all the earlier parameters and you
get this command:

<pre class="smallexample">     gnutls-serv --http \
                 --x509cafile x509-ca.pem \
                 --x509keyfile x509-server-key.pem \
                 --x509certfile x509-server.pem \
                 --x509dsakeyfile x509-server-key-dsa.pem \
                 --x509dsacertfile x509-server-dsa.pem \
                 --pgpkeyfile openpgp-server-key.txt \
                 --pgpcertfile openpgp-server.txt \
                 --srppasswdconf srp-tpasswd.conf \
                 --srppasswd srp-passwd.txt \
                 --pskpasswd psk-passwd.txt
</pre>
<div class="node">
<a name="The-gnutls-cli-debug-tool"></a>
<a name="The-gnutls_002dcli_002ddebug-tool"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-gnutls_002dserv-tool">The gnutls-serv tool</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Other-included-programs">Other included programs</a>

</div>

<h3 class="section">9.3 The gnutls-cli-debug tool</h3>

<p><a name="index-gnutls_002dcli_002ddebug-78"></a>
This program was created to assist in debugging <acronym>GnuTLS</acronym>, but
it might be useful to extract a <acronym>TLS</acronym> server's capabilities. 
It's purpose is to connect onto a <acronym>TLS</acronym> server, perform some
tests and print the server's capabilities. If called with the `-v'
parameter more checks will be performed. An example output is:

<pre class="example">     crystal:/cvs/gnutls/src$ ./gnutls-cli-debug localhost -p 5556
     Resolving 'localhost'...
     Connecting to '127.0.0.1:5556'...
     Checking for TLS 1.1 support... yes
     Checking fallback from TLS 1.1 to... N/A
     Checking for TLS 1.0 support... yes
     Checking for SSL 3.0 support... yes
     Checking for version rollback bug in RSA PMS... no
     Checking for version rollback bug in Client Hello... no
     Checking whether we need to disable TLS 1.0... N/A
     Checking whether the server ignores the RSA PMS version... no
     Checking whether the server can accept Hello Extensions... yes
     Checking whether the server can accept cipher suites not in SSL 3.0 spec... yes
     Checking for certificate information... N/A
     Checking for trusted CAs... N/A
     Checking whether the server understands TLS closure alerts... yes
     Checking whether the server supports session resumption... yes
     Checking for export-grade ciphersuite support... no
     Checking RSA-export ciphersuite info... N/A
     Checking for anonymous authentication support... no
     Checking anonymous Diffie-Hellman group info... N/A
     Checking for ephemeral Diffie-Hellman support... no
     Checking ephemeral Diffie-Hellman group info... N/A
     Checking for AES cipher support (TLS extension)... yes
     Checking for 3DES cipher support... yes
     Checking for ARCFOUR 128 cipher support... yes
     Checking for ARCFOUR 40 cipher support... no
     Checking for MD5 MAC support... yes
     Checking for SHA1 MAC support... yes
     Checking for ZLIB compression support (TLS extension)... yes
     Checking for max record size (TLS extension)... yes
     Checking for SRP authentication support (TLS extension)... yes
     Checking for OpenPGP authentication support (TLS extension)... no
</pre>
<div class="node">
<a name="Internal-architecture-of-GnuTLS"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Support">Support</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Other-included-programs">Other included programs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">10 Internal Architecture of GnuTLS</h2>

<p><a name="index-internal-architecture-79"></a>
This chapter is to give a brief description of the
way <acronym>GnuTLS</acronym> works. The focus is to give an idea
to potential developers and those who want to know what
happens inside the black box.

<ul class="menu">
<li><a accesskey="1" href="#The-TLS-Protocol">The TLS Protocol</a>
<li><a accesskey="2" href="#TLS-Handshake-Protocol">TLS Handshake Protocol</a>
<li><a accesskey="3" href="#TLS-Authentication-Methods">TLS Authentication Methods</a>
<li><a accesskey="4" href="#TLS-Extension-Handling">TLS Extension Handling</a>
<li><a accesskey="5" href="#Cryptographic-Backend">Cryptographic Backend</a>
</ul>

<div class="node">
<a name="The-TLS-Protocol"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#TLS-Handshake-Protocol">TLS Handshake Protocol</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Internal-architecture-of-GnuTLS">Internal architecture of GnuTLS</a>

</div>

<h3 class="section">10.1 The TLS Protocol</h3>

<p>The main use case for the TLS protocol is shown in <a href="#fig_003aclient_002dserver">fig:client-server</a>. 
A user of a library implementing the protocol expects no less than this functionality,
i.e., to be able to set parameters such as the accepted security level, perform a
negotiation with the peer and be able to exchange data.

<div class="float">
<a name="fig_003aclient_002dserver"></a><img src="gnutls-client-server-use-case.png" alt="gnutls-client-server-use-case.png">

<p><strong class="float-caption">Figure 10.1: TLS protocol use case.</strong></p></div>

<div class="node">
<a name="TLS-Handshake-Protocol"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#TLS-Authentication-Methods">TLS Authentication Methods</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-TLS-Protocol">The TLS Protocol</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Internal-architecture-of-GnuTLS">Internal architecture of GnuTLS</a>

</div>

<h3 class="section">10.2 TLS Handshake Protocol</h3>

<p>The <acronym>GnuTLS</acronym> handshake protocol is implemented as a state
machine that waits for input or returns immediately when the non-blocking
transport layer functions are used. The main idea is shown in <a href="#fig_003agnutls_002dhandshake">fig:gnutls-handshake</a>.

<div class="float">
<a name="fig_003agnutls_002dhandshake"></a><img src="gnutls-handshake-state.png" alt="gnutls-handshake-state.png">

<p><strong class="float-caption">Figure 10.2: GnuTLS handshake state machine.</strong></p></div>

<p>Also the way the input is processed varies per ciphersuite. Several
implementations of the internal handlers are available and
<a href="#gnutls_005fhandshake">gnutls_handshake</a> only multiplexes the input to the appropriate
handler. For example a <acronym>PSK</acronym> ciphersuite has a different
implementation of the <code>process_client_key_exchange</code> than a
certificate ciphersuite. We illustrate the idea in <a href="#fig_003agnutls_002dhandshake_002dsequence">fig:gnutls-handshake-sequence</a>.

<div class="float">
<a name="fig_003agnutls_002dhandshake_002dsequence"></a><img src="gnutls-handshake-sequence.png" alt="gnutls-handshake-sequence.png">

<p><strong class="float-caption">Figure 10.3: GnuTLS handshake process sequence.</strong></p></div>

<div class="node">
<a name="TLS-Authentication-Methods"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#TLS-Extension-Handling">TLS Extension Handling</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#TLS-Handshake-Protocol">TLS Handshake Protocol</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Internal-architecture-of-GnuTLS">Internal architecture of GnuTLS</a>

</div>

<h3 class="section">10.3 TLS Authentication Methods</h3>

<p>In <acronym>GnuTLS</acronym> authentication methods can be implemented quite
easily.  Since the required changes to add a new authentication method
affect only the handshake protocol, a simple interface is used. An
authentication method needs to implement the functions shown below.

<pre class="verbatim">typedef struct 
{
  const char *name;
  int (*gnutls_generate_server_certificate) (gnutls_session_t, gnutls_buffer_st*);
  int (*gnutls_generate_client_certificate) (gnutls_session_t, gnutls_buffer_st*);
  int (*gnutls_generate_server_kx) (gnutls_session_t, gnutls_buffer_st*);
  int (*gnutls_generate_client_kx) (gnutls_session_t, gnutls_buffer_st*);
  int (*gnutls_generate_client_cert_vrfy) (gnutls_session_t, gnutls_buffer_st *);
  int (*gnutls_generate_server_certificate_request) (gnutls_session_t,
                                                     gnutls_buffer_st *);

  int (*gnutls_process_server_certificate) (gnutls_session_t, opaque *,
                                            size_t);
  int (*gnutls_process_client_certificate) (gnutls_session_t, opaque *,
                                            size_t);
  int (*gnutls_process_server_kx) (gnutls_session_t, opaque *, size_t);
  int (*gnutls_process_client_kx) (gnutls_session_t, opaque *, size_t);
  int (*gnutls_process_client_cert_vrfy) (gnutls_session_t, opaque *, size_t);
  int (*gnutls_process_server_certificate_request) (gnutls_session_t,
                                                    opaque *, size_t);
} mod_auth_st;
</pre>

<p>Those functions are responsible for the
interpretation of the handshake protocol messages. It is common for such
functions to read data from one or more <code>credentials_t</code>
structures<a rel="footnote" href="#fn-16" name="fnd-16"><sup>16</sup></a> and write data,
such as certificates, usernames etc. to <code>auth_info_t</code> structures.

<p>Simple examples of existing authentication methods can be seen in
<code>auth/psk.c</code> for PSK ciphersuites and <code>auth/srp.c</code> for SRP
ciphersuites. After implementing these functions the structure holding
its pointers has to be registered in <code>gnutls_algorithms.c</code> in the
<code>_gnutls_kx_algorithms</code> structure.

<div class="node">
<a name="TLS-Extension-Handling"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Cryptographic-Backend">Cryptographic Backend</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#TLS-Authentication-Methods">TLS Authentication Methods</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Internal-architecture-of-GnuTLS">Internal architecture of GnuTLS</a>

</div>

<h3 class="section">10.4 TLS Extension Handling</h3>

<p>As with authentication methods, the TLS extensions handlers can be
implemented using the interface shown below.

<pre class="verbatim">typedef int (*gnutls_ext_recv_func) (gnutls_session_t session,
                                     const unsigned char *data, size_t len);
typedef int (*gnutls_ext_send_func) (gnutls_session_t session,
                                     gnutls_buffer_st *extdata);
</pre>

<p>Here there are two functions, one for receiving the extension data
and one for sending. These functions have to check internally whether
they operate in client or server side.

<p>A simple example of an extension handler can be seen in
<code>ext/srp.c</code> in GnuTLS' source code. After implementing these functions,
together with the extension number they handle, they have to be registered
using <code>_gnutls_ext_register</code> in
<code>gnutls_extensions.c</code> typically within <code>_gnutls_ext_init</code>.

<ul class="menu">
<li><a accesskey="1" href="#Adding-a-new-TLS-extension">Adding a new TLS extension</a>
</ul>

<div class="node">
<a name="Adding-a-new-TLS-extension"></a>
<p><hr>
Up:&nbsp;<a rel="up" accesskey="u" href="#TLS-Extension-Handling">TLS Extension Handling</a>

</div>

<h4 class="subsection">10.4.1 Adding a new TLS extension</h4>

<p>Adding support for a new TLS extension is done from time to time, and
the process to do so is not difficult.  Here are the steps you need to
follow if you wish to do this yourself.  For sake of discussion, let's
consider adding support for the hypothetical TLS extension
<code>foobar</code>.

<h5 class="subsubheading">Add <code>configure</code> option like <code>--enable-foobar</code> or <code>--disable-foobar</code>.</h5>

<p>This step is useful when the extension code is large and it might be desirable
to disable the extension under some circumstances. Otherwise it can be safely
skipped.

<p>Whether to chose enable or disable depends on whether you intend to make the extension be
enabled by default.  Look at existing checks (i.e., SRP, authz) for
how to model the code.  For example:

<pre class="example">     AC_MSG_CHECKING([whether to disable foobar support])
     AC_ARG_ENABLE(foobar,
     	AS_HELP_STRING([--disable-foobar],
     		[disable foobar support]),
     	ac_enable_foobar=no)
     if test x$ac_enable_foobar != xno; then
      AC_MSG_RESULT(no)
      AC_DEFINE(ENABLE_FOOBAR, 1, [enable foobar])
     else
      ac_full=0
      AC_MSG_RESULT(yes)
     fi
     AM_CONDITIONAL(ENABLE_FOOBAR, test "$ac_enable_foobar" != "no")
</pre>
<p>These lines should go in <code>lib/m4/hooks.m4</code>.

<h5 class="subsubheading">Add IANA extension value to <code>extensions_t</code> in <code>gnutls_int.h</code>.</h5>

<p>A good name for the value would be GNUTLS_EXTENSION_FOOBAR.  Check
with <a href="http://www.iana.org/assignments/tls-extensiontype-values">http://www.iana.org/assignments/tls-extensiontype-values</a>
for allocated values.  For experiments, you could pick a number but
remember that some consider it a bad idea to deploy such modified
version since it will lead to interoperability problems in the future
when the IANA allocates that number to someone else, or when the
foobar protocol is allocated another number.

<h5 class="subsubheading">Add an entry to <code>_gnutls_extensions</code> in <code>gnutls_extensions.c</code>.</h5>

<p>A typical entry would be:

<pre class="example">       int ret;
     
     #if ENABLE_FOOBAR
       ret = _gnutls_ext_register (&amp;foobar_ext);
       if (ret != GNUTLS_E_SUCCESS)
         return ret;
     #endif
</pre>
<p>Most likely you'll need to add an <code>#include "ext/foobar.h"</code>, that
will contain something like
like:
<pre class="example">       extension_entry_st foobar_ext = {
         .name = "FOOBAR",
         .type = GNUTLS_EXTENSION_FOOBAR,
         .parse_type = GNUTLS_EXT_TLS,
         .recv_func = _foobar_recv_params,
         .send_func = _foobar_send_params,
         .pack_func = _foobar_pack,
         .unpack_func = _foobar_unpack,
         .deinit_func = NULL
       }
</pre>
<p>The GNUTLS_EXTENSION_FOOBAR is the integer value you added to
<code>gnutls_int.h</code> earlier.  In this structure you specify the
functions to read the extension from the hello message, the function
to send the reply to, and two more functions to pack and unpack from
stored session data (e.g. when resumming a session). The <code>deinit</code> function
will be called to deinitialize the extension's private parameters, if any.

<p>Note that the conditional <code>ENABLE_FOOBAR</code> definition should only be
used if step 1 with the <code>configure</code> options has taken place.

<h5 class="subsubheading">Add new files  that implement the extension.</h5>

<p>The functions you are responsible to add are those mentioned in the
previous step.  They should be added in a file such as <code>ext/foobar.c</code>
and headers should be placed in <code>ext/foobar.h</code>. 
As a starter, you could add this:

<pre class="example">     int
     _foobar_recv_params (gnutls_session_t session, const opaque * data,
                          size_t data_size)
     {
       return 0;
     }
     
     int
     _foobar_send_params (gnutls_session_t session, gnutls_buffer_st* data)
     {
       return 0;
     }
     
     int
     _foobar_pack (extension_priv_data_t epriv, gnutls_buffer_st * ps)
     {
        /* Append the extension's internal state to buffer */
        return 0;
     }
     
     int
     _foobar_unpack (gnutls_buffer_st * ps, extension_priv_data_t * epriv)
     {
        /* Read the internal state from buffer */
        return 0;
     }
</pre>
<p>The <code>_foobar_recv_params</code> function is responsible for
parsing incoming extension data (both in the client and server).

<p>The <code>_foobar_send_params</code> function is responsible for
sending extension data (both in the client and server).

<p>If you receive length fields that doesn't match, return
<code>GNUTLS_E_UNEXPECTED_PACKET_LENGTH</code>.  If you receive invalid
data, return <code>GNUTLS_E_RECEIVED_ILLEGAL_PARAMETER</code>.  You can use
other error codes from the list in <a href="#Error-codes">Error codes</a>.  Return 0 on success.

<p>An extension typically stores private information in the <code>session</code>
data for later usage. That can be done using the functions
<code>_gnutls_ext_set_session_data</code> and
<code>_gnutls_ext_get_session_data</code>. You can check simple examples
at <code>ext/max_record.c</code> and <code>ext/server_name.c</code> extensions. 
That private information can be saved and restored across session
resumption if the following functions are set:

<p>The <code>_foobar_pack</code> function is responsible for packing
internal extension data to save them in the session resumption storage.

<p>The <code>_foobar_unpack</code> function is responsible for
restoring session data from the session resumption storage.

<p>Recall that both the client and server, send and receive
parameters, and your code most likely will need to do different things
depending on which mode it is in.  It may be useful to make this
distinction explicit in the code.  Thus, for example, a better
template than above would be:

<pre class="example">     int
     _gnutls_foobar_recv_params (gnutls_session_t session,
                                 const opaque * data,
                                 size_t data_size)
     {
       if (session-&gt;security_parameters.entity == GNUTLS_CLIENT)
         return foobar_recv_client (session, data, data_size);
       else
         return foobar_recv_server (session, data, data_size);
     }
     
     int
     _gnutls_foobar_send_params (gnutls_session_t session,
                                 gnutls_buffer_st * data)
     {
       if (session-&gt;security_parameters.entity == GNUTLS_CLIENT)
         return foobar_send_client (session, data);
       else
         return foobar_send_server (session, data);
     }
</pre>
<p>The functions used would be declared as <code>static</code> functions, of
the appropriate prototype, in the same file. 
When adding the files, you'll need to add them to <code>ext/Makefile.am</code>
as well, for example:

<pre class="example">     if ENABLE_FOOBAR
     libgnutls_ext_la_SOURCES += ext/foobar.c ext/foobar.h
     endif
</pre>
<h5 class="subsubheading">Add API functions to enable/disable the extension.</h5>

<p>It might be desirable to allow users of the extension to
request use of the extension, or set extension specific data. 
This can be implemented by adding extension specific function calls
that can be added to <code>includes/gnutls/gnutls.h</code>,
as long as the LGPLv3+ applies. 
The implementation of the function should lie in the <code>ext/foobar.c</code> file.

<p>To make the API available in the shared library you need to add the
symbol in <code>lib/libgnutls.map</code>, so that the symbol
is exported properly.

<p>When writing GTK-DOC style documentation for your new APIs, don't
forget to add <code>Since:</code> tags to indicate the GnuTLS version the
API was introduced in.

<div class="node">
<a name="Cryptographic-Backend"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#TLS-Extension-Handling">TLS Extension Handling</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Internal-architecture-of-GnuTLS">Internal architecture of GnuTLS</a>

</div>

<h3 class="section">10.5 Cryptographic Backend</h3>

<p>Today most new processors, either for embedded or desktop systems
include either instructions  intended to speed up cryptographic operations,
or a co-processor with cryptographic capabilities. Taking advantage of
those is a challenging task for every cryptographic  application or
library. Unfortunately the cryptographic library that GnuTLS is based
on takes no advantage of these capabilities. For this reason GnuTLS handles
this internally by following a layered approach to accessing
cryptographic operations as in <a href="#fig_003acrypto_002dlayers">fig:crypto-layers</a>.

<div class="float">
<a name="fig_003acrypto_002dlayers"></a><img src="gnutls-crypto-layers.png" alt="gnutls-crypto-layers.png">

<p><strong class="float-caption">Figure 10.4: GnuTLS cryptographic back-end design.</strong></p></div>

<p>The TLS layer uses a cryptographic provider layer, that will in turn either
use the default crypto provider &ndash; a software crypto library, or use an external
crypto provider, if available.

<h4 class="subsection">10.5.1 Cryptographic library layer</h4>

<p>The Cryptographic library layer, currently supports only
libnettle. Other cryptographic libraries might be supported
in the future.

<h4 class="subsection">10.5.2 External cryptography provider</h4>

<p>Systems that include a cryptographic co-processor, typically come with
kernel drivers to utilize the operations from software. For this reason
GnuTLS provides a layer where each individual algorithm used can be replaced
by another implementation, i.e., the one provided by the driver. The
FreeBSD, OpenBSD and Linux kernels<a rel="footnote" href="#fn-17" name="fnd-17"><sup>17</sup></a> include already
a number of hardware assisted implementations, and also provide an interface
to access them, called <code>/dev/crypto</code>. 
GnuTLS will take advantage of this interface if compiled with special
options. That is because in most systems where hardware-assisted
cryptographic operations are not available, using this interface might
actually harm performance.

<p>In systems that include cryptographic instructions with the CPU's
instructions set, using the kernel interface will introduce an
unneeded layer. For this reason GnuTLS includes such optimizations
found in popular processors such as the AES-NI or VIA PADLOCK instruction sets. 
This is achieved using a mechanism that detects CPU capabilities and
overrides parts of crypto backend at runtime. 
The next section discusses the registration of a detected algorithm
optimization. For more information please consult the <acronym>GnuTLS</acronym>
source code in <code>lib/accelerated/</code>.

<h5 class="subsubheading">Overriding specific algorithms</h5>

<p>When an optimized implementation of a single algorithm is available,
say a hardware assisted version of <acronym>AES-CBC</acronym> then the
following (internal) functions, from <code>crypto-backend.h</code>, can
be used to register those algorithms.

     <ul>
<li><code>gnutls_crypto_single_cipher_register</code>:
To register a cipher algorithm.

     <li><code>gnutls_crypto_single_digest_register</code>:
To register a hash (digest) or MAC algorithm.

</ul>

<p>Those registration functions will only replace the specified algorithm
and leave the rest of subsystem intact.

<h5 class="subsubheading">Overriding the cryptographic library</h5>

<p>In some systems, that might contain a broad acceleration engine, it
might be desirable to override big parts of the cryptographic backend,
or even all of them. T following functions are provided for this reason.

     <ul>
<li><code>gnutls_crypto_cipher_register</code>:
To override the cryptographic algorithms backend.

     <li><code>gnutls_crypto_digest_register</code>:
To override the digest algorithms backend.

     <li><code>gnutls_crypto_rnd_register</code>:
To override the random number generator backend.

     <li><code>gnutls_crypto_bigint_register</code>:
To override the big number number operations backend.

     <li><code>gnutls_crypto_pk_register</code>:
To override the public key encryption backend. This is tied to the
big number operations so either none or both of them should be overriden.

</ul>

<!-- appendices -->
<div class="node">
<a name="Support"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Error-codes">Error codes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Internal-architecture-of-GnuTLS">Internal architecture of GnuTLS</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix A Support</h2>

<ul class="menu">
<li><a accesskey="1" href="#Getting-help">Getting help</a>
<li><a accesskey="2" href="#Commercial-Support">Commercial Support</a>
<li><a accesskey="3" href="#Bug-Reports">Bug Reports</a>
<li><a accesskey="4" href="#Contributing">Contributing</a>
</ul>

<div class="node">
<a name="Getting-help"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Commercial-Support">Commercial Support</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Support">Support</a>

</div>

<h3 class="section">A.1 Getting Help</h3>

<p>A mailing list where users may help each other exists, and you can
reach it by sending e-mail to <a href="mailto:help-gnutls@gnu.org">help-gnutls@gnu.org</a>.  Archives
of the mailing list discussions, and an interface to manage
subscriptions, is available through the World Wide Web at
<a href="http://lists.gnu.org/mailman/listinfo/help-gnutls">http://lists.gnu.org/mailman/listinfo/help-gnutls</a>.

<p>A mailing list for developers are also available, see
<a href="http://www.gnu.org/software/gnutls/lists.html">http://www.gnu.org/software/gnutls/lists.html</a>. 
Bug reports should be sent to <a href="mailto:bug-gnutls@gnu.org">bug-gnutls@gnu.org</a>, see
<a href="#Bug-Reports">Bug Reports</a>.

<div class="node">
<a name="Commercial-Support"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Bug-Reports">Bug Reports</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Getting-help">Getting help</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Support">Support</a>

</div>

<h3 class="section">A.2 Commercial Support</h3>

<p>Commercial support is available for users of GnuTLS.  The kind of
support that can be purchased may include:

     <ul>
<li>Implement new features. 
Such as a new TLS extension.

     <li>Port GnuTLS to new platforms. 
This could include porting to an embedded platforms that may need
memory or size optimization.

     <li>Integrating TLS as a security environment in your existing project.

     <li>System design of components related to TLS.

</ul>

<p>If you are interested, please write to:

<pre class="verbatim">Simon Josefsson Datakonsult
Hagagatan 24
113 47 Stockholm
Sweden

E-mail: simon@josefsson.org
</pre>

<p>If your company provides support related to GnuTLS and would like to
be mentioned here, contact the authors.

<div class="node">
<a name="Bug-Reports"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Contributing">Contributing</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Commercial-Support">Commercial Support</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Support">Support</a>

</div>

<h3 class="section">A.3 Bug Reports</h3>

<p><a name="index-reporting-bugs-80"></a>
If you think you have found a bug in GnuTLS, please investigate it and
report it.

     <ul>
<li>Please make sure that the bug is really in GnuTLS, and
preferably also check that it hasn't already been fixed in the latest
version.

     <li>You have to send us a test case that makes it possible for us to
reproduce the bug.

     <li>You also have to explain what is wrong; if you get a crash, or
if the results printed are not good and in that case, in what way. 
Make sure that the bug report includes all information you would need
to fix this kind of bug for someone else.

</ul>

<p>Please make an effort to produce a self-contained report, with
something definite that can be tested or debugged.  Vague queries or
piecemeal messages are difficult to act on and don't help the
development effort.

<p>If your bug report is good, we will do our best to help you to get a
corrected version of the software; if the bug report is poor, we won't
do anything about it (apart from asking you to send better bug
reports).

<p>If you think something in this manual is unclear, or downright
incorrect, or if the language needs to be improved, please also send a
note.

<p>Send your bug report to:

<div align="center">&lsquo;<samp><span class="samp">bug-gnutls@gnu.org</span></samp>&rsquo;</div>

<div class="node">
<a name="Contributing"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Bug-Reports">Bug Reports</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Support">Support</a>

</div>

<h3 class="section">A.4 Contributing</h3>

<p><a name="index-contributing-81"></a><a name="index-hacking-82"></a>
If you want to submit a patch for inclusion &ndash; from solving a typo you
discovered, up to adding support for a new feature &ndash; you should
submit it as a bug report, using the process in <a href="#Bug-Reports">Bug Reports</a>.  There are some
things that you can do to increase the chances for it to be included
in the official package.

<p>Unless your patch is very small (say, under 10 lines) we require that
you assign the copyright of your work to the Free Software Foundation. 
This is to protect the freedom of the project.  If you have not
already signed papers, we will send you the necessary information when
you submit your contribution.

<p>For contributions that doesn't consist of actual programming code, the
only guidelines are common sense. 
For code contributions, a number of style guides will help you:

     <ul>
<li>Coding Style. 
Follow the GNU Standards document. 
<!-- (@pxref{top, GNU Coding Standards,,standards}). -->

     <p>If you normally code using another coding standard, there is no
problem, but you should use &lsquo;<samp><span class="samp">indent</span></samp>&rsquo; to reformat the code
<!-- (@pxref{top, GNU Indent,, indent}) -->
before submitting your work.

     <li>Use the unified diff format &lsquo;<samp><span class="samp">diff -u</span></samp>&rsquo;.

     <li>Return errors. 
No reason whatsoever should abort the execution of the library.  Even
memory allocation errors, e.g. when malloc return NULL, should work
although result in an error code.

     <li>Design with thread safety in mind. 
Don't use global variables.  Don't even write to per-handle global
variables unless the documented behaviour of the function you write is
to write to the per-handle global variable.

     <li>Avoid using the C math library. 
It causes problems for embedded implementations, and in most
situations it is very easy to avoid using it.

     <li>Document your functions. 
Use comments before each function headers, that, if properly
formatted, are extracted into Texinfo manuals and GTK-DOC web pages.

     <li>Supply a ChangeLog and NEWS entries, where appropriate.

</ul>

<div class="node">
<a name="Error-codes"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#API-reference">API reference</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Support">Support</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix B Error Codes and Descriptions</h2>

<p><a name="index-error-codes-83"></a>
The error codes used throughout the library are described below.  The
return code <code>GNUTLS_E_SUCCESS</code> indicate successful operation, and
is guaranteed to have the value 0, so you can use it in logical
expressions.

     <dl>
<dt><code>GNUTLS_E_AGAIN:</code><dd>Resource temporarily unavailable, try again.

     <br><dt><code>GNUTLS_E_ASN1_DER_ERROR:</code><dd>ASN1 parser: Error in DER parsing.

     <br><dt><code>GNUTLS_E_ASN1_DER_OVERFLOW:</code><dd>ASN1 parser: Overflow in DER parsing.

     <br><dt><code>GNUTLS_E_ASN1_ELEMENT_NOT_FOUND:</code><dd>ASN1 parser: Element was not found.

     <br><dt><code>GNUTLS_E_ASN1_GENERIC_ERROR:</code><dd>ASN1 parser: Generic parsing error.

     <br><dt><code>GNUTLS_E_ASN1_IDENTIFIER_NOT_FOUND:</code><dd>ASN1 parser: Identifier was not found

     <br><dt><code>GNUTLS_E_ASN1_SYNTAX_ERROR:</code><dd>ASN1 parser: Syntax error.

     <br><dt><code>GNUTLS_E_ASN1_TAG_ERROR:</code><dd>ASN1 parser: Error in TAG.

     <br><dt><code>GNUTLS_E_ASN1_TAG_IMPLICIT:</code><dd>ASN1 parser: error in implicit tag

     <br><dt><code>GNUTLS_E_ASN1_TYPE_ANY_ERROR:</code><dd>ASN1 parser: Error in type 'ANY'.

     <br><dt><code>GNUTLS_E_ASN1_VALUE_NOT_FOUND:</code><dd>ASN1 parser: Value was not found.

     <br><dt><code>GNUTLS_E_ASN1_VALUE_NOT_VALID:</code><dd>ASN1 parser: Value is not valid.

     <br><dt><code>GNUTLS_E_BAD_COOKIE:</code><dd>The cookie was bad.

     <br><dt><code>GNUTLS_E_BASE64_DECODING_ERROR:</code><dd>Base64 decoding error.

     <br><dt><code>GNUTLS_E_BASE64_ENCODING_ERROR:</code><dd>Base64 encoding error.

     <br><dt><code>GNUTLS_E_BASE64_UNEXPECTED_HEADER_ERROR:</code><dd>Base64 unexpected header error.

     <br><dt><code>GNUTLS_E_CERTIFICATE_ERROR:</code><dd>Error in the certificate.

     <br><dt><code>GNUTLS_E_CERTIFICATE_KEY_MISMATCH:</code><dd>The certificate and the given key do not match.

     <br><dt><code>GNUTLS_E_CERTIFICATE_LIST_UNSORTED:</code><dd>The provided X.509 certificate list is not sorted (in subject to issuer order)

     <br><dt><code>GNUTLS_E_CHANNEL_BINDING_NOT_AVAILABLE:</code><dd>Channel binding data not available

     <br><dt><code>GNUTLS_E_COMPRESSION_FAILED:</code><dd>Compression of the TLS record packet has failed.

     <br><dt><code>GNUTLS_E_CONSTRAINT_ERROR:</code><dd>Some constraint limits were reached.

     <br><dt><code>GNUTLS_E_CRYPTODEV_DEVICE_ERROR:</code><dd>Error opening /dev/crypto

     <br><dt><code>GNUTLS_E_CRYPTODEV_IOCTL_ERROR:</code><dd>Error interfacing with /dev/crypto

     <br><dt><code>GNUTLS_E_CRYPTO_ALREADY_REGISTERED:</code><dd>There is already a crypto algorithm with lower priority.

     <br><dt><code>GNUTLS_E_CRYPTO_INIT_FAILED:</code><dd>The initialization of crypto backend has failed.

     <br><dt><code>GNUTLS_E_DB_ERROR:</code><dd>Error in Database backend.

     <br><dt><code>GNUTLS_E_DECOMPRESSION_FAILED:</code><dd>Decompression of the TLS record packet has failed.

     <br><dt><code>GNUTLS_E_DECRYPTION_FAILED:</code><dd>Decryption has failed.

     <br><dt><code>GNUTLS_E_DH_PRIME_UNACCEPTABLE:</code><dd>The Diffie-Hellman prime sent by the server is not acceptable (not long enough).

     <br><dt><code>GNUTLS_E_ECC_NO_SUPPORTED_CURVES:</code><dd>No supported ECC curves were found

     <br><dt><code>GNUTLS_E_ECC_UNSUPPORTED_CURVE:</code><dd>The curve is unsupported

     <br><dt><code>GNUTLS_E_ENCRYPTION_FAILED:</code><dd>Encryption has failed.

     <br><dt><code>GNUTLS_E_ERROR_IN_FINISHED_PACKET:</code><dd>An error was encountered at the TLS Finished packet calculation.

     <br><dt><code>GNUTLS_E_EXPIRED:</code><dd>The requested session has expired.

     <br><dt><code>GNUTLS_E_FATAL_ALERT_RECEIVED:</code><dd>A TLS fatal alert has been received.

     <br><dt><code>GNUTLS_E_FILE_ERROR:</code><dd>Error while reading file.

     <br><dt><code>GNUTLS_E_GOT_APPLICATION_DATA:</code><dd>TLS Application data were received, while expecting handshake data.

     <br><dt><code>GNUTLS_E_HANDSHAKE_TOO_LARGE:</code><dd>The handshake data size is too large.

     <br><dt><code>GNUTLS_E_HASH_FAILED:</code><dd>Hashing has failed.

     <br><dt><code>GNUTLS_E_IA_VERIFY_FAILED:</code><dd>Verifying TLS/IA phase checksum failed

     <br><dt><code>GNUTLS_E_ILLEGAL_PARAMETER:</code><dd>An illegal parameter was found.

     <br><dt><code>GNUTLS_E_ILLEGAL_SRP_USERNAME:</code><dd>The SRP username supplied is illegal.

     <br><dt><code>GNUTLS_E_INCOMPATIBLE_GCRYPT_LIBRARY:</code><dd>The crypto library version is too old.

     <br><dt><code>GNUTLS_E_INCOMPATIBLE_LIBTASN1_LIBRARY:</code><dd>The tasn1 library version is too old.

     <br><dt><code>GNUTLS_E_INCOMPAT_DSA_KEY_WITH_TLS_PROTOCOL:</code><dd>The given DSA key is incompatible with the selected TLS protocol.

     <br><dt><code>GNUTLS_E_INSUFFICIENT_CREDENTIALS:</code><dd>Insufficient credentials for that request.

     <br><dt><code>GNUTLS_E_INTERNAL_ERROR:</code><dd>GnuTLS internal error.

     <br><dt><code>GNUTLS_E_INTERRUPTED:</code><dd>Function was interrupted.

     <br><dt><code>GNUTLS_E_INVALID_PASSWORD:</code><dd>The given password contains invalid characters.

     <br><dt><code>GNUTLS_E_INVALID_REQUEST:</code><dd>The request is invalid.

     <br><dt><code>GNUTLS_E_INVALID_SESSION:</code><dd>The specified session has been invalidated for some reason.

     <br><dt><code>GNUTLS_E_KEY_USAGE_VIOLATION:</code><dd>Key usage violation in certificate has been detected.

     <br><dt><code>GNUTLS_E_LARGE_PACKET:</code><dd>A large TLS record packet was received.

     <br><dt><code>GNUTLS_E_LOCKING_ERROR:</code><dd>Thread locking error

     <br><dt><code>GNUTLS_E_MAC_VERIFY_FAILED:</code><dd>The Message Authentication Code verification failed.

     <br><dt><code>GNUTLS_E_MEMORY_ERROR:</code><dd>Internal error in memory allocation.

     <br><dt><code>GNUTLS_E_MPI_PRINT_FAILED:</code><dd>Could not export a large integer.

     <br><dt><code>GNUTLS_E_MPI_SCAN_FAILED:</code><dd>The scanning of a large integer has failed.

     <br><dt><code>GNUTLS_E_NO_CERTIFICATE_FOUND:</code><dd>The peer did not send any certificate.

     <br><dt><code>GNUTLS_E_NO_CIPHER_SUITES:</code><dd>No supported cipher suites have been found.

     <br><dt><code>GNUTLS_E_NO_COMPRESSION_ALGORITHMS:</code><dd>No supported compression algorithms have been found.

     <br><dt><code>GNUTLS_E_NO_TEMPORARY_DH_PARAMS:</code><dd>No temporary DH parameters were found.

     <br><dt><code>GNUTLS_E_NO_TEMPORARY_RSA_PARAMS:</code><dd>No temporary RSA parameters were found.

     <br><dt><code>GNUTLS_E_OPENPGP_FINGERPRINT_UNSUPPORTED:</code><dd>The OpenPGP fingerprint is not supported.

     <br><dt><code>GNUTLS_E_OPENPGP_GETKEY_FAILED:</code><dd>Could not get OpenPGP key.

     <br><dt><code>GNUTLS_E_OPENPGP_KEYRING_ERROR:</code><dd>Error loading the keyring.

     <br><dt><code>GNUTLS_E_OPENPGP_PREFERRED_KEY_ERROR:</code><dd>The OpenPGP key has not a preferred key set.

     <br><dt><code>GNUTLS_E_OPENPGP_SUBKEY_ERROR:</code><dd>Could not find OpenPGP subkey.

     <br><dt><code>GNUTLS_E_OPENPGP_UID_REVOKED:</code><dd>The OpenPGP User ID is revoked.

     <br><dt><code>GNUTLS_E_PARSING_ERROR:</code><dd>Error in parsing.

     <br><dt><code>GNUTLS_E_PKCS11_ATTRIBUTE_ERROR:</code><dd>PKCS #11 error in attribute

     <br><dt><code>GNUTLS_E_PKCS11_DATA_ERROR:</code><dd>PKCS #11 error in data

     <br><dt><code>GNUTLS_E_PKCS11_DEVICE_ERROR:</code><dd>PKCS #11 error in device

     <br><dt><code>GNUTLS_E_PKCS11_ERROR:</code><dd>PKCS #11 error.

     <br><dt><code>GNUTLS_E_PKCS11_KEY_ERROR:</code><dd>PKCS #11 error in key

     <br><dt><code>GNUTLS_E_PKCS11_LOAD_ERROR:</code><dd>PKCS #11 initialization error.

     <br><dt><code>GNUTLS_E_PKCS11_PIN_ERROR:</code><dd>PKCS #11 error in PIN.

     <br><dt><code>GNUTLS_E_PKCS11_PIN_EXPIRED:</code><dd>PKCS #11 PIN expired

     <br><dt><code>GNUTLS_E_PKCS11_PIN_LOCKED:</code><dd>PKCS #11 PIN locked

     <br><dt><code>GNUTLS_E_PKCS11_REQUESTED_OBJECT_NOT_AVAILBLE:</code><dd>The requested PKCS #11 object is not available

     <br><dt><code>GNUTLS_E_PKCS11_SESSION_ERROR:</code><dd>PKCS #11 error in session

     <br><dt><code>GNUTLS_E_PKCS11_SIGNATURE_ERROR:</code><dd>PKCS #11 error in signature

     <br><dt><code>GNUTLS_E_PKCS11_SLOT_ERROR:</code><dd>PKCS #11 error in slot

     <br><dt><code>GNUTLS_E_PKCS11_TOKEN_ERROR:</code><dd>PKCS #11 error in token

     <br><dt><code>GNUTLS_E_PKCS11_UNSUPPORTED_FEATURE_ERROR:</code><dd>PKCS #11 unsupported feature

     <br><dt><code>GNUTLS_E_PKCS11_USER_ERROR:</code><dd>PKCS #11 user error

     <br><dt><code>GNUTLS_E_PKCS1_WRONG_PAD:</code><dd>Wrong padding in PKCS1 packet.

     <br><dt><code>GNUTLS_E_PK_DECRYPTION_FAILED:</code><dd>Public key decryption has failed.

     <br><dt><code>GNUTLS_E_PK_ENCRYPTION_FAILED:</code><dd>Public key encryption has failed.

     <br><dt><code>GNUTLS_E_PK_SIGN_FAILED:</code><dd>Public key signing has failed.

     <br><dt><code>GNUTLS_E_PK_SIG_VERIFY_FAILED:</code><dd>Public key signature verification has failed.

     <br><dt><code>GNUTLS_E_PREMATURE_TERMINATION:</code><dd>The TLS connection was non-properly terminated.

     <br><dt><code>GNUTLS_E_PULL_ERROR:</code><dd>Error in the pull function.

     <br><dt><code>GNUTLS_E_PUSH_ERROR:</code><dd>Error in the push function.

     <br><dt><code>GNUTLS_E_RANDOM_FAILED:</code><dd>Failed to acquire random data.

     <br><dt><code>GNUTLS_E_RECEIVED_ILLEGAL_EXTENSION:</code><dd>An illegal TLS extension was received.

     <br><dt><code>GNUTLS_E_RECEIVED_ILLEGAL_PARAMETER:</code><dd>An illegal parameter has been received.

     <br><dt><code>GNUTLS_E_RECORD_LIMIT_REACHED:</code><dd>The upper limit of record packet sequence numbers has been reached. Wow!

     <br><dt><code>GNUTLS_E_REHANDSHAKE:</code><dd>Rehandshake was requested by the peer.

     <br><dt><code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE:</code><dd>The requested data were not available.

     <br><dt><code>GNUTLS_E_SAFE_RENEGOTIATION_FAILED:</code><dd>Safe renegotiation failed.

     <br><dt><code>GNUTLS_E_SHORT_MEMORY_BUFFER:</code><dd>The given memory buffer is too short to hold parameters.

     <br><dt><code>GNUTLS_E_SRP_PWD_ERROR:</code><dd>Error in password file.

     <br><dt><code>GNUTLS_E_SRP_PWD_PARSING_ERROR:</code><dd>Parsing error in password file.

     <br><dt><code>GNUTLS_E_SUCCESS:</code><dd>Success.

     <br><dt><code>GNUTLS_E_TIMEDOUT:</code><dd>The operation timed out

     <br><dt><code>GNUTLS_E_TOO_MANY_EMPTY_PACKETS:</code><dd>Too many empty record packets have been received.

     <br><dt><code>GNUTLS_E_TOO_MANY_HANDSHAKE_PACKETS:</code><dd>Too many handshake packets have been received.

     <br><dt><code>GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET:</code><dd>An unexpected TLS handshake packet was received.

     <br><dt><code>GNUTLS_E_UNEXPECTED_PACKET:</code><dd>An unexpected TLS packet was received.

     <br><dt><code>GNUTLS_E_UNEXPECTED_PACKET_LENGTH:</code><dd>A TLS packet with unexpected length was received.

     <br><dt><code>GNUTLS_E_UNKNOWN_ALGORITHM:</code><dd>The specified algorithm or protocol is unknown.

     <br><dt><code>GNUTLS_E_UNKNOWN_CIPHER_SUITE:</code><dd>Could not negotiate a supported cipher suite.

     <br><dt><code>GNUTLS_E_UNKNOWN_CIPHER_TYPE:</code><dd>The cipher type is unsupported.

     <br><dt><code>GNUTLS_E_UNKNOWN_COMPRESSION_ALGORITHM:</code><dd>Could not negotiate a supported compression method.

     <br><dt><code>GNUTLS_E_UNKNOWN_HASH_ALGORITHM:</code><dd>The hash algorithm is unknown.

     <br><dt><code>GNUTLS_E_UNKNOWN_PKCS_BAG_TYPE:</code><dd>The PKCS structure's bag type is unknown.

     <br><dt><code>GNUTLS_E_UNKNOWN_PKCS_CONTENT_TYPE:</code><dd>The PKCS structure's content type is unknown.

     <br><dt><code>GNUTLS_E_UNKNOWN_PK_ALGORITHM:</code><dd>An unknown public key algorithm was encountered.

     <br><dt><code>GNUTLS_E_UNKNOWN_SRP_USERNAME:</code><dd>The SRP username supplied is unknown.

     <br><dt><code>GNUTLS_E_UNSAFE_RENEGOTIATION_DENIED:</code><dd>Unsafe renegotiation denied.

     <br><dt><code>GNUTLS_E_UNSUPPORTED_CERTIFICATE_TYPE:</code><dd>The certificate type is not supported.

     <br><dt><code>GNUTLS_E_UNSUPPORTED_SIGNATURE_ALGORITHM:</code><dd>The signature algorithm is not supported.

     <br><dt><code>GNUTLS_E_UNSUPPORTED_VERSION_PACKET:</code><dd>A record packet with illegal version was received.

     <br><dt><code>GNUTLS_E_UNWANTED_ALGORITHM:</code><dd>An algorithm that is not enabled was negotiated.

     <br><dt><code>GNUTLS_E_USER_ERROR:</code><dd>The operation was cancelled due to user error

     <br><dt><code>GNUTLS_E_WARNING_ALERT_RECEIVED:</code><dd>A TLS warning alert has been received.

     <br><dt><code>GNUTLS_E_WARNING_IA_FPHF_RECEIVED:</code><dd>Received a TLS/IA Final Phase Finished message

     <br><dt><code>GNUTLS_E_WARNING_IA_IPHF_RECEIVED:</code><dd>Received a TLS/IA Intermediate Phase Finished message

     <br><dt><code>GNUTLS_E_X509_UNKNOWN_SAN:</code><dd>Unknown Subject Alternative name in X.509 certificate.

     <br><dt><code>GNUTLS_E_X509_UNSUPPORTED_ATTRIBUTE:</code><dd>The certificate has unsupported attributes.

     <br><dt><code>GNUTLS_E_X509_UNSUPPORTED_CRITICAL_EXTENSION:</code><dd>Unsupported critical extension in X.509 certificate.

     <br><dt><code>GNUTLS_E_X509_UNSUPPORTED_OID:</code><dd>The OID is not supported.

</dl>

<div class="node">
<a name="API-reference"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Supported-ciphersuites-in-GnuTLS">Supported ciphersuites in GnuTLS</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Error-codes">Error codes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix C API reference</h2>

<p><a name="index-API-reference-84"></a>

<ul class="menu">
<li><a accesskey="1" href="#Core-TLS-API">Core TLS API</a>
<li><a accesskey="2" href="#Datagram-TLS-API">Datagram TLS API</a>
<li><a accesskey="3" href="#X509-certificate-API">X509 certificate API</a>
<li><a accesskey="4" href="#OpenPGP-API">OpenPGP API</a>
<li><a accesskey="5" href="#PKCS-12-API">PKCS 12 API</a>
<li><a accesskey="6" href="#PKCS-11-API">PKCS 11 API</a>
<li><a accesskey="7" href="#Abstract-key-API">Abstract key API</a>
<li><a accesskey="8" href="#Cryptographic-API">Cryptographic API</a>
<li><a accesskey="9" href="#Compatibility-API">Compatibility API</a>
</ul>

<div class="node">
<a name="Core-TLS-API"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Datagram-TLS-API">Datagram TLS API</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#API-reference">API reference</a>

</div>

<h3 class="section">C.1 Core TLS API</h3>

<p>The prototypes for the following functions lie in
<samp><span class="file">gnutls/gnutls.h</span></samp>.

<h4 class="subheading">gnutls_alert_get</h4>

<p><a name="gnutls_005falert_005fget"></a>

<div class="defun">
&mdash; Function: gnutls_alert_description_t <b>gnutls_alert_get</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005falert_005fget-85"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>This function will return the last alert number received.  This
function should be called when <code>GNUTLS_E_WARNING_ALERT_RECEIVED</code> or
<code>GNUTLS_E_FATAL_ALERT_RECEIVED</code> errors are returned by a gnutls
function.  The peer may send alerts if he encounters an error. 
If no alert has been received the returned value is undefined.

     <p><strong>Returns:</strong> the last alert received, a
<code>gnutls_alert_description_t</code> value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_alert_get_name</h4>

<p><a name="gnutls_005falert_005fget_005fname"></a>

<div class="defun">
&mdash; Function: const char * <b>gnutls_alert_get_name</b> (<var>gnutls_alert_description_t alert</var>)<var><a name="index-gnutls_005falert_005fget_005fname-86"></a></var><br>
<blockquote><p><var>alert</var>: is an alert number.

     <p>This function will return a string that describes the given alert
number, or <code>NULL</code>.  See <code>gnutls_alert_get()</code>.

     <p><strong>Returns:</strong> string corresponding to <code>gnutls_alert_description_t</code> value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_alert_get_strname</h4>

<p><a name="gnutls_005falert_005fget_005fstrname"></a>

<div class="defun">
&mdash; Function: const char * <b>gnutls_alert_get_strname</b> (<var>gnutls_alert_description_t alert</var>)<var><a name="index-gnutls_005falert_005fget_005fstrname-87"></a></var><br>
<blockquote><p><var>alert</var>: is an alert number.

     <p>This function will return a string of the name of the alert.

     <p><strong>Returns:</strong> string corresponding to <code>gnutls_alert_description_t</code> value.

     <p><strong>Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_alert_send</h4>

<p><a name="gnutls_005falert_005fsend"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_alert_send</b> (<var>gnutls_session_t session, gnutls_alert_level_t level, gnutls_alert_description_t desc</var>)<var><a name="index-gnutls_005falert_005fsend-88"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>level</var>: is the level of the alert

     <p><var>desc</var>: is the alert description

     <p>This function will send an alert to the peer in order to inform
him of something important (eg. his Certificate could not be verified). 
If the alert level is Fatal then the peer is expected to close the
connection, otherwise he may ignore the alert and continue.

     <p>The error code of the underlying record send function will be
returned, so you may also receive <code>GNUTLS_E_INTERRUPTED</code> or
<code>GNUTLS_E_AGAIN</code> as well.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise
an error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_alert_send_appropriate</h4>

<p><a name="gnutls_005falert_005fsend_005fappropriate"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_alert_send_appropriate</b> (<var>gnutls_session_t session, int err</var>)<var><a name="index-gnutls_005falert_005fsend_005fappropriate-89"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>err</var>: is an integer

     <p>Sends an alert to the peer depending on the error code returned by
a gnutls function. This function will call <code>gnutls_error_to_alert()</code>
to determine the appropriate alert to send.

     <p>This function may also return <code>GNUTLS_E_AGAIN</code>, or
<code>GNUTLS_E_INTERRUPTED</code>.

     <p>If the return value is <code>GNUTLS_E_INVALID_REQUEST</code>, then no alert has
been sent to the peer.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise
an error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_anon_allocate_client_credentials</h4>

<p><a name="gnutls_005fanon_005fallocate_005fclient_005fcredentials"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_anon_allocate_client_credentials</b> (<var>gnutls_anon_client_credentials_t * sc</var>)<var><a name="index-gnutls_005fanon_005fallocate_005fclient_005fcredentials-90"></a></var><br>
<blockquote><p><var>sc</var>: is a pointer to a <code>gnutls_anon_client_credentials_t</code> structure.

     <p>This structure is complex enough to manipulate directly thus
this helper function is provided in order to allocate it.

     <p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_anon_allocate_server_credentials</h4>

<p><a name="gnutls_005fanon_005fallocate_005fserver_005fcredentials"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_anon_allocate_server_credentials</b> (<var>gnutls_anon_server_credentials_t * sc</var>)<var><a name="index-gnutls_005fanon_005fallocate_005fserver_005fcredentials-91"></a></var><br>
<blockquote><p><var>sc</var>: is a pointer to a <code>gnutls_anon_server_credentials_t</code> structure.

     <p>This structure is complex enough to manipulate directly thus this
helper function is provided in order to allocate it.

     <p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_anon_free_client_credentials</h4>

<p><a name="gnutls_005fanon_005ffree_005fclient_005fcredentials"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_anon_free_client_credentials</b> (<var>gnutls_anon_client_credentials_t sc</var>)<var><a name="index-gnutls_005fanon_005ffree_005fclient_005fcredentials-92"></a></var><br>
<blockquote><p><var>sc</var>: is a <code>gnutls_anon_client_credentials_t</code> structure.

     <p>This structure is complex enough to manipulate directly thus this
helper function is provided in order to free (deallocate) it. 
</p></blockquote></div>

<h4 class="subheading">gnutls_anon_free_server_credentials</h4>

<p><a name="gnutls_005fanon_005ffree_005fserver_005fcredentials"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_anon_free_server_credentials</b> (<var>gnutls_anon_server_credentials_t sc</var>)<var><a name="index-gnutls_005fanon_005ffree_005fserver_005fcredentials-93"></a></var><br>
<blockquote><p><var>sc</var>: is a <code>gnutls_anon_server_credentials_t</code> structure.

     <p>This structure is complex enough to manipulate directly thus this
helper function is provided in order to free (deallocate) it. 
</p></blockquote></div>

<h4 class="subheading">gnutls_anon_set_params_function</h4>

<p><a name="gnutls_005fanon_005fset_005fparams_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_anon_set_params_function</b> (<var>gnutls_anon_server_credentials_t res, gnutls_params_function * func</var>)<var><a name="index-gnutls_005fanon_005fset_005fparams_005ffunction-94"></a></var><br>
<blockquote><p><var>res</var>: is a gnutls_anon_server_credentials_t structure

     <p><var>func</var>: is the function to be called

     <p>This function will set a callback in order for the server to get
the Diffie-Hellman or RSA parameters for anonymous authentication. 
The callback should return <code>GNUTLS_E_SUCCESS</code> (0) on success. 
</p></blockquote></div>

<h4 class="subheading">gnutls_anon_set_server_dh_params</h4>

<p><a name="gnutls_005fanon_005fset_005fserver_005fdh_005fparams"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_anon_set_server_dh_params</b> (<var>gnutls_anon_server_credentials_t res, gnutls_dh_params_t dh_params</var>)<var><a name="index-gnutls_005fanon_005fset_005fserver_005fdh_005fparams-95"></a></var><br>
<blockquote><p><var>res</var>: is a gnutls_anon_server_credentials_t structure

     <p><var>dh_params</var>: is a structure that holds Diffie-Hellman parameters.

     <p>This function will set the Diffie-Hellman parameters for an
anonymous server to use.  These parameters will be used in
Anonymous Diffie-Hellman cipher suites. 
</p></blockquote></div>

<h4 class="subheading">gnutls_anon_set_server_params_function</h4>

<p><a name="gnutls_005fanon_005fset_005fserver_005fparams_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_anon_set_server_params_function</b> (<var>gnutls_anon_server_credentials_t res, gnutls_params_function * func</var>)<var><a name="index-gnutls_005fanon_005fset_005fserver_005fparams_005ffunction-96"></a></var><br>
<blockquote><p><var>res</var>: is a gnutls_certificate_credentials_t structure

     <p><var>func</var>: is the function to be called

     <p>This function will set a callback in order for the server to get
the Diffie-Hellman parameters for anonymous authentication.  The
callback should return <code>GNUTLS_E_SUCCESS</code> (0) on success. 
</p></blockquote></div>

<h4 class="subheading">gnutls_auth_client_get_type</h4>

<p><a name="gnutls_005fauth_005fclient_005fget_005ftype"></a>

<div class="defun">
&mdash; Function: gnutls_credentials_type_t <b>gnutls_auth_client_get_type</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fauth_005fclient_005fget_005ftype-97"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>Returns the type of credentials that were used for client authentication. 
The returned information is to be used to distinguish the function used
to access authentication data.

     <p><strong>Returns:</strong> The type of credentials for the client authentication
schema, a <code>gnutls_credentials_type_t</code> type. 
</p></blockquote></div>

<h4 class="subheading">gnutls_auth_get_type</h4>

<p><a name="gnutls_005fauth_005fget_005ftype"></a>

<div class="defun">
&mdash; Function: gnutls_credentials_type_t <b>gnutls_auth_get_type</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fauth_005fget_005ftype-98"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>Returns type of credentials for the current authentication schema. 
The returned information is to be used to distinguish the function used
to access authentication data.

     <p>Eg. for CERTIFICATE ciphersuites (key exchange algorithms:
<code>GNUTLS_KX_RSA</code>, <code>GNUTLS_KX_DHE_RSA</code>), the same function are to be
used to access the authentication data.

     <p><strong>Returns:</strong> The type of credentials for the current authentication
schema, a <code>gnutls_credentials_type_t</code> type. 
</p></blockquote></div>

<h4 class="subheading">gnutls_auth_server_get_type</h4>

<p><a name="gnutls_005fauth_005fserver_005fget_005ftype"></a>

<div class="defun">
&mdash; Function: gnutls_credentials_type_t <b>gnutls_auth_server_get_type</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fauth_005fserver_005fget_005ftype-99"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>Returns the type of credentials that were used for server authentication. 
The returned information is to be used to distinguish the function used
to access authentication data.

     <p><strong>Returns:</strong> The type of credentials for the server authentication
schema, a <code>gnutls_credentials_type_t</code> type. 
</p></blockquote></div>

<h4 class="subheading">gnutls_bye</h4>

<p><a name="gnutls_005fbye"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_bye</b> (<var>gnutls_session_t session, gnutls_close_request_t how</var>)<var><a name="index-gnutls_005fbye-100"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>how</var>: is an integer

     <p>Terminates the current TLS/SSL connection. The connection should
have been initiated using <code>gnutls_handshake()</code>.   <code>how</code>should be one
of <code>GNUTLS_SHUT_RDWR</code>, <code>GNUTLS_SHUT_WR</code>.

     <p>In case of <code>GNUTLS_SHUT_RDWR</code> the TLS session gets
terminated and further receives and sends will be disallowed.  If
the return value is zero you may continue using the underlying
transport layer. <code>GNUTLS_SHUT_RDWR</code> sends an alert containing a close
request and waits for the peer to reply with the same message.

     <p>In case of <code>GNUTLS_SHUT_WR</code> the TLS session gets terminated
and further sends will be disallowed. In order to reuse the
connection you should wait for an EOF from the peer. 
<code>GNUTLS_SHUT_WR</code> sends an alert containing a close request.

     <p>Note that not all implementations will properly terminate a TLS
connection.  Some of them, usually for performance reasons, will
terminate only the underlying transport layer, and thus not
distinguishing between a malicious party prematurely terminating
the connection and normal termination.

     <p>This function may also return <code>GNUTLS_E_AGAIN</code> or
<code>GNUTLS_E_INTERRUPTED</code>; cf.  <code>gnutls_record_get_direction()</code>.

     <p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code, see
function documentation for entire semantics. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_activation_time_peers</h4>

<p><a name="gnutls_005fcertificate_005factivation_005ftime_005fpeers"></a>

<div class="defun">
&mdash; Function: time_t <b>gnutls_certificate_activation_time_peers</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fcertificate_005factivation_005ftime_005fpeers-101"></a></var><br>
<blockquote><p><var>session</var>: is a gnutls session

     <p>This function will return the peer's certificate activation time. 
This is the creation time for openpgp keys.

     <p><strong>Returns:</strong> (time_t)-1 on error.

     <p><strong>Deprecated:</strong> <code>gnutls_certificate_verify_peers2()</code> now verifies activation times. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_allocate_credentials</h4>

<p><a name="gnutls_005fcertificate_005fallocate_005fcredentials"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_certificate_allocate_credentials</b> (<var>gnutls_certificate_credentials_t * res</var>)<var><a name="index-gnutls_005fcertificate_005fallocate_005fcredentials-102"></a></var><br>
<blockquote><p><var>res</var>: is a pointer to a <code>gnutls_certificate_credentials_t</code> structure.

     <p>This structure is complex enough to manipulate directly thus this
helper function is provided in order to allocate it.

     <p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_client_get_request_status</h4>

<p><a name="gnutls_005fcertificate_005fclient_005fget_005frequest_005fstatus"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_certificate_client_get_request_status</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fcertificate_005fclient_005fget_005frequest_005fstatus-103"></a></var><br>
<blockquote><p><var>session</var>: is a gnutls session

     <p>Get whether client certificate is requested or not.

     <p><strong>Returns:</strong> 0 if the peer (server) did not request client
authentication or 1 otherwise, or a negative error code in case of
error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_expiration_time_peers</h4>

<p><a name="gnutls_005fcertificate_005fexpiration_005ftime_005fpeers"></a>

<div class="defun">
&mdash; Function: time_t <b>gnutls_certificate_expiration_time_peers</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fcertificate_005fexpiration_005ftime_005fpeers-104"></a></var><br>
<blockquote><p><var>session</var>: is a gnutls session

     <p>This function will return the peer's certificate expiration time.

     <p><strong>Returns:</strong> (time_t)-1 on error.

     <p><strong>Deprecated:</strong> <code>gnutls_certificate_verify_peers2()</code> now verifies expiration times. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_free_ca_names</h4>

<p><a name="gnutls_005fcertificate_005ffree_005fca_005fnames"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_certificate_free_ca_names</b> (<var>gnutls_certificate_credentials_t sc</var>)<var><a name="index-gnutls_005fcertificate_005ffree_005fca_005fnames-105"></a></var><br>
<blockquote><p><var>sc</var>: is a <code>gnutls_certificate_credentials_t</code> structure.

     <p>This function will delete all the CA name in the given
credentials. Clients may call this to save some memory since in
client side the CA names are not used. Servers might want to use
this function if a large list of trusted CAs is present and
sending the names of it would just consume bandwidth without providing
information to client.

     <p>CA names are used by servers to advertize the CAs they support to
clients. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_free_cas</h4>

<p><a name="gnutls_005fcertificate_005ffree_005fcas"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_certificate_free_cas</b> (<var>gnutls_certificate_credentials_t sc</var>)<var><a name="index-gnutls_005fcertificate_005ffree_005fcas-106"></a></var><br>
<blockquote><p><var>sc</var>: is a <code>gnutls_certificate_credentials_t</code> structure.

     <p>This function will delete all the CAs associated with the given
credentials. Servers that do not use
<code>gnutls_certificate_verify_peers2()</code> may call this to save some
memory. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_free_credentials</h4>

<p><a name="gnutls_005fcertificate_005ffree_005fcredentials"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_certificate_free_credentials</b> (<var>gnutls_certificate_credentials_t sc</var>)<var><a name="index-gnutls_005fcertificate_005ffree_005fcredentials-107"></a></var><br>
<blockquote><p><var>sc</var>: is a <code>gnutls_certificate_credentials_t</code> structure.

     <p>This structure is complex enough to manipulate directly thus this
helper function is provided in order to free (deallocate) it.

     <p>This function does not free any temporary parameters associated
with this structure (ie RSA and DH parameters are not freed by this
function). 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_free_crls</h4>

<p><a name="gnutls_005fcertificate_005ffree_005fcrls"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_certificate_free_crls</b> (<var>gnutls_certificate_credentials_t sc</var>)<var><a name="index-gnutls_005fcertificate_005ffree_005fcrls-108"></a></var><br>
<blockquote><p><var>sc</var>: is a <code>gnutls_certificate_credentials_t</code> structure.

     <p>This function will delete all the CRLs associated
with the given credentials. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_free_keys</h4>

<p><a name="gnutls_005fcertificate_005ffree_005fkeys"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_certificate_free_keys</b> (<var>gnutls_certificate_credentials_t sc</var>)<var><a name="index-gnutls_005fcertificate_005ffree_005fkeys-109"></a></var><br>
<blockquote><p><var>sc</var>: is a <code>gnutls_certificate_credentials_t</code> structure.

     <p>This function will delete all the keys and the certificates associated
with the given credentials. This function must not be called when a
TLS negotiation that uses the credentials is in progress. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_get_issuer</h4>

<p><a name="gnutls_005fcertificate_005fget_005fissuer"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_certificate_get_issuer</b> (<var>gnutls_certificate_credentials_t sc, gnutls_x509_crt_t cert, gnutls_x509_crt_t* issuer, unsigned int flags</var>)<var><a name="index-gnutls_005fcertificate_005fget_005fissuer-110"></a></var><br>
<blockquote><p><var>sc</var>: is a <code>gnutls_certificate_credentials_t</code> structure.

     <p><var>cert</var>: is the certificate to find issuer for

     <p><var>issuer</var>: Will hold the issuer if any. Should be treated as constant.

     <p><var>flags</var>: Use zero.

     <p>This function will return the issuer of a given certificate.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong>Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_get_ours</h4>

<p><a name="gnutls_005fcertificate_005fget_005fours"></a>

<div class="defun">
&mdash; Function: const gnutls_datum_t * <b>gnutls_certificate_get_ours</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fcertificate_005fget_005fours-111"></a></var><br>
<blockquote><p><var>session</var>: is a gnutls session

     <p>Gets the certificate as sent to the peer in the last handshake. 
The certificate is in raw (DER) format.  No certificate
list is being returned. Only the first certificate.

     <p><strong>Returns:</strong> a pointer to a <code>gnutls_datum_t</code> containing our
certificates, or <code>NULL</code> in case of an error or if no certificate
was used. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_get_peers</h4>

<p><a name="gnutls_005fcertificate_005fget_005fpeers"></a>

<div class="defun">
&mdash; Function: const gnutls_datum_t * <b>gnutls_certificate_get_peers</b> (<var>gnutls_session_t session, unsigned int * list_size</var>)<var><a name="index-gnutls_005fcertificate_005fget_005fpeers-112"></a></var><br>
<blockquote><p><var>session</var>: is a gnutls session

     <p><var>list_size</var>: is the length of the certificate list

     <p>Get the peer's raw certificate (chain) as sent by the peer.  These
certificates are in raw format (DER encoded for X.509).  In case of
a X.509 then a certificate list may be present.  The first
certificate in the list is the peer's certificate, following the
issuer's certificate, then the issuer's issuer etc.

     <p>In case of OpenPGP keys a single key will be returned in raw
format.

     <p><strong>Returns:</strong> a pointer to a <code>gnutls_datum_t</code> containing our
certificates, or <code>NULL</code> in case of an error or if no certificate
was used. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_send_x509_rdn_sequence</h4>

<p><a name="gnutls_005fcertificate_005fsend_005fx509_005frdn_005fsequence"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_certificate_send_x509_rdn_sequence</b> (<var>gnutls_session_t session, int status</var>)<var><a name="index-gnutls_005fcertificate_005fsend_005fx509_005frdn_005fsequence-113"></a></var><br>
<blockquote><p><var>session</var>: is a pointer to a <code>gnutls_session_t</code> structure.

     <p><var>status</var>: is 0 or 1

     <p>If status is non zero, this function will order gnutls not to send
the rdnSequence in the certificate request message. That is the
server will not advertize it's trusted CAs to the peer. If status
is zero then the default behaviour will take effect, which is to
advertize the server's trusted CAs.

     <p>This function has no effect in clients, and in authentication
methods other than certificate with X.509 certificates. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_server_set_request</h4>

<p><a name="gnutls_005fcertificate_005fserver_005fset_005frequest"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_certificate_server_set_request</b> (<var>gnutls_session_t session, gnutls_certificate_request_t req</var>)<var><a name="index-gnutls_005fcertificate_005fserver_005fset_005frequest-114"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>req</var>: is one of GNUTLS_CERT_REQUEST, GNUTLS_CERT_REQUIRE

     <p>This function specifies if we (in case of a server) are going to
send a certificate request message to the client. If  <code>req</code>is
GNUTLS_CERT_REQUIRE then the server will return an error if the
peer does not provide a certificate. If you do not call this
function then the client will not be asked to send a certificate. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_set_dh_params</h4>

<p><a name="gnutls_005fcertificate_005fset_005fdh_005fparams"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_certificate_set_dh_params</b> (<var>gnutls_certificate_credentials_t res, gnutls_dh_params_t dh_params</var>)<var><a name="index-gnutls_005fcertificate_005fset_005fdh_005fparams-115"></a></var><br>
<blockquote><p><var>res</var>: is a gnutls_certificate_credentials_t structure

     <p><var>dh_params</var>: is a structure that holds Diffie-Hellman parameters.

     <p>This function will set the Diffie-Hellman parameters for a
certificate server to use. These parameters will be used in
Ephemeral Diffie-Hellman cipher suites.  Note that only a pointer
to the parameters are stored in the certificate handle, so if you
deallocate the parameters before the certificate is deallocated,
you must change the parameters stored in the certificate first. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_set_params_function</h4>

<p><a name="gnutls_005fcertificate_005fset_005fparams_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_certificate_set_params_function</b> (<var>gnutls_certificate_credentials_t res, gnutls_params_function * func</var>)<var><a name="index-gnutls_005fcertificate_005fset_005fparams_005ffunction-116"></a></var><br>
<blockquote><p><var>res</var>: is a gnutls_certificate_credentials_t structure

     <p><var>func</var>: is the function to be called

     <p>This function will set a callback in order for the server to get
the Diffie-Hellman or RSA parameters for certificate
authentication.  The callback should return <code>GNUTLS_E_SUCCESS</code> (0) on success. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_set_retrieve_function</h4>

<p><a name="gnutls_005fcertificate_005fset_005fretrieve_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_certificate_set_retrieve_function</b> (<var>gnutls_certificate_credentials_t cred, gnutls_certificate_retrieve_function * func</var>)<var><a name="index-gnutls_005fcertificate_005fset_005fretrieve_005ffunction-117"></a></var><br>
<blockquote><p><var>cred</var>: is a <code>gnutls_certificate_credentials_t</code> structure.

     <p><var>func</var>: is the callback function

     <p>This function sets a callback to be called in order to retrieve the
certificate to be used in the handshake. You are advised
to use <code>gnutls_certificate_set_retrieve_function2()</code> because it
is much more efficient in the processing it requires from gnutls.

     <p>The callback's function prototype is:
int (*callback)(gnutls_session_t, const gnutls_datum_t* req_ca_dn, int nreqs,
const gnutls_pk_algorithm_t* pk_algos, int pk_algos_length, gnutls_retr2_st* st);

     <p><code>req_ca_cert</code>is only used in X.509 certificates. 
Contains a list with the CA names that the server considers trusted. 
Normally we should send a certificate that is signed
by one of these CAs. These names are DER encoded. To get a more
meaningful value use the function <code>gnutls_x509_rdn_get()</code>.

     <p><code>pk_algos</code>contains a list with server's acceptable signature algorithms. 
The certificate returned should support the server's given algorithms.

     <p><code>st</code>should contain the certificates and private keys.

     <p>If the callback function is provided then gnutls will call it, in the
handshake, after the certificate request message has been received.

     <p>In server side pk_algos and req_ca_dn are NULL.

     <p>The callback function should set the certificate list to be sent,
and return 0 on success. If no certificate was selected then the
number of certificates should be set to zero. The value (-1)
indicates error and the handshake will be terminated.

     <p><strong>Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_set_verify_flags</h4>

<p><a name="gnutls_005fcertificate_005fset_005fverify_005fflags"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_certificate_set_verify_flags</b> (<var>gnutls_certificate_credentials_t res, unsigned int flags</var>)<var><a name="index-gnutls_005fcertificate_005fset_005fverify_005fflags-118"></a></var><br>
<blockquote><p><var>res</var>: is a gnutls_certificate_credentials_t structure

     <p><var>flags</var>: are the flags

     <p>This function will set the flags to be used at verification of the
certificates.  Flags must be OR of the
<code>gnutls_certificate_verify_flags</code> enumerations. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_set_verify_function</h4>

<p><a name="gnutls_005fcertificate_005fset_005fverify_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_certificate_set_verify_function</b> (<var>gnutls_certificate_credentials_t cred, gnutls_certificate_verify_function * func</var>)<var><a name="index-gnutls_005fcertificate_005fset_005fverify_005ffunction-119"></a></var><br>
<blockquote><p><var>cred</var>: is a <code>gnutls_certificate_credentials_t</code> structure.

     <p><var>func</var>: is the callback function

     <p>This function sets a callback to be called when peer's certificate
has been received in order to verify it on receipt rather than
doing after the handshake is completed.

     <p>The callback's function prototype is:
int (*callback)(gnutls_session_t);

     <p>If the callback function is provided then gnutls will call it, in the
handshake, just after the certificate message has been received. 
To verify or obtain the certificate the <code>gnutls_certificate_verify_peers2()</code>,
<code>gnutls_certificate_type_get()</code>, <code>gnutls_certificate_get_peers()</code> functions
can be used.

     <p>The callback function should return 0 for the handshake to continue
or non-zero to terminate.

     <p><strong>Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_set_verify_limits</h4>

<p><a name="gnutls_005fcertificate_005fset_005fverify_005flimits"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_certificate_set_verify_limits</b> (<var>gnutls_certificate_credentials_t res, unsigned int max_bits, unsigned int max_depth</var>)<var><a name="index-gnutls_005fcertificate_005fset_005fverify_005flimits-120"></a></var><br>
<blockquote><p><var>res</var>: is a gnutls_certificate_credentials structure

     <p><var>max_bits</var>: is the number of bits of an acceptable certificate (default 8200)

     <p><var>max_depth</var>: is maximum depth of the verification of a certificate chain (default 5)

     <p>This function will set some upper limits for the default
verification function, <code>gnutls_certificate_verify_peers2()</code>, to avoid
denial of service attacks.  You can set them to zero to disable
limits. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_set_x509_crl</h4>

<p><a name="gnutls_005fcertificate_005fset_005fx509_005fcrl"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_certificate_set_x509_crl</b> (<var>gnutls_certificate_credentials_t res, gnutls_x509_crl_t * crl_list, int crl_list_size</var>)<var><a name="index-gnutls_005fcertificate_005fset_005fx509_005fcrl-121"></a></var><br>
<blockquote><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code> structure.

     <p><var>crl_list</var>: is a list of trusted CRLs. They should have been verified before.

     <p><var>crl_list_size</var>: holds the size of the crl_list

     <p>This function adds the trusted CRLs in order to verify client or
server certificates.  In case of a client this is not required to
be called if the certificates are not verified using
<code>gnutls_certificate_verify_peers2()</code>.  This function may be called
multiple times.

     <p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code> (0) on success, or a negative error code.

     <p><strong>Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_set_x509_crl_file</h4>

<p><a name="gnutls_005fcertificate_005fset_005fx509_005fcrl_005ffile"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_certificate_set_x509_crl_file</b> (<var>gnutls_certificate_credentials_t res, const char * crlfile, gnutls_x509_crt_fmt_t type</var>)<var><a name="index-gnutls_005fcertificate_005fset_005fx509_005fcrl_005ffile-122"></a></var><br>
<blockquote><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code> structure.

     <p><var>crlfile</var>: is a file containing the list of verified CRLs (DER or PEM list)

     <p><var>type</var>: is PEM or DER

     <p>This function adds the trusted CRLs in order to verify client or server
certificates.  In case of a client this is not required
to be called if the certificates are not verified using
<code>gnutls_certificate_verify_peers2()</code>. 
This function may be called multiple times.

     <p><strong>Returns:</strong> number of CRLs processed or a negative error code on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_set_x509_crl_mem</h4>

<p><a name="gnutls_005fcertificate_005fset_005fx509_005fcrl_005fmem"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_certificate_set_x509_crl_mem</b> (<var>gnutls_certificate_credentials_t res, const gnutls_datum_t * CRL, gnutls_x509_crt_fmt_t type</var>)<var><a name="index-gnutls_005fcertificate_005fset_005fx509_005fcrl_005fmem-123"></a></var><br>
<blockquote><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code> structure.

     <p><var>CRL</var>: is a list of trusted CRLs. They should have been verified before.

     <p><var>type</var>: is DER or PEM

     <p>This function adds the trusted CRLs in order to verify client or
server certificates.  In case of a client this is not required to
be called if the certificates are not verified using
<code>gnutls_certificate_verify_peers2()</code>.  This function may be called
multiple times.

     <p><strong>Returns:</strong> number of CRLs processed, or a negative error code on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_set_x509_key</h4>

<p><a name="gnutls_005fcertificate_005fset_005fx509_005fkey"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_certificate_set_x509_key</b> (<var>gnutls_certificate_credentials_t res, gnutls_x509_crt_t * cert_list, int cert_list_size, gnutls_x509_privkey_t key</var>)<var><a name="index-gnutls_005fcertificate_005fset_005fx509_005fkey-124"></a></var><br>
<blockquote><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code> structure.

     <p><var>cert_list</var>: contains a certificate list (path) for the specified private key

     <p><var>cert_list_size</var>: holds the size of the certificate list

     <p><var>key</var>: is a gnutls_x509_privkey_t key

     <p>This function sets a certificate/private key pair in the
gnutls_certificate_credentials_t structure.  This function may be
called more than once, in case multiple keys/certificates exist for
the server.  For clients that wants to send more than its own end
entity certificate (e.g., also an intermediate CA cert) then put
the certificate chain in  <code>cert_list</code>.

     <p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code> (0) on success, or a negative error code.

     <p><strong>Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_set_x509_key_file</h4>

<p><a name="gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_certificate_set_x509_key_file</b> (<var>gnutls_certificate_credentials_t res, const char * certfile, const char * keyfile, gnutls_x509_crt_fmt_t type</var>)<var><a name="index-gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile-125"></a></var><br>
<blockquote><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code> structure.

     <p><var>certfile</var>: is a file that containing the certificate list (path) for
the specified private key, in PKCS7 format, or a list of certificates

     <p><var>keyfile</var>: is a file that contains the private key

     <p><var>type</var>: is PEM or DER

     <p>This function sets a certificate/private key pair in the
gnutls_certificate_credentials_t structure.  This function may be
called more than once, in case multiple keys/certificates exist for
the server.  For clients that need to send more than its own end
entity certificate, e.g., also an intermediate CA cert, then the
 <code>certfile</code>must contain the ordered certificate chain.

     <p>This function can also accept PKCS <code>11</code> URLs at  <code>keyfile</code>and  <code>certfile</code>. In that case it
will import the private key and certificate indicated by the URLs.

     <p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code> (0) on success, or a negative error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_set_x509_key_mem</h4>

<p><a name="gnutls_005fcertificate_005fset_005fx509_005fkey_005fmem"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_certificate_set_x509_key_mem</b> (<var>gnutls_certificate_credentials_t res, const gnutls_datum_t * cert, const gnutls_datum_t * key, gnutls_x509_crt_fmt_t type</var>)<var><a name="index-gnutls_005fcertificate_005fset_005fx509_005fkey_005fmem-126"></a></var><br>
<blockquote><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code> structure.

     <p><var>cert</var>: contains a certificate list (path) for the specified private key

     <p><var>key</var>: is the private key, or <code>NULL</code>

     <p><var>type</var>: is PEM or DER

     <p>This function sets a certificate/private key pair in the
gnutls_certificate_credentials_t structure. This function may be called
more than once, in case multiple keys/certificates exist for the
server.

     <p>Note that the keyUsage (2.5.29.15) PKIX extension in X.509 certificates
is supported. This means that certificates intended for signing cannot
be used for ciphersuites that require encryption.

     <p>If the certificate and the private key are given in PEM encoding
then the strings that hold their values must be null terminated.

     <p>The  <code>key</code>may be <code>NULL</code> if you are using a sign callback, see
<code>gnutls_sign_callback_set()</code>.

     <p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code> (0) on success, or a negative error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_set_x509_trust</h4>

<p><a name="gnutls_005fcertificate_005fset_005fx509_005ftrust"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_certificate_set_x509_trust</b> (<var>gnutls_certificate_credentials_t res, gnutls_x509_crt_t * ca_list, int ca_list_size</var>)<var><a name="index-gnutls_005fcertificate_005fset_005fx509_005ftrust-127"></a></var><br>
<blockquote><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code> structure.

     <p><var>ca_list</var>: is a list of trusted CAs

     <p><var>ca_list_size</var>: holds the size of the CA list

     <p>This function adds the trusted CAs in order to verify client
or server certificates. In case of a client this is not required
to be called if the certificates are not verified using
<code>gnutls_certificate_verify_peers2()</code>. 
This function may be called multiple times.

     <p>In case of a server the CAs set here will be sent to the client if
a certificate request is sent. This can be disabled using
<code>gnutls_certificate_send_x509_rdn_sequence()</code>.

     <p><strong>Returns:</strong> the number of certificates processed or a negative error code
on error.

     <p><strong>Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_set_x509_trust_file</h4>

<p><a name="gnutls_005fcertificate_005fset_005fx509_005ftrust_005ffile"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_certificate_set_x509_trust_file</b> (<var>gnutls_certificate_credentials_t cred, const char * cafile, gnutls_x509_crt_fmt_t type</var>)<var><a name="index-gnutls_005fcertificate_005fset_005fx509_005ftrust_005ffile-128"></a></var><br>
<blockquote><p><var>cred</var>: is a <code>gnutls_certificate_credentials_t</code> structure.

     <p><var>cafile</var>: is a file containing the list of trusted CAs (DER or PEM list)

     <p><var>type</var>: is PEM or DER

     <p>This function adds the trusted CAs in order to verify client or
server certificates. In case of a client this is not required to
be called if the certificates are not verified using
<code>gnutls_certificate_verify_peers2()</code>.  This function may be called
multiple times.

     <p>In case of a server the names of the CAs set here will be sent to
the client if a certificate request is sent. This can be disabled
using <code>gnutls_certificate_send_x509_rdn_sequence()</code>.

     <p>This function can also accept PKCS <code>11</code> URLs. In that case it
will import all certificates that are marked as trusted.

     <p><strong>Returns:</strong> number of certificates processed, or a negative error code on
error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_set_x509_trust_mem</h4>

<p><a name="gnutls_005fcertificate_005fset_005fx509_005ftrust_005fmem"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_certificate_set_x509_trust_mem</b> (<var>gnutls_certificate_credentials_t res, const gnutls_datum_t * ca, gnutls_x509_crt_fmt_t type</var>)<var><a name="index-gnutls_005fcertificate_005fset_005fx509_005ftrust_005fmem-129"></a></var><br>
<blockquote><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code> structure.

     <p><var>ca</var>: is a list of trusted CAs or a DER certificate

     <p><var>type</var>: is DER or PEM

     <p>This function adds the trusted CAs in order to verify client or
server certificates. In case of a client this is not required to be
called if the certificates are not verified using
<code>gnutls_certificate_verify_peers2()</code>.  This function may be called
multiple times.

     <p>In case of a server the CAs set here will be sent to the client if
a certificate request is sent. This can be disabled using
<code>gnutls_certificate_send_x509_rdn_sequence()</code>.

     <p><strong>Returns:</strong> the number of certificates processed or a negative error code
on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_type_get</h4>

<p><a name="gnutls_005fcertificate_005ftype_005fget"></a>

<div class="defun">
&mdash; Function: gnutls_certificate_type_t <b>gnutls_certificate_type_get</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fcertificate_005ftype_005fget-130"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>The certificate type is by default X.509, unless it is negotiated
as a TLS extension.

     <p><strong>Returns:</strong> the currently used <code>gnutls_certificate_type_t</code> certificate
type. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_type_get_id</h4>

<p><a name="gnutls_005fcertificate_005ftype_005fget_005fid"></a>

<div class="defun">
&mdash; Function: gnutls_certificate_type_t <b>gnutls_certificate_type_get_id</b> (<var>const char * name</var>)<var><a name="index-gnutls_005fcertificate_005ftype_005fget_005fid-131"></a></var><br>
<blockquote><p><var>name</var>: is a certificate type name

     <p>The names are compared in a case insensitive way.

     <p><strong>Returns:</strong> a <code>gnutls_certificate_type_t</code> for the specified in a
string certificate type, or <code>GNUTLS_CRT_UNKNOWN</code> on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_type_get_name</h4>

<p><a name="gnutls_005fcertificate_005ftype_005fget_005fname"></a>

<div class="defun">
&mdash; Function: const char * <b>gnutls_certificate_type_get_name</b> (<var>gnutls_certificate_type_t type</var>)<var><a name="index-gnutls_005fcertificate_005ftype_005fget_005fname-132"></a></var><br>
<blockquote><p><var>type</var>: is a certificate type

     <p>Convert a <code>gnutls_certificate_type_t</code> type to a string.

     <p><strong>Returns:</strong> a string that contains the name of the specified
certificate type, or <code>NULL</code> in case of unknown types. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_type_list</h4>

<p><a name="gnutls_005fcertificate_005ftype_005flist"></a>

<div class="defun">
&mdash; Function: const gnutls_certificate_type_t * <b>gnutls_certificate_type_list</b> (<var> void</var>)<var><a name="index-gnutls_005fcertificate_005ftype_005flist-133"></a></var><br>
<blockquote>
     <p>Get a list of certificate types.  Note that to be able to use
OpenPGP certificates, you must link to libgnutls-extra and call
<code>gnutls_global_init_extra()</code>.

     <p><strong>Returns:</strong> a (0)-terminated list of <code>gnutls_certificate_type_t</code>
integers indicating the available certificate types. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_verify_peers2</h4>

<p><a name="gnutls_005fcertificate_005fverify_005fpeers2"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_certificate_verify_peers2</b> (<var>gnutls_session_t session, unsigned int * status</var>)<var><a name="index-gnutls_005fcertificate_005fverify_005fpeers2-134"></a></var><br>
<blockquote><p><var>session</var>: is a gnutls session

     <p><var>status</var>: is the output of the verification

     <p>This function will try to verify the peer's certificate and return
its status (trusted, invalid etc.).  The value of  <code>status</code>should
be one or more of the gnutls_certificate_status_t enumerated
elements bitwise or'd. To avoid denial of service attacks some
default upper limits regarding the certificate key size and chain
size are set. To override them use
<code>gnutls_certificate_set_verify_limits()</code>.

     <p>Note that you must also check the peer's name in order to check if
the verified certificate belongs to the actual peer.

     <p>This function uses <code>gnutls_x509_crt_list_verify()</code> with the CAs in
the credentials as trusted CAs.

     <p><strong>Returns:</strong> a negative error code on error and <code>GNUTLS_E_SUCCESS</code> (0) on success. 
</p></blockquote></div>

<h4 class="subheading">gnutls_check_version</h4>

<p><a name="gnutls_005fcheck_005fversion"></a>

<div class="defun">
&mdash; Function: const char * <b>gnutls_check_version</b> (<var>const char * req_version</var>)<var><a name="index-gnutls_005fcheck_005fversion-135"></a></var><br>
<blockquote><p><var>req_version</var>: version string to compare with, or <code>NULL</code>.

     <p>Check GnuTLS Library version.

     <p>See <code>GNUTLS_VERSION</code> for a suitable  <code>req_version</code>string.

     <p><strong>Returns:</strong> Check that the version of the library is at
minimum the one given as a string in  <code>req_version</code>and return the
actual version string of the library; return <code>NULL</code> if the
condition is not met.  If <code>NULL</code> is passed to this function no
check is done and only the version string is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_cipher_get</h4>

<p><a name="gnutls_005fcipher_005fget"></a>

<div class="defun">
&mdash; Function: gnutls_cipher_algorithm_t <b>gnutls_cipher_get</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fcipher_005fget-136"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>Get currently used cipher.

     <p><strong>Returns:</strong> the currently used cipher, a <code>gnutls_cipher_algorithm_t</code>
type. 
</p></blockquote></div>

<h4 class="subheading">gnutls_cipher_get_id</h4>

<p><a name="gnutls_005fcipher_005fget_005fid"></a>

<div class="defun">
&mdash; Function: gnutls_cipher_algorithm_t <b>gnutls_cipher_get_id</b> (<var>const char * name</var>)<var><a name="index-gnutls_005fcipher_005fget_005fid-137"></a></var><br>
<blockquote><p><var>name</var>: is a MAC algorithm name

     <p>The names are compared in a case insensitive way.

     <p><strong>Returns:</strong> return a <code>gnutls_cipher_algorithm_t</code> value corresponding to
the specified cipher, or <code>GNUTLS_CIPHER_UNKNOWN</code> on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_cipher_get_key_size</h4>

<p><a name="gnutls_005fcipher_005fget_005fkey_005fsize"></a>

<div class="defun">
&mdash; Function: size_t <b>gnutls_cipher_get_key_size</b> (<var>gnutls_cipher_algorithm_t algorithm</var>)<var><a name="index-gnutls_005fcipher_005fget_005fkey_005fsize-138"></a></var><br>
<blockquote><p><var>algorithm</var>: is an encryption algorithm

     <p>Get key size for cipher.

     <p><strong>Returns:</strong> length (in bytes) of the given cipher's key size, or 0 if
the given cipher is invalid. 
</p></blockquote></div>

<h4 class="subheading">gnutls_cipher_get_name</h4>

<p><a name="gnutls_005fcipher_005fget_005fname"></a>

<div class="defun">
&mdash; Function: const char * <b>gnutls_cipher_get_name</b> (<var>gnutls_cipher_algorithm_t algorithm</var>)<var><a name="index-gnutls_005fcipher_005fget_005fname-139"></a></var><br>
<blockquote><p><var>algorithm</var>: is an encryption algorithm

     <p>Convert a <code>gnutls_cipher_algorithm_t</code> type to a string.

     <p><strong>Returns:</strong> a pointer to a string that contains the name of the
specified cipher, or <code>NULL</code>. 
</p></blockquote></div>

<h4 class="subheading">gnutls_cipher_list</h4>

<p><a name="gnutls_005fcipher_005flist"></a>

<div class="defun">
&mdash; Function: const gnutls_cipher_algorithm_t * <b>gnutls_cipher_list</b> (<var> void</var>)<var><a name="index-gnutls_005fcipher_005flist-140"></a></var><br>
<blockquote>
     <p>Get a list of supported cipher algorithms.  Note that not
necessarily all ciphers are supported as TLS cipher suites.  For
example, DES is not supported as a cipher suite, but is supported
for other purposes (e.g., PKCS<code>8</code> or similar).

     <p>This function is not thread safe.

     <p><strong>Returns:</strong> a (0)-terminated list of <code>gnutls_cipher_algorithm_t</code>
integers indicating the available ciphers. 
</p></blockquote></div>

<h4 class="subheading">gnutls_cipher_suite_get_name</h4>

<p><a name="gnutls_005fcipher_005fsuite_005fget_005fname"></a>

<div class="defun">
&mdash; Function: const char * <b>gnutls_cipher_suite_get_name</b> (<var>gnutls_kx_algorithm_t kx_algorithm, gnutls_cipher_algorithm_t cipher_algorithm, gnutls_mac_algorithm_t mac_algorithm</var>)<var><a name="index-gnutls_005fcipher_005fsuite_005fget_005fname-141"></a></var><br>
<blockquote><p><var>kx_algorithm</var>: is a Key exchange algorithm

     <p><var>cipher_algorithm</var>: is a cipher algorithm

     <p><var>mac_algorithm</var>: is a MAC algorithm

     <p>Note that the full cipher suite name must be prepended by TLS or
SSL depending of the protocol in use.

     <p><strong>Returns:</strong> a string that contains the name of a TLS cipher suite,
specified by the given algorithms, or <code>NULL</code>. 
</p></blockquote></div>

<h4 class="subheading">gnutls_cipher_suite_info</h4>

<p><a name="gnutls_005fcipher_005fsuite_005finfo"></a>

<div class="defun">
&mdash; Function: const char * <b>gnutls_cipher_suite_info</b> (<var>size_t idx, unsigned char * cs_id, gnutls_kx_algorithm_t * kx, gnutls_cipher_algorithm_t * cipher, gnutls_mac_algorithm_t * mac, gnutls_protocol_t * min_version</var>)<var><a name="index-gnutls_005fcipher_005fsuite_005finfo-142"></a></var><br>
<blockquote><p><var>idx</var>: index of cipher suite to get information about, starts on 0.

     <p><var>cs_id</var>: output buffer with room for 2 bytes, indicating cipher suite value

     <p><var>kx</var>: output variable indicating key exchange algorithm, or <code>NULL</code>.

     <p><var>cipher</var>: output variable indicating cipher, or <code>NULL</code>.

     <p><var>mac</var>: output variable indicating MAC algorithm, or <code>NULL</code>.

     <p><var>min_version</var>: output variable indicating TLS protocol version, or <code>NULL</code>.

     <p>Get information about supported cipher suites.  Use the function
iteratively to get information about all supported cipher suites. 
Call with idx=0 to get information about first cipher suite, then
idx=1 and so on until the function returns NULL.

     <p><strong>Returns:</strong> the name of  <code>idx</code>cipher suite, and set the information
about the cipher suite in the output variables.  If  <code>idx</code>is out of
bounds, <code>NULL</code> is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_compression_get</h4>

<p><a name="gnutls_005fcompression_005fget"></a>

<div class="defun">
&mdash; Function: gnutls_compression_method_t <b>gnutls_compression_get</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fcompression_005fget-143"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>Get currently used compression algorithm.

     <p><strong>Returns:</strong> the currently used compression method, a
<code>gnutls_compression_method_t</code> value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_compression_get_id</h4>

<p><a name="gnutls_005fcompression_005fget_005fid"></a>

<div class="defun">
&mdash; Function: gnutls_compression_method_t <b>gnutls_compression_get_id</b> (<var>const char * name</var>)<var><a name="index-gnutls_005fcompression_005fget_005fid-144"></a></var><br>
<blockquote><p><var>name</var>: is a compression method name

     <p>The names are compared in a case insensitive way.

     <p><strong>Returns:</strong> an id of the specified in a string compression method, or
<code>GNUTLS_COMP_UNKNOWN</code> on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_compression_get_name</h4>

<p><a name="gnutls_005fcompression_005fget_005fname"></a>

<div class="defun">
&mdash; Function: const char * <b>gnutls_compression_get_name</b> (<var>gnutls_compression_method_t algorithm</var>)<var><a name="index-gnutls_005fcompression_005fget_005fname-145"></a></var><br>
<blockquote><p><var>algorithm</var>: is a Compression algorithm

     <p>Convert a <code>gnutls_compression_method_t</code> value to a string.

     <p><strong>Returns:</strong> a pointer to a string that contains the name of the
specified compression algorithm, or <code>NULL</code>. 
</p></blockquote></div>

<h4 class="subheading">gnutls_compression_list</h4>

<p><a name="gnutls_005fcompression_005flist"></a>

<div class="defun">
&mdash; Function: const gnutls_compression_method_t * <b>gnutls_compression_list</b> (<var> void</var>)<var><a name="index-gnutls_005fcompression_005flist-146"></a></var><br>
<blockquote>
     <p>Get a list of compression methods.

     <p><strong>Returns:</strong> a zero-terminated list of <code>gnutls_compression_method_t</code>
integers indicating the available compression methods. 
</p></blockquote></div>

<h4 class="subheading">gnutls_credentials_clear</h4>

<p><a name="gnutls_005fcredentials_005fclear"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_credentials_clear</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fcredentials_005fclear-147"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>Clears all the credentials previously set in this session. 
</p></blockquote></div>

<h4 class="subheading">gnutls_credentials_set</h4>

<p><a name="gnutls_005fcredentials_005fset"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_credentials_set</b> (<var>gnutls_session_t session, gnutls_credentials_type_t type, void * cred</var>)<var><a name="index-gnutls_005fcredentials_005fset-148"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>type</var>: is the type of the credentials

     <p><var>cred</var>: is a pointer to a structure.

     <p>Sets the needed credentials for the specified type.  Eg username,
password - or public and private keys etc.  The  <code>cred</code>parameter is
a structure that depends on the specified type and on the current
session (client or server).

     <p>In order to minimize memory usage, and share credentials between
several threads gnutls keeps a pointer to cred, and not the whole
cred structure.  Thus you will have to keep the structure allocated
until you call <code>gnutls_deinit()</code>.

     <p>For <code>GNUTLS_CRD_ANON</code>,  <code>cred</code>should be
<code>gnutls_anon_client_credentials_t</code> in case of a client.  In case of
a server it should be <code>gnutls_anon_server_credentials_t</code>.

     <p>For <code>GNUTLS_CRD_SRP</code>,  <code>cred</code>should be <code>gnutls_srp_client_credentials_t</code>
in case of a client, and <code>gnutls_srp_server_credentials_t</code>, in case
of a server.

     <p>For <code>GNUTLS_CRD_CERTIFICATE</code>,  <code>cred</code>should be
<code>gnutls_certificate_credentials_t</code>.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned,
otherwise a negative error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_db_check_entry</h4>

<p><a name="gnutls_005fdb_005fcheck_005fentry"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_db_check_entry</b> (<var>gnutls_session_t session, gnutls_datum_t session_entry</var>)<var><a name="index-gnutls_005fdb_005fcheck_005fentry-149"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>session_entry</var>: is the session data (not key)

     <p>Check if database entry has expired.  This function is to be used
when you want to clear unnesessary session which occupy space in
your backend.

     <p><strong>Returns:</strong> Returns <code>GNUTLS_E_EXPIRED</code>, if the database entry has
expired or 0 otherwise. 
</p></blockquote></div>

<h4 class="subheading">gnutls_db_get_ptr</h4>

<p><a name="gnutls_005fdb_005fget_005fptr"></a>

<div class="defun">
&mdash; Function: void * <b>gnutls_db_get_ptr</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fdb_005fget_005fptr-150"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>Get db function pointer.

     <p><strong>Returns:</strong> the pointer that will be sent to db store, retrieve and
delete functions, as the first argument. 
</p></blockquote></div>

<h4 class="subheading">gnutls_db_remove_session</h4>

<p><a name="gnutls_005fdb_005fremove_005fsession"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_db_remove_session</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fdb_005fremove_005fsession-151"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>This function will remove the current session data from the
session database.  This will prevent future handshakes reusing
these session data.  This function should be called if a session
was terminated abnormally, and before <code>gnutls_deinit()</code> is called.

     <p>Normally <code>gnutls_deinit()</code> will remove abnormally terminated
sessions. 
</p></blockquote></div>

<h4 class="subheading">gnutls_db_set_cache_expiration</h4>

<p><a name="gnutls_005fdb_005fset_005fcache_005fexpiration"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_db_set_cache_expiration</b> (<var>gnutls_session_t session, int seconds</var>)<var><a name="index-gnutls_005fdb_005fset_005fcache_005fexpiration-152"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>seconds</var>: is the number of seconds.

     <p>Set the expiration time for resumed sessions. The default is 3600
(one hour) at the time writing this. 
</p></blockquote></div>

<h4 class="subheading">gnutls_db_set_ptr</h4>

<p><a name="gnutls_005fdb_005fset_005fptr"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_db_set_ptr</b> (<var>gnutls_session_t session, void * ptr</var>)<var><a name="index-gnutls_005fdb_005fset_005fptr-153"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>ptr</var>: is the pointer

     <p>Sets the pointer that will be provided to db store, retrieve and
delete functions, as the first argument. 
</p></blockquote></div>

<h4 class="subheading">gnutls_db_set_remove_function</h4>

<p><a name="gnutls_005fdb_005fset_005fremove_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_db_set_remove_function</b> (<var>gnutls_session_t session, gnutls_db_remove_func rem_func</var>)<var><a name="index-gnutls_005fdb_005fset_005fremove_005ffunction-154"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>rem_func</var>: is the function.

     <p>Sets the function that will be used to remove data from the
resumed sessions database. This function must return 0 on success.

     <p>The first argument to  <code>rem_func</code>will be null unless
<code>gnutls_db_set_ptr()</code> has been called. 
</p></blockquote></div>

<h4 class="subheading">gnutls_db_set_retrieve_function</h4>

<p><a name="gnutls_005fdb_005fset_005fretrieve_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_db_set_retrieve_function</b> (<var>gnutls_session_t session, gnutls_db_retr_func retr_func</var>)<var><a name="index-gnutls_005fdb_005fset_005fretrieve_005ffunction-155"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>retr_func</var>: is the function.

     <p>Sets the function that will be used to retrieve data from the
resumed sessions database.  This function must return a
gnutls_datum_t containing the data on success, or a gnutls_datum_t
containing null and 0 on failure.

     <p>The datum's data must be allocated using the function
<code>gnutls_malloc()</code>.

     <p>The first argument to  <code>retr_func</code>will be null unless
<code>gnutls_db_set_ptr()</code> has been called. 
</p></blockquote></div>

<h4 class="subheading">gnutls_db_set_store_function</h4>

<p><a name="gnutls_005fdb_005fset_005fstore_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_db_set_store_function</b> (<var>gnutls_session_t session, gnutls_db_store_func store_func</var>)<var><a name="index-gnutls_005fdb_005fset_005fstore_005ffunction-156"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>store_func</var>: is the function

     <p>Sets the function that will be used to store data from the resumed
sessions database. This function must remove 0 on success.

     <p>The first argument to  <code>store_func</code>will be null unless
<code>gnutls_db_set_ptr()</code> has been called. 
</p></blockquote></div>

<h4 class="subheading">gnutls_deinit</h4>

<p><a name="gnutls_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_deinit</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fdeinit-157"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>This function clears all buffers associated with the  <code>session</code>. 
This function will also remove session data from the session
database if the session was terminated abnormally. 
</p></blockquote></div>

<h4 class="subheading">gnutls_dh_get_group</h4>

<p><a name="gnutls_005fdh_005fget_005fgroup"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_dh_get_group</b> (<var>gnutls_session_t session, gnutls_datum_t * raw_gen, gnutls_datum_t * raw_prime</var>)<var><a name="index-gnutls_005fdh_005fget_005fgroup-158"></a></var><br>
<blockquote><p><var>session</var>: is a gnutls session

     <p><var>raw_gen</var>: will hold the generator.

     <p><var>raw_prime</var>: will hold the prime.

     <p>This function will return the group parameters used in the last
Diffie-Hellman key exchange with the peer.  These are the prime and
the generator used.  This function should be used for both
anonymous and ephemeral Diffie-Hellman.  The output parameters must
be freed with <code>gnutls_free()</code>.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise
an error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_dh_get_peers_public_bits</h4>

<p><a name="gnutls_005fdh_005fget_005fpeers_005fpublic_005fbits"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_dh_get_peers_public_bits</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fdh_005fget_005fpeers_005fpublic_005fbits-159"></a></var><br>
<blockquote><p><var>session</var>: is a gnutls session

     <p>Get the Diffie-Hellman public key bit size.  Can be used for both
anonymous and ephemeral Diffie-Hellman.

     <p><strong>Returns:</strong> The public key bit size used in the last Diffie-Hellman
key exchange with the peer, or a negative error code in case of error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_dh_get_prime_bits</h4>

<p><a name="gnutls_005fdh_005fget_005fprime_005fbits"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_dh_get_prime_bits</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fdh_005fget_005fprime_005fbits-160"></a></var><br>
<blockquote><p><var>session</var>: is a gnutls session

     <p>This function will return the bits of the prime used in the last
Diffie-Hellman key exchange with the peer.  Should be used for both
anonymous and ephemeral Diffie-Hellman.  Note that some ciphers,
like RSA and DSA without DHE, does not use a Diffie-Hellman key
exchange, and then this function will return 0.

     <p><strong>Returns:</strong> The Diffie-Hellman bit strength is returned, or 0 if no
Diffie-Hellman key exchange was done, or a negative error code on
failure. 
</p></blockquote></div>

<h4 class="subheading">gnutls_dh_get_pubkey</h4>

<p><a name="gnutls_005fdh_005fget_005fpubkey"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_dh_get_pubkey</b> (<var>gnutls_session_t session, gnutls_datum_t * raw_key</var>)<var><a name="index-gnutls_005fdh_005fget_005fpubkey-161"></a></var><br>
<blockquote><p><var>session</var>: is a gnutls session

     <p><var>raw_key</var>: will hold the public key.

     <p>This function will return the peer's public key used in the last
Diffie-Hellman key exchange.  This function should be used for both
anonymous and ephemeral Diffie-Hellman.  The output parameters must
be freed with <code>gnutls_free()</code>.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise
an error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_dh_get_secret_bits</h4>

<p><a name="gnutls_005fdh_005fget_005fsecret_005fbits"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_dh_get_secret_bits</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fdh_005fget_005fsecret_005fbits-162"></a></var><br>
<blockquote><p><var>session</var>: is a gnutls session

     <p>This function will return the bits used in the last Diffie-Hellman
key exchange with the peer.  Should be used for both anonymous and
ephemeral Diffie-Hellman.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise
an error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_dh_params_cpy</h4>

<p><a name="gnutls_005fdh_005fparams_005fcpy"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_dh_params_cpy</b> (<var>gnutls_dh_params_t dst, gnutls_dh_params_t src</var>)<var><a name="index-gnutls_005fdh_005fparams_005fcpy-163"></a></var><br>
<blockquote><p><var>dst</var>: Is the destination structure, which should be initialized.

     <p><var>src</var>: Is the source structure

     <p>This function will copy the DH parameters structure from source
to destination.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned,
otherwise a negative error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_dh_params_deinit</h4>

<p><a name="gnutls_005fdh_005fparams_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_dh_params_deinit</b> (<var>gnutls_dh_params_t dh_params</var>)<var><a name="index-gnutls_005fdh_005fparams_005fdeinit-164"></a></var><br>
<blockquote><p><var>dh_params</var>: Is a structure that holds the prime numbers

     <p>This function will deinitialize the DH parameters structure. 
</p></blockquote></div>

<h4 class="subheading">gnutls_dh_params_export_pkcs3</h4>

<p><a name="gnutls_005fdh_005fparams_005fexport_005fpkcs3"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_dh_params_export_pkcs3</b> (<var>gnutls_dh_params_t params, gnutls_x509_crt_fmt_t format, unsigned char * params_data, size_t * params_data_size</var>)<var><a name="index-gnutls_005fdh_005fparams_005fexport_005fpkcs3-165"></a></var><br>
<blockquote><p><var>params</var>: Holds the DH parameters

     <p><var>format</var>: the format of output params. One of PEM or DER.

     <p><var>params_data</var>: will contain a PKCS3 DHParams structure PEM or DER encoded

     <p><var>params_data_size</var>: holds the size of params_data (and will be replaced by the actual size of parameters)

     <p>This function will export the given dh parameters to a PKCS3
DHParams structure. This is the format generated by "openssl dhparam" tool. 
If the buffer provided is not long enough to hold the output, then
GNUTLS_E_SHORT_MEMORY_BUFFER will be returned.

     <p>If the structure is PEM encoded, it will have a header
of "BEGIN DH PARAMETERS".

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned,
otherwise a negative error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_dh_params_export_raw</h4>

<p><a name="gnutls_005fdh_005fparams_005fexport_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_dh_params_export_raw</b> (<var>gnutls_dh_params_t params, gnutls_datum_t * prime, gnutls_datum_t * generator, unsigned int * bits</var>)<var><a name="index-gnutls_005fdh_005fparams_005fexport_005fraw-166"></a></var><br>
<blockquote><p><var>params</var>: Holds the DH parameters

     <p><var>prime</var>: will hold the new prime

     <p><var>generator</var>: will hold the new generator

     <p><var>bits</var>: if non null will hold the secret key's number of bits

     <p>This function will export the pair of prime and generator for use
in the Diffie-Hellman key exchange.  The new parameters will be
allocated using <code>gnutls_malloc()</code> and will be stored in the
appropriate datum.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned,
otherwise a negative error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_dh_params_generate2</h4>

<p><a name="gnutls_005fdh_005fparams_005fgenerate2"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_dh_params_generate2</b> (<var>gnutls_dh_params_t params, unsigned int bits</var>)<var><a name="index-gnutls_005fdh_005fparams_005fgenerate2-167"></a></var><br>
<blockquote><p><var>params</var>: Is the structure that the DH parameters will be stored

     <p><var>bits</var>: is the prime's number of bits

     <p>This function will generate a new pair of prime and generator for use in
the Diffie-Hellman key exchange. The new parameters will be allocated using
<code>gnutls_malloc()</code> and will be stored in the appropriate datum. 
This function is normally slow.

     <p>Do not set the number of bits directly, use <code>gnutls_sec_param_to_pk_bits()</code> to
get bits for <code>GNUTLS_PK_DSA</code>. 
Also note that the DH parameters are only useful to servers. 
Since clients use the parameters sent by the server, it's of
no use to call this in client side.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned,
otherwise a negative error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_dh_params_import_pkcs3</h4>

<p><a name="gnutls_005fdh_005fparams_005fimport_005fpkcs3"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_dh_params_import_pkcs3</b> (<var>gnutls_dh_params_t params, const gnutls_datum_t * pkcs3_params, gnutls_x509_crt_fmt_t format</var>)<var><a name="index-gnutls_005fdh_005fparams_005fimport_005fpkcs3-168"></a></var><br>
<blockquote><p><var>params</var>: A structure where the parameters will be copied to

     <p><var>pkcs3_params</var>: should contain a PKCS3 DHParams structure PEM or DER encoded

     <p><var>format</var>: the format of params. PEM or DER.

     <p>This function will extract the DHParams found in a PKCS3 formatted
structure. This is the format generated by "openssl dhparam" tool.

     <p>If the structure is PEM encoded, it should have a header
of "BEGIN DH PARAMETERS".

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned,
otherwise a negative error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_dh_params_import_raw</h4>

<p><a name="gnutls_005fdh_005fparams_005fimport_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_dh_params_import_raw</b> (<var>gnutls_dh_params_t dh_params, const gnutls_datum_t * prime, const gnutls_datum_t * generator</var>)<var><a name="index-gnutls_005fdh_005fparams_005fimport_005fraw-169"></a></var><br>
<blockquote><p><var>dh_params</var>: Is a structure that will hold the prime numbers

     <p><var>prime</var>: holds the new prime

     <p><var>generator</var>: holds the new generator

     <p>This function will replace the pair of prime and generator for use
in the Diffie-Hellman key exchange.  The new parameters should be
stored in the appropriate gnutls_datum.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned,
otherwise a negative error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_dh_params_init</h4>

<p><a name="gnutls_005fdh_005fparams_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_dh_params_init</b> (<var>gnutls_dh_params_t * dh_params</var>)<var><a name="index-gnutls_005fdh_005fparams_005finit-170"></a></var><br>
<blockquote><p><var>dh_params</var>: Is a structure that will hold the prime numbers

     <p>This function will initialize the DH parameters structure.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned,
otherwise a negative error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_dh_set_prime_bits</h4>

<p><a name="gnutls_005fdh_005fset_005fprime_005fbits"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_dh_set_prime_bits</b> (<var>gnutls_session_t session, unsigned int bits</var>)<var><a name="index-gnutls_005fdh_005fset_005fprime_005fbits-171"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>bits</var>: is the number of bits

     <p>This function sets the number of bits, for use in an Diffie-Hellman
key exchange.  This is used both in DH ephemeral and DH anonymous
cipher suites.  This will set the minimum size of the prime that
will be used for the handshake.

     <p>In the client side it sets the minimum accepted number of bits.  If
a server sends a prime with less bits than that
<code>GNUTLS_E_DH_PRIME_UNACCEPTABLE</code> will be returned by the handshake.

     <p>This function has no effect in server side. 
</p></blockquote></div>

<h4 class="subheading">gnutls_ecc_curve_get</h4>

<p><a name="gnutls_005fecc_005fcurve_005fget"></a>

<div class="defun">
&mdash; Function: gnutls_ecc_curve_t <b>gnutls_ecc_curve_get</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fecc_005fcurve_005fget-172"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>Returns the currently used elliptic curve. Only valid
when using an elliptic curve ciphersuite.

     <p><strong>Returns:</strong> the currently used curve, a <code>gnutls_ecc_curve_t</code>
type.

     <p><strong>Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_ecc_curve_get_name</h4>

<p><a name="gnutls_005fecc_005fcurve_005fget_005fname"></a>

<div class="defun">
&mdash; Function: const char * <b>gnutls_ecc_curve_get_name</b> (<var>gnutls_ecc_curve_t curve</var>)<var><a name="index-gnutls_005fecc_005fcurve_005fget_005fname-173"></a></var><br>
<blockquote><p><var>curve</var>: is an ECC curve

     <p>Convert a <code>gnutls_ecc_curve_t</code> value to a string.

     <p><strong>Returns:</strong> a string that contains the name of the specified
curve or <code>NULL</code>.

     <p><strong>Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_ecc_curve_get_size</h4>

<p><a name="gnutls_005fecc_005fcurve_005fget_005fsize"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_ecc_curve_get_size</b> (<var>gnutls_ecc_curve_t curve</var>)<var><a name="index-gnutls_005fecc_005fcurve_005fget_005fsize-174"></a></var><br>
<blockquote><p><var>curve</var>: is an ECC curve

     <p>Returns the size in bytes of the curve.

     <p><strong>Returns:</strong> a the size or (0).

     <p><strong>Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_error_is_fatal</h4>

<p><a name="gnutls_005ferror_005fis_005ffatal"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_error_is_fatal</b> (<var>int error</var>)<var><a name="index-gnutls_005ferror_005fis_005ffatal-175"></a></var><br>
<blockquote><p><var>error</var>: is a GnuTLS error code, a negative error code

     <p>If a GnuTLS function returns a negative error code you may feed that
value to this function to see if the error condition is fatal. 
Note that you may also want to check the error code manually, since some
non-fatal errors to the protocol (such as a warning alert or
a rehandshake request) may be fatal for your program.

     <p>This function is only useful if you are dealing with errors from
the record layer or the handshake layer.

     <p><strong>Returns:</strong> 1 if the error code is fatal, for positive  <code>error</code>values,
0 is returned.  For unknown  <code>error</code>values, -1 is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_error_to_alert</h4>

<p><a name="gnutls_005ferror_005fto_005falert"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_error_to_alert</b> (<var>int err, int * level</var>)<var><a name="index-gnutls_005ferror_005fto_005falert-176"></a></var><br>
<blockquote><p><var>err</var>: is a negative integer

     <p><var>level</var>: the alert level will be stored there

     <p>Get an alert depending on the error code returned by a gnutls
function.  All alerts sent by this function should be considered
fatal.  The only exception is when  <code>err</code>is <code>GNUTLS_E_REHANDSHAKE</code>,
where a warning alert should be sent to the peer indicating that no
renegotiation will be performed.

     <p>If there is no mapping to a valid alert the alert to indicate
internal error is returned.

     <p><strong>Returns:</strong> the alert code to use for a particular error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_fingerprint</h4>

<p><a name="gnutls_005ffingerprint"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_fingerprint</b> (<var>gnutls_digest_algorithm_t algo, const gnutls_datum_t * data, void * result, size_t * result_size</var>)<var><a name="index-gnutls_005ffingerprint-177"></a></var><br>
<blockquote><p><var>algo</var>: is a digest algorithm

     <p><var>data</var>: is the data

     <p><var>result</var>: is the place where the result will be copied (may be null).

     <p><var>result_size</var>: should hold the size of the result. The actual size
of the returned result will also be copied there.

     <p>This function will calculate a fingerprint (actually a hash), of
the given data.  The result is not printable data.  You should
convert it to hex, or to something else printable.

     <p>This is the usual way to calculate a fingerprint of an X.509 DER
encoded certificate.  Note however that the fingerprint of an
OpenPGP is not just a hash and cannot be calculated with this
function.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise
an error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_global_deinit</h4>

<p><a name="gnutls_005fglobal_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_global_deinit</b> (<var> void</var>)<var><a name="index-gnutls_005fglobal_005fdeinit-178"></a></var><br>
<blockquote>
     <p>This function deinitializes the global data, that were initialized
using <code>gnutls_global_init()</code>.

     <p>Note!  This function is not thread safe.  See the discussion for
<code>gnutls_global_init()</code> for more information. 
</p></blockquote></div>

<h4 class="subheading">gnutls_global_init</h4>

<p><a name="gnutls_005fglobal_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_global_init</b> (<var> void</var>)<var><a name="index-gnutls_005fglobal_005finit-179"></a></var><br>
<blockquote>
     <p>This function initializes the global data to defaults.  Every
gnutls application has a global data which holds common parameters
shared by gnutls session structures.  You should call
<code>gnutls_global_deinit()</code> when gnutls usage is no longer needed

     <p>Note that this function will also initialize the underlying crypto
backend, if it has not been initialized before.

     <p>This function increment a global counter, so that
<code>gnutls_global_deinit()</code> only releases resources when it has been
called as many times as <code>gnutls_global_init()</code>.  This is useful when
GnuTLS is used by more than one library in an application.  This
function can be called many times, but will only do something the
first time.

     <p>Note!  This function is not thread safe.  If two threads call this
function simultaneously, they can cause a race between checking
the global counter and incrementing it, causing both threads to
execute the library initialization code.  That would lead to a
memory leak.  To handle this, your application could invoke this
function after aquiring a thread mutex.  To ignore the potential
memory leak is also an option.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned,
otherwise a negative error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_global_set_audit_log_function</h4>

<p><a name="gnutls_005fglobal_005fset_005faudit_005flog_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_global_set_audit_log_function</b> (<var>gnutls_audit_log_func log_func</var>)<var><a name="index-gnutls_005fglobal_005fset_005faudit_005flog_005ffunction-180"></a></var><br>
<blockquote><p><var>log_func</var>: it is the audit log function

     <p>This is the function where you set the logging function gnutls is
going to use.  This is different from <code>gnutls_global_set_log_function()</code>
because it will report the session of the event if any. Note that
that session might be null if there is no corresponding TLS session.

     <p><code>gnutls_audit_log_func</code>is of the form,
void (*gnutls_audit_log_func)( gnutls_session_t, int level, const char*);

     <p><strong>Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_global_set_log_function</h4>

<p><a name="gnutls_005fglobal_005fset_005flog_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_global_set_log_function</b> (<var>gnutls_log_func log_func</var>)<var><a name="index-gnutls_005fglobal_005fset_005flog_005ffunction-181"></a></var><br>
<blockquote><p><var>log_func</var>: it's a log function

     <p>This is the function where you set the logging function gnutls is
going to use.  This function only accepts a character array. 
Normally you may not use this function since it is only used for
debugging purposes.

     <p><code>gnutls_log_func</code>is of the form,
void (*gnutls_log_func)( int level, const char*);
</p></blockquote></div>

<h4 class="subheading">gnutls_global_set_log_level</h4>

<p><a name="gnutls_005fglobal_005fset_005flog_005flevel"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_global_set_log_level</b> (<var>int level</var>)<var><a name="index-gnutls_005fglobal_005fset_005flog_005flevel-182"></a></var><br>
<blockquote><p><var>level</var>: it's an integer from 0 to 9.

     <p>This is the function that allows you to set the log level.  The
level is an integer between 0 and 9.  Higher values mean more
verbosity. The default value is 0.  Larger values should only be
used with care, since they may reveal sensitive information.

     <p>Use a log level over 10 to enable all debugging options. 
</p></blockquote></div>

<h4 class="subheading">gnutls_global_set_mem_functions</h4>

<p><a name="gnutls_005fglobal_005fset_005fmem_005ffunctions"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_global_set_mem_functions</b> (<var>gnutls_alloc_function alloc_func, gnutls_alloc_function secure_alloc_func, gnutls_is_secure_function is_secure_func, gnutls_realloc_function realloc_func, gnutls_free_function free_func</var>)<var><a name="index-gnutls_005fglobal_005fset_005fmem_005ffunctions-183"></a></var><br>
<blockquote><p><var>alloc_func</var>: it's the default memory allocation function. Like <code>malloc()</code>.

     <p><var>secure_alloc_func</var>: This is the memory allocation function that will be used for sensitive data.

     <p><var>is_secure_func</var>: a function that returns 0 if the memory given is not secure. May be NULL.

     <p><var>realloc_func</var>: A realloc function

     <p><var>free_func</var>: The function that frees allocated data. Must accept a NULL pointer.

     <p>This is the function were you set the memory allocation functions
gnutls is going to use. By default the libc's allocation functions
(<code>malloc()</code>, <code>free()</code>), are used by gnutls, to allocate both sensitive
and not sensitive data.  This function is provided to set the
memory allocation functions to something other than the defaults

     <p>This function must be called before <code>gnutls_global_init()</code> is called. 
This function is not thread safe. 
</p></blockquote></div>

<h4 class="subheading">gnutls_global_set_mutex</h4>

<p><a name="gnutls_005fglobal_005fset_005fmutex"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_global_set_mutex</b> (<var>mutex_init_func init, mutex_deinit_func deinit, mutex_lock_func lock, mutex_unlock_func unlock</var>)<var><a name="index-gnutls_005fglobal_005fset_005fmutex-184"></a></var><br>
<blockquote><p><var>init</var>: mutex initialization function

     <p><var>deinit</var>: mutex deinitialization function

     <p><var>lock</var>: mutex locking function

     <p><var>unlock</var>: mutex unlocking function

     <p>With this function you are allowed to override the default mutex
locks used in some parts of gnutls and dependent libraries. This function
should be used if you have complete control of your program and libraries. 
Do not call this function from a library. Instead only initialize gnutls and
the default OS mutex locks will be used.

     <p>This function must be called before <code>gnutls_global_init()</code>.

     <p><strong>Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_global_set_time_function</h4>

<p><a name="gnutls_005fglobal_005fset_005ftime_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_global_set_time_function</b> (<var>gnutls_time_func time_func</var>)<var><a name="index-gnutls_005fglobal_005fset_005ftime_005ffunction-185"></a></var><br>
<blockquote><p><var>time_func</var>: it's the system time function, a <code>gnutls_time_func()</code> callback.

     <p>This is the function where you can override the default system time
function.  The application provided function should behave the same
as the standard function.

     <p><strong>Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_handshake</h4>

<p><a name="gnutls_005fhandshake"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_handshake</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fhandshake-186"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>This function does the handshake of the TLS/SSL protocol, and
initializes the TLS connection.

     <p>This function will fail if any problem is encountered, and will
return a negative error code. In case of a client, if the client
has asked to resume a session, but the server couldn't, then a
full handshake will be performed.

     <p>The non-fatal errors such as <code>GNUTLS_E_AGAIN</code> and
<code>GNUTLS_E_INTERRUPTED</code> interrupt the handshake procedure, which
should be later be resumed.  Call this function again, until it
returns 0; cf.  <code>gnutls_record_get_direction()</code> and
<code>gnutls_error_is_fatal()</code>.

     <p>If this function is called by a server after a rehandshake request
then <code>GNUTLS_E_GOT_APPLICATION_DATA</code> or
<code>GNUTLS_E_WARNING_ALERT_RECEIVED</code> may be returned.  Note that these
are non fatal errors, only in the specific case of a rehandshake. 
Their meaning is that the client rejected the rehandshake request or
in the case of <code>GNUTLS_E_GOT_APPLICATION_DATA</code> it might also mean that
some data were pending.

     <p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, otherwise a negative error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_handshake_get_last_in</h4>

<p><a name="gnutls_005fhandshake_005fget_005flast_005fin"></a>

<div class="defun">
&mdash; Function: gnutls_handshake_description_t <b>gnutls_handshake_get_last_in</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fhandshake_005fget_005flast_005fin-187"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>This function is only useful to check where the last performed
handshake failed.  If the previous handshake succeed or was not
performed at all then no meaningful value will be returned.

     <p>Check <code>gnutls_handshake_description_t</code> in gnutls.h for the
available handshake descriptions.

     <p><strong>Returns:</strong> the last handshake message type received, a
<code>gnutls_handshake_description_t</code>. 
</p></blockquote></div>

<h4 class="subheading">gnutls_handshake_get_last_out</h4>

<p><a name="gnutls_005fhandshake_005fget_005flast_005fout"></a>

<div class="defun">
&mdash; Function: gnutls_handshake_description_t <b>gnutls_handshake_get_last_out</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fhandshake_005fget_005flast_005fout-188"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>This function is only useful to check where the last performed
handshake failed.  If the previous handshake succeed or was not
performed at all then no meaningful value will be returned.

     <p>Check <code>gnutls_handshake_description_t</code> in gnutls.h for the
available handshake descriptions.

     <p><strong>Returns:</strong> the last handshake message type sent, a
<code>gnutls_handshake_description_t</code>. 
</p></blockquote></div>

<h4 class="subheading">gnutls_handshake_set_max_packet_length</h4>

<p><a name="gnutls_005fhandshake_005fset_005fmax_005fpacket_005flength"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_handshake_set_max_packet_length</b> (<var>gnutls_session_t session, size_t max</var>)<var><a name="index-gnutls_005fhandshake_005fset_005fmax_005fpacket_005flength-189"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>max</var>: is the maximum number.

     <p>This function will set the maximum size of all handshake messages. 
Handshakes over this size are rejected with
<code>GNUTLS_E_HANDSHAKE_TOO_LARGE</code> error code.  The default value is
48kb which is typically large enough.  Set this to 0 if you do not
want to set an upper limit.

     <p>The reason for restricting the handshake message sizes are to
limit Denial of Service attacks. 
</p></blockquote></div>

<h4 class="subheading">gnutls_handshake_set_post_client_hello_function</h4>

<p><a name="gnutls_005fhandshake_005fset_005fpost_005fclient_005fhello_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_handshake_set_post_client_hello_function</b> (<var>gnutls_session_t session, gnutls_handshake_post_client_hello_func func</var>)<var><a name="index-gnutls_005fhandshake_005fset_005fpost_005fclient_005fhello_005ffunction-190"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>func</var>: is the function to be called

     <p>This function will set a callback to be called after the client
hello has been received (callback valid in server side only). This
allows the server to adjust settings based on received extensions.

     <p>Those settings could be ciphersuites, requesting certificate, or
anything else except for version negotiation (this is done before
the hello message is parsed).

     <p>This callback must return 0 on success or a gnutls error code to
terminate the handshake.

     <p><strong>Warning:</strong> You should not use this function to terminate the
handshake based on client input unless you know what you are
doing. Before the handshake is finished there is no way to know if
there is a man-in-the-middle attack being performed. 
</p></blockquote></div>

<h4 class="subheading">gnutls_handshake_set_private_extensions</h4>

<p><a name="gnutls_005fhandshake_005fset_005fprivate_005fextensions"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_handshake_set_private_extensions</b> (<var>gnutls_session_t session, int allow</var>)<var><a name="index-gnutls_005fhandshake_005fset_005fprivate_005fextensions-191"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>allow</var>: is an integer (0 or 1)

     <p>This function will enable or disable the use of private cipher
suites (the ones that start with 0xFF).  By default or if  <code>allow</code>is 0 then these cipher suites will not be advertized nor used.

     <p>Currently GnuTLS does not include such cipher-suites or
compression algorithms.

     <p>Enabling the private ciphersuites when talking to other than
gnutls servers and clients may cause interoperability problems. 
</p></blockquote></div>

<h4 class="subheading">gnutls_hex2bin</h4>

<p><a name="gnutls_005fhex2bin"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_hex2bin</b> (<var>const char * hex_data, size_t hex_size, char * bin_data, size_t * bin_size</var>)<var><a name="index-gnutls_005fhex2bin-192"></a></var><br>
<blockquote><p><var>hex_data</var>: string with data in hex format

     <p><var>hex_size</var>: size of hex data

     <p><var>bin_data</var>: output array with binary data

     <p><var>bin_size</var>: when calling should hold maximum size of  <code>bin_data</code>,
on return will hold actual length of  <code>bin_data</code>.

     <p>Convert a buffer with hex data to binary data.

     <p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, otherwise a negative error code.

     <p><strong>Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_hex_decode</h4>

<p><a name="gnutls_005fhex_005fdecode"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_hex_decode</b> (<var>const gnutls_datum_t * hex_data, char * result, size_t * result_size</var>)<var><a name="index-gnutls_005fhex_005fdecode-193"></a></var><br>
<blockquote><p><var>hex_data</var>: contain the encoded data

     <p><var>result</var>: the place where decoded data will be copied

     <p><var>result_size</var>: holds the size of the result

     <p>This function will decode the given encoded data, using the hex
encoding used by PSK password files.

     <p>Note that hex_data should be null terminated.

     <p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> if the buffer given is not
long enough, or 0 on success. 
</p></blockquote></div>

<h4 class="subheading">gnutls_hex_encode</h4>

<p><a name="gnutls_005fhex_005fencode"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_hex_encode</b> (<var>const gnutls_datum_t * data, char * result, size_t * result_size</var>)<var><a name="index-gnutls_005fhex_005fencode-194"></a></var><br>
<blockquote><p><var>data</var>: contain the raw data

     <p><var>result</var>: the place where hex data will be copied

     <p><var>result_size</var>: holds the size of the result

     <p>This function will convert the given data to printable data, using
the hex encoding, as used in the PSK password files.

     <p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> if the buffer given is not
long enough, or 0 on success. 
</p></blockquote></div>

<h4 class="subheading">gnutls_init</h4>

<p><a name="gnutls_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_init</b> (<var>gnutls_session_t * session, unsigned int flags</var>)<var><a name="index-gnutls_005finit-195"></a></var><br>
<blockquote><p><var>session</var>: is a pointer to a <code>gnutls_session_t</code> structure.

     <p><var>flags</var>: indicate if this session is to be used for server or client.

     <p>This function initializes the current session to null. Every
session must be initialized before use, so internal structures can
be allocated.  This function allocates structures which can only
be free'd by calling <code>gnutls_deinit()</code>.  Returns <code>GNUTLS_E_SUCCESS</code> (0) on success.

     <p><code>flags</code>can be one of <code>GNUTLS_CLIENT</code> and <code>GNUTLS_SERVER</code>. For a DTLS
entity, the flags <code>GNUTLS_DATAGRAM</code> and  <code>GNUTLS_NONBLOCK</code> are
also available. The latter flag will enable a non-blocking
operation of the DTLS timers.

     <p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_key_generate</h4>

<p><a name="gnutls_005fkey_005fgenerate"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_key_generate</b> (<var>gnutls_datum_t * key, unsigned int key_size</var>)<var><a name="index-gnutls_005fkey_005fgenerate-196"></a></var><br>
<blockquote><p><var>key</var>: is a pointer to a <code>gnutls_datum_t</code> which will contain a newly
created key.

     <p><var>key_size</var>: The number of bytes of the key.

     <p>Generates a random key of  <code>key_bytes</code>size.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, or an
error code.

     <p><strong>Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_kx_get</h4>

<p><a name="gnutls_005fkx_005fget"></a>

<div class="defun">
&mdash; Function: gnutls_kx_algorithm_t <b>gnutls_kx_get</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fkx_005fget-197"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>Get currently used key exchange algorithm.

     <p><strong>Returns:</strong> the key exchange algorithm used in the last handshake, a
<code>gnutls_kx_algorithm_t</code> value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_kx_get_id</h4>

<p><a name="gnutls_005fkx_005fget_005fid"></a>

<div class="defun">
&mdash; Function: gnutls_kx_algorithm_t <b>gnutls_kx_get_id</b> (<var>const char * name</var>)<var><a name="index-gnutls_005fkx_005fget_005fid-198"></a></var><br>
<blockquote><p><var>name</var>: is a KX name

     <p>Convert a string to a <code>gnutls_kx_algorithm_t</code> value.  The names are
compared in a case insensitive way.

     <p><strong>Returns:</strong> an id of the specified KX algorithm, or <code>GNUTLS_KX_UNKNOWN</code>
on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_kx_get_name</h4>

<p><a name="gnutls_005fkx_005fget_005fname"></a>

<div class="defun">
&mdash; Function: const char * <b>gnutls_kx_get_name</b> (<var>gnutls_kx_algorithm_t algorithm</var>)<var><a name="index-gnutls_005fkx_005fget_005fname-199"></a></var><br>
<blockquote><p><var>algorithm</var>: is a key exchange algorithm

     <p>Convert a <code>gnutls_kx_algorithm_t</code> value to a string.

     <p><strong>Returns:</strong> a pointer to a string that contains the name of the
specified key exchange algorithm, or <code>NULL</code>. 
</p></blockquote></div>

<h4 class="subheading">gnutls_kx_list</h4>

<p><a name="gnutls_005fkx_005flist"></a>

<div class="defun">
&mdash; Function: const gnutls_kx_algorithm_t * <b>gnutls_kx_list</b> (<var> void</var>)<var><a name="index-gnutls_005fkx_005flist-200"></a></var><br>
<blockquote>
     <p>Get a list of supported key exchange algorithms.

     <p>This function is not thread safe.

     <p><strong>Returns:</strong> a (0)-terminated list of <code>gnutls_kx_algorithm_t</code> integers
indicating the available key exchange algorithms. 
</p></blockquote></div>

<h4 class="subheading">gnutls_mac_get</h4>

<p><a name="gnutls_005fmac_005fget"></a>

<div class="defun">
&mdash; Function: gnutls_mac_algorithm_t <b>gnutls_mac_get</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fmac_005fget-201"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>Get currently used MAC algorithm.

     <p><strong>Returns:</strong> the currently used mac algorithm, a
<code>gnutls_mac_algorithm_t</code> value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_mac_get_id</h4>

<p><a name="gnutls_005fmac_005fget_005fid"></a>

<div class="defun">
&mdash; Function: gnutls_mac_algorithm_t <b>gnutls_mac_get_id</b> (<var>const char * name</var>)<var><a name="index-gnutls_005fmac_005fget_005fid-202"></a></var><br>
<blockquote><p><var>name</var>: is a MAC algorithm name

     <p>Convert a string to a <code>gnutls_mac_algorithm_t</code> value.  The names are
compared in a case insensitive way.

     <p><strong>Returns:</strong> a <code>gnutls_mac_algorithm_t</code> id of the specified MAC
algorithm string, or <code>GNUTLS_MAC_UNKNOWN</code> on failures. 
</p></blockquote></div>

<h4 class="subheading">gnutls_mac_get_key_size</h4>

<p><a name="gnutls_005fmac_005fget_005fkey_005fsize"></a>

<div class="defun">
&mdash; Function: size_t <b>gnutls_mac_get_key_size</b> (<var>gnutls_mac_algorithm_t algorithm</var>)<var><a name="index-gnutls_005fmac_005fget_005fkey_005fsize-203"></a></var><br>
<blockquote><p><var>algorithm</var>: is an encryption algorithm

     <p>Get size of MAC key.

     <p><strong>Returns:</strong> length (in bytes) of the given MAC key size, or 0 if the
given MAC algorithm is invalid. 
</p></blockquote></div>

<h4 class="subheading">gnutls_mac_get_name</h4>

<p><a name="gnutls_005fmac_005fget_005fname"></a>

<div class="defun">
&mdash; Function: const char * <b>gnutls_mac_get_name</b> (<var>gnutls_mac_algorithm_t algorithm</var>)<var><a name="index-gnutls_005fmac_005fget_005fname-204"></a></var><br>
<blockquote><p><var>algorithm</var>: is a MAC algorithm

     <p>Convert a <code>gnutls_mac_algorithm_t</code> value to a string.

     <p><strong>Returns:</strong> a string that contains the name of the specified MAC
algorithm, or <code>NULL</code>. 
</p></blockquote></div>

<h4 class="subheading">gnutls_mac_list</h4>

<p><a name="gnutls_005fmac_005flist"></a>

<div class="defun">
&mdash; Function: const gnutls_mac_algorithm_t * <b>gnutls_mac_list</b> (<var> void</var>)<var><a name="index-gnutls_005fmac_005flist-205"></a></var><br>
<blockquote>
     <p>Get a list of hash algorithms for use as MACs.  Note that not
necessarily all MACs are supported in TLS cipher suites.  For
example, MD2 is not supported as a cipher suite, but is supported
for other purposes (e.g., X.509 signature verification or similar).

     <p>This function is not thread safe.

     <p><strong>Returns:</strong> Return a (0)-terminated list of <code>gnutls_mac_algorithm_t</code>
integers indicating the available MACs. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_send_cert</h4>

<p><a name="gnutls_005fopenpgp_005fsend_005fcert"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_openpgp_send_cert</b> (<var>gnutls_session_t session, gnutls_openpgp_crt_status_t status</var>)<var><a name="index-gnutls_005fopenpgp_005fsend_005fcert-206"></a></var><br>
<blockquote><p><var>session</var>: is a pointer to a <code>gnutls_session_t</code> structure.

     <p><var>status</var>: is one of GNUTLS_OPENPGP_CERT, or GNUTLS_OPENPGP_CERT_FINGERPRINT

     <p>This function will order gnutls to send the key fingerprint
instead of the key in the initial handshake procedure. This should
be used with care and only when there is indication or knowledge
that the server can obtain the client's key. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pem_base64_decode</h4>

<p><a name="gnutls_005fpem_005fbase64_005fdecode"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pem_base64_decode</b> (<var>const char * header, const gnutls_datum_t * b64_data, unsigned char * result, size_t * result_size</var>)<var><a name="index-gnutls_005fpem_005fbase64_005fdecode-207"></a></var><br>
<blockquote><p><var>header</var>: A null terminated string with the PEM header (eg. CERTIFICATE)

     <p><var>b64_data</var>: contain the encoded data

     <p><var>result</var>: the place where decoded data will be copied

     <p><var>result_size</var>: holds the size of the result

     <p>This function will decode the given encoded data.  If the header
given is non null this function will search for "&mdash;&mdash;BEGIN header"
and decode only this part.  Otherwise it will decode the first PEM
packet found.

     <p><strong>Returns:</strong> On success <code>GNUTLS_E_SUCCESS</code> (0) is returned,
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> is returned if the buffer given is
not long enough, or 0 on success. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pem_base64_decode_alloc</h4>

<p><a name="gnutls_005fpem_005fbase64_005fdecode_005falloc"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pem_base64_decode_alloc</b> (<var>const char * header, const gnutls_datum_t * b64_data, gnutls_datum_t * result</var>)<var><a name="index-gnutls_005fpem_005fbase64_005fdecode_005falloc-208"></a></var><br>
<blockquote><p><var>header</var>: The PEM header (eg. CERTIFICATE)

     <p><var>b64_data</var>: contains the encoded data

     <p><var>result</var>: the place where decoded data lie

     <p>This function will decode the given encoded data. The decoded data
will be allocated, and stored into result.  If the header given is
non null this function will search for "&mdash;&mdash;BEGIN header" and
decode only this part. Otherwise it will decode the first PEM
packet found.

     <p>You should use <code>gnutls_free()</code> to free the returned data.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise
an error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pem_base64_encode</h4>

<p><a name="gnutls_005fpem_005fbase64_005fencode"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pem_base64_encode</b> (<var>const char * msg, const gnutls_datum_t * data, char * result, size_t * result_size</var>)<var><a name="index-gnutls_005fpem_005fbase64_005fencode-209"></a></var><br>
<blockquote><p><var>msg</var>: is a message to be put in the header

     <p><var>data</var>: contain the raw data

     <p><var>result</var>: the place where base64 data will be copied

     <p><var>result_size</var>: holds the size of the result

     <p>This function will convert the given data to printable data, using
the base64 encoding. This is the encoding used in PEM messages.

     <p>The output string will be null terminated, although the size will
not include the terminating null.

     <p><strong>Returns:</strong> On success <code>GNUTLS_E_SUCCESS</code> (0) is returned,
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> is returned if the buffer given is
not long enough, or 0 on success. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pem_base64_encode_alloc</h4>

<p><a name="gnutls_005fpem_005fbase64_005fencode_005falloc"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pem_base64_encode_alloc</b> (<var>const char * msg, const gnutls_datum_t * data, gnutls_datum_t * result</var>)<var><a name="index-gnutls_005fpem_005fbase64_005fencode_005falloc-210"></a></var><br>
<blockquote><p><var>msg</var>: is a message to be put in the encoded header

     <p><var>data</var>: contains the raw data

     <p><var>result</var>: will hold the newly allocated encoded data

     <p>This function will convert the given data to printable data, using
the base64 encoding.  This is the encoding used in PEM messages. 
This function will allocate the required memory to hold the encoded
data.

     <p>You should use <code>gnutls_free()</code> to free the returned data.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise
an error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_perror</h4>

<p><a name="gnutls_005fperror"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_perror</b> (<var>int error</var>)<var><a name="index-gnutls_005fperror-211"></a></var><br>
<blockquote><p><var>error</var>: is a GnuTLS error code, a negative error code

     <p>This function is like <code>perror()</code>. The only difference is that it
accepts an error number returned by a gnutls function. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pk_algorithm_get_name</h4>

<p><a name="gnutls_005fpk_005falgorithm_005fget_005fname"></a>

<div class="defun">
&mdash; Function: const char * <b>gnutls_pk_algorithm_get_name</b> (<var>gnutls_pk_algorithm_t algorithm</var>)<var><a name="index-gnutls_005fpk_005falgorithm_005fget_005fname-212"></a></var><br>
<blockquote><p><var>algorithm</var>: is a pk algorithm

     <p>Convert a <code>gnutls_pk_algorithm_t</code> value to a string.

     <p><strong>Returns:</strong> a string that contains the name of the specified public
key algorithm, or <code>NULL</code>. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pk_bits_to_sec_param</h4>

<p><a name="gnutls_005fpk_005fbits_005fto_005fsec_005fparam"></a>

<div class="defun">
&mdash; Function: gnutls_sec_param_t <b>gnutls_pk_bits_to_sec_param</b> (<var>gnutls_pk_algorithm_t algo, unsigned int bits</var>)<var><a name="index-gnutls_005fpk_005fbits_005fto_005fsec_005fparam-213"></a></var><br>
<blockquote><p><var>algo</var>: is a public key algorithm

     <p><var>bits</var>: is the number of bits

     <p>This is the inverse of <code>gnutls_sec_param_to_pk_bits()</code>. Given an algorithm
and the number of bits, it will return the security parameter. This is
a rough indication.

     <p><strong>Returns:</strong> The security parameter.

     <p><strong>Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pk_get_id</h4>

<p><a name="gnutls_005fpk_005fget_005fid"></a>

<div class="defun">
&mdash; Function: gnutls_pk_algorithm_t <b>gnutls_pk_get_id</b> (<var>const char * name</var>)<var><a name="index-gnutls_005fpk_005fget_005fid-214"></a></var><br>
<blockquote><p><var>name</var>: is a string containing a public key algorithm name.

     <p>Convert a string to a <code>gnutls_pk_algorithm_t</code> value.  The names are
compared in a case insensitive way.  For example,
gnutls_pk_get_id("RSA") will return <code>GNUTLS_PK_RSA</code>.

     <p><strong>Returns:</strong> a <code>gnutls_pk_algorithm_t</code> id of the specified public key
algorithm string, or <code>GNUTLS_PK_UNKNOWN</code> on failures.

     <p><strong>Since:</strong> 2.6.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pk_get_name</h4>

<p><a name="gnutls_005fpk_005fget_005fname"></a>

<div class="defun">
&mdash; Function: const char * <b>gnutls_pk_get_name</b> (<var>gnutls_pk_algorithm_t algorithm</var>)<var><a name="index-gnutls_005fpk_005fget_005fname-215"></a></var><br>
<blockquote><p><var>algorithm</var>: is a public key algorithm

     <p>Convert a <code>gnutls_pk_algorithm_t</code> value to a string.

     <p><strong>Returns:</strong> a pointer to a string that contains the name of the
specified public key algorithm, or <code>NULL</code>.

     <p><strong>Since:</strong> 2.6.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pk_list</h4>

<p><a name="gnutls_005fpk_005flist"></a>

<div class="defun">
&mdash; Function: const gnutls_pk_algorithm_t * <b>gnutls_pk_list</b> (<var> void</var>)<var><a name="index-gnutls_005fpk_005flist-216"></a></var><br>
<blockquote>
     <p>Get a list of supported public key algorithms.

     <p>This function is not thread safe.

     <p><strong>Returns:</strong> a (0)-terminated list of <code>gnutls_pk_algorithm_t</code> integers
indicating the available ciphers.

     <p><strong>Since:</strong> 2.6.0
</p></blockquote></div>

<h4 class="subheading">gnutls_prf</h4>

<p><a name="gnutls_005fprf"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_prf</b> (<var>gnutls_session_t session, size_t label_size, const char * label, int server_random_first, size_t extra_size, const char * extra, size_t outsize, char * out</var>)<var><a name="index-gnutls_005fprf-217"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>label_size</var>: length of the  <code>label</code>variable.

     <p><var>label</var>: label used in PRF computation, typically a short string.

     <p><var>server_random_first</var>: non-0 if server random field should be first in seed

     <p><var>extra_size</var>: length of the  <code>extra</code>variable.

     <p><var>extra</var>: optional extra data to seed the PRF with.

     <p><var>outsize</var>: size of pre-allocated output buffer to hold the output.

     <p><var>out</var>: pre-allocate buffer to hold the generated data.

     <p>Apply the TLS Pseudo-Random-Function (PRF) using the master secret
on some data, seeded with the client and server random fields.

     <p>The  <code>label</code>variable usually contain a string denoting the purpose
for the generated data.  The  <code>server_random_first</code>indicate whether
the client random field or the server random field should be first
in the seed.  Non-0 indicate that the server random field is first,
0 that the client random field is first.

     <p>The  <code>extra</code>variable can be used to add more data to the seed, after
the random variables.  It can be used to tie make sure the
generated output is strongly connected to some additional data
(e.g., a string used in user authentication).

     <p>The output is placed in  <code>out</code>, which must be pre-allocated.

     <p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_prf_raw</h4>

<p><a name="gnutls_005fprf_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_prf_raw</b> (<var>gnutls_session_t session, size_t label_size, const char * label, size_t seed_size, const char * seed, size_t outsize, char * out</var>)<var><a name="index-gnutls_005fprf_005fraw-218"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>label_size</var>: length of the  <code>label</code>variable.

     <p><var>label</var>: label used in PRF computation, typically a short string.

     <p><var>seed_size</var>: length of the  <code>seed</code>variable.

     <p><var>seed</var>: optional extra data to seed the PRF with.

     <p><var>outsize</var>: size of pre-allocated output buffer to hold the output.

     <p><var>out</var>: pre-allocate buffer to hold the generated data.

     <p>Apply the TLS Pseudo-Random-Function (PRF) using the master secret
on some data.

     <p>The  <code>label</code>variable usually contain a string denoting the purpose
for the generated data.  The  <code>seed</code>usually contain data such as the
client and server random, perhaps together with some additional
data that is added to guarantee uniqueness of the output for a
particular purpose.

     <p>Because the output is not guaranteed to be unique for a particular
session unless  <code>seed</code>include the client random and server random
fields (the PRF would output the same data on another connection
resumed from the first one), it is not recommended to use this
function directly.  The <code>gnutls_prf()</code> function seed the PRF with the
client and server random fields directly, and is recommended if you
want to generate pseudo random data unique for each session.

     <p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_priority_deinit</h4>

<p><a name="gnutls_005fpriority_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_priority_deinit</b> (<var>gnutls_priority_t priority_cache</var>)<var><a name="index-gnutls_005fpriority_005fdeinit-219"></a></var><br>
<blockquote><p><var>priority_cache</var>: is a <code>gnutls_prioritity_t</code> structure.

     <p>Deinitializes the priority cache. 
</p></blockquote></div>

<h4 class="subheading">gnutls_priority_get_cipher_suite_index</h4>

<p><a name="gnutls_005fpriority_005fget_005fcipher_005fsuite_005findex"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_priority_get_cipher_suite_index</b> (<var>gnutls_priority_t pcache, unsigned int idx, unsigned int * sidx</var>)<var><a name="index-gnutls_005fpriority_005fget_005fcipher_005fsuite_005findex-220"></a></var><br>
<blockquote><p><var>pcache</var>: is a <code>gnutls_prioritity_t</code> structure.

     <p><var>idx</var>: is an index number.

     <p><var>sidx</var>: internal index of cipher suite to get information about.

     <p>Provides the internal ciphersuite index to be used with
<code>gnutls_cipher_suite_info()</code>. The index  <code>idx</code>provided is an
index kept at the priorities structure. It might be that a valid
priorities index does not correspond to a ciphersuite and in
that case <code>GNUTLS_E_UNKNOWN_CIPHER_SUITE</code> will be returned. 
Once the last available index is crossed then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> will be returned.

     <p><strong>Returns:</strong> On success it returns <code>GNUTLS_E_SUCCESS</code> (0), or a negative error value otherwise. 
</p></blockquote></div>

<h4 class="subheading">gnutls_priority_init</h4>

<p><a name="gnutls_005fpriority_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_priority_init</b> (<var>gnutls_priority_t * priority_cache, const char * priorities, const char ** err_pos</var>)<var><a name="index-gnutls_005fpriority_005finit-221"></a></var><br>
<blockquote><p><var>priority_cache</var>: is a <code>gnutls_prioritity_t</code> structure.

     <p><var>priorities</var>: is a string describing priorities

     <p><var>err_pos</var>: In case of an error this will have the position in the string the error occured

     <p>Sets priorities for the ciphers, key exchange methods, macs and
compression methods.

     <p>The <code>priorities</code> option allows you to specify a colon
separated list of the cipher priorities to enable. 
Some keywords are defined to provide quick access
to common preferences.

     <p>"PERFORMANCE" means all the "secure" ciphersuites are enabled,
limited to 128 bit ciphers and sorted by terms of speed
performance.

     <p>"NORMAL" means all "secure" ciphersuites. The 256-bit ciphers are
included as a fallback only.  The ciphers are sorted by security
margin.

     <p>"SECURE128" means all "secure" ciphersuites of security level 128-bit
or more.

     <p>"SECURE192" means all "secure" ciphersuites of security level 192-bit
or more.

     <p>"SUITEB128" means all the NSA SuiteB ciphersuites with security level
of 128.

     <p>"SUITEB192" means all the NSA SuiteB ciphersuites with security level
of 192.

     <p>"EXPORT" means all ciphersuites are enabled, including the
low-security 40 bit ciphers.

     <p>"NONE" means nothing is enabled.  This disables even protocols and
compression methods.

     <p>Special keywords are "!", "-" and "+". 
"!" or "-" appended with an algorithm will remove this algorithm. 
"+" appended with an algorithm will add this algorithm.

     <p>Check the GnuTLS manual section "Priority strings" for detailed
information.

     <p><strong>Examples:</strong>
"NONE:+VERS-TLS-ALL:+MAC-ALL:+RSA:+AES-128-CBC:+SIGN-ALL:+COMP-NULL"

     <p>"NORMAL:-ARCFOUR-128" means normal ciphers except for ARCFOUR-128.

     <p>"SECURE:-VERS-SSL3.0:+COMP-DEFLATE" means that only secure ciphers are
enabled, SSL3.0 is disabled, and libz compression enabled.

     <p>"NONE:+VERS-TLS-ALL:+AES-128-CBC:+RSA:+SHA1:+COMP-NULL:+SIGN-RSA-SHA1",

     <p>"NONE:+VERS-TLS-ALL:+AES-128-CBC:+ECDHE-RSA:+SHA1:+COMP-NULL:+SIGN-RSA-SHA1:+CURVE-SECP256R1",

     <p>"NORMAL:<code>COMPAT</code>" is the most compatible mode.

     <p><strong>Returns:</strong> On syntax error <code>GNUTLS_E_INVALID_REQUEST</code> is returned,
<code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_priority_set</h4>

<p><a name="gnutls_005fpriority_005fset"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_priority_set</b> (<var>gnutls_session_t session, gnutls_priority_t priority</var>)<var><a name="index-gnutls_005fpriority_005fset-222"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>priority</var>: is a <code>gnutls_priority_t</code> structure.

     <p>Sets the priorities to use on the ciphers, key exchange methods,
macs and compression methods.

     <p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_priority_set_direct</h4>

<p><a name="gnutls_005fpriority_005fset_005fdirect"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_priority_set_direct</b> (<var>gnutls_session_t session, const char * priorities, const char ** err_pos</var>)<var><a name="index-gnutls_005fpriority_005fset_005fdirect-223"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>priorities</var>: is a string describing priorities

     <p><var>err_pos</var>: In case of an error this will have the position in the string the error occured

     <p>Sets the priorities to use on the ciphers, key exchange methods,
macs and compression methods.  This function avoids keeping a
priority cache and is used to directly set string priorities to a
TLS session.  For documentation check the <code>gnutls_priority_init()</code>.

     <p><strong>Returns:</strong> On syntax error <code>GNUTLS_E_INVALID_REQUEST</code> is returned,
<code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_protocol_get_id</h4>

<p><a name="gnutls_005fprotocol_005fget_005fid"></a>

<div class="defun">
&mdash; Function: gnutls_protocol_t <b>gnutls_protocol_get_id</b> (<var>const char * name</var>)<var><a name="index-gnutls_005fprotocol_005fget_005fid-224"></a></var><br>
<blockquote><p><var>name</var>: is a protocol name

     <p>The names are compared in a case insensitive way.

     <p><strong>Returns:</strong> an id of the specified protocol, or
<code>GNUTLS_VERSION_UNKNOWN</code> on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_protocol_get_name</h4>

<p><a name="gnutls_005fprotocol_005fget_005fname"></a>

<div class="defun">
&mdash; Function: const char * <b>gnutls_protocol_get_name</b> (<var>gnutls_protocol_t version</var>)<var><a name="index-gnutls_005fprotocol_005fget_005fname-225"></a></var><br>
<blockquote><p><var>version</var>: is a (gnutls) version number

     <p>Convert a <code>gnutls_protocol_t</code> value to a string.

     <p><strong>Returns:</strong> a string that contains the name of the specified TLS
version (e.g., "TLS1.0"), or <code>NULL</code>. 
</p></blockquote></div>

<h4 class="subheading">gnutls_protocol_get_version</h4>

<p><a name="gnutls_005fprotocol_005fget_005fversion"></a>

<div class="defun">
&mdash; Function: gnutls_protocol_t <b>gnutls_protocol_get_version</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fprotocol_005fget_005fversion-226"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>Get TLS version, a <code>gnutls_protocol_t</code> value.

     <p><strong>Returns:</strong> The version of the currently used protocol. 
</p></blockquote></div>

<h4 class="subheading">gnutls_protocol_list</h4>

<p><a name="gnutls_005fprotocol_005flist"></a>

<div class="defun">
&mdash; Function: const gnutls_protocol_t * <b>gnutls_protocol_list</b> (<var> void</var>)<var><a name="index-gnutls_005fprotocol_005flist-227"></a></var><br>
<blockquote>
     <p>Get a list of supported protocols, e.g. SSL 3.0, TLS 1.0 etc.

     <p>This function is not threat safe.

     <p><strong>Returns:</strong> a (0)-terminated list of <code>gnutls_protocol_t</code> integers
indicating the available protocols. 
</p></blockquote></div>

<h4 class="subheading">gnutls_psk_allocate_client_credentials</h4>

<p><a name="gnutls_005fpsk_005fallocate_005fclient_005fcredentials"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_psk_allocate_client_credentials</b> (<var>gnutls_psk_client_credentials_t * sc</var>)<var><a name="index-gnutls_005fpsk_005fallocate_005fclient_005fcredentials-228"></a></var><br>
<blockquote><p><var>sc</var>: is a pointer to a <code>gnutls_psk_server_credentials_t</code> structure.

     <p>This structure is complex enough to manipulate directly thus this
helper function is provided in order to allocate it.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise
an error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_psk_allocate_server_credentials</h4>

<p><a name="gnutls_005fpsk_005fallocate_005fserver_005fcredentials"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_psk_allocate_server_credentials</b> (<var>gnutls_psk_server_credentials_t * sc</var>)<var><a name="index-gnutls_005fpsk_005fallocate_005fserver_005fcredentials-229"></a></var><br>
<blockquote><p><var>sc</var>: is a pointer to a <code>gnutls_psk_server_credentials_t</code> structure.

     <p>This structure is complex enough to manipulate directly thus this
helper function is provided in order to allocate it.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise
an error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_psk_client_get_hint</h4>

<p><a name="gnutls_005fpsk_005fclient_005fget_005fhint"></a>

<div class="defun">
&mdash; Function: const char * <b>gnutls_psk_client_get_hint</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fpsk_005fclient_005fget_005fhint-230"></a></var><br>
<blockquote><p><var>session</var>: is a gnutls session

     <p>The PSK identity hint may give the client help in deciding which
username to use.  This should only be called in case of PSK
authentication and in case of a client.

     <p><strong>Returns:</strong> the identity hint of the peer, or <code>NULL</code> in case of an error.

     <p><strong>Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_psk_free_client_credentials</h4>

<p><a name="gnutls_005fpsk_005ffree_005fclient_005fcredentials"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_psk_free_client_credentials</b> (<var>gnutls_psk_client_credentials_t sc</var>)<var><a name="index-gnutls_005fpsk_005ffree_005fclient_005fcredentials-231"></a></var><br>
<blockquote><p><var>sc</var>: is a <code>gnutls_psk_client_credentials_t</code> structure.

     <p>This structure is complex enough to manipulate directly thus this
helper function is provided in order to free (deallocate) it. 
</p></blockquote></div>

<h4 class="subheading">gnutls_psk_free_server_credentials</h4>

<p><a name="gnutls_005fpsk_005ffree_005fserver_005fcredentials"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_psk_free_server_credentials</b> (<var>gnutls_psk_server_credentials_t sc</var>)<var><a name="index-gnutls_005fpsk_005ffree_005fserver_005fcredentials-232"></a></var><br>
<blockquote><p><var>sc</var>: is a <code>gnutls_psk_server_credentials_t</code> structure.

     <p>This structure is complex enough to manipulate directly thus this
helper function is provided in order to free (deallocate) it. 
</p></blockquote></div>

<h4 class="subheading">gnutls_psk_server_get_username</h4>

<p><a name="gnutls_005fpsk_005fserver_005fget_005fusername"></a>

<div class="defun">
&mdash; Function: const char * <b>gnutls_psk_server_get_username</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fpsk_005fserver_005fget_005fusername-233"></a></var><br>
<blockquote><p><var>session</var>: is a gnutls session

     <p>This should only be called in case of PSK authentication and in
case of a server.

     <p><strong>Returns:</strong> the username of the peer, or <code>NULL</code> in case of an error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_psk_set_client_credentials</h4>

<p><a name="gnutls_005fpsk_005fset_005fclient_005fcredentials"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_psk_set_client_credentials</b> (<var>gnutls_psk_client_credentials_t res, const char * username, const gnutls_datum_t * key, gnutls_psk_key_flags flags</var>)<var><a name="index-gnutls_005fpsk_005fset_005fclient_005fcredentials-234"></a></var><br>
<blockquote><p><var>res</var>: is a <code>gnutls_psk_client_credentials_t</code> structure.

     <p><var>username</var>: is the user's zero-terminated userid

     <p><var>key</var>: is the user's key

     <p><var>flags</var>: indicate the format of the key, either
<code>GNUTLS_PSK_KEY_RAW</code> or <code>GNUTLS_PSK_KEY_HEX</code>.

     <p>This function sets the username and password, in a
gnutls_psk_client_credentials_t structure.  Those will be used in
PSK authentication.   <code>username</code>should be an ASCII string or UTF-8
strings prepared using the "SASLprep" profile of "stringprep".  The
key can be either in raw byte format or in Hex format (without the
0x prefix).

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise
an error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_psk_set_client_credentials_function</h4>

<p><a name="gnutls_005fpsk_005fset_005fclient_005fcredentials_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_psk_set_client_credentials_function</b> (<var>gnutls_psk_client_credentials_t cred, gnutls_psk_client_credentials_function * func</var>)<var><a name="index-gnutls_005fpsk_005fset_005fclient_005fcredentials_005ffunction-235"></a></var><br>
<blockquote><p><var>cred</var>: is a <code>gnutls_psk_server_credentials_t</code> structure.

     <p><var>func</var>: is the callback function

     <p>This function can be used to set a callback to retrieve the username and
password for client PSK authentication. 
The callback's function form is:
int (*callback)(gnutls_session_t, char** username,
gnutls_datum_t* key);

     <p>The  <code>username</code>and  <code>key</code>-&gt;data must be allocated using <code>gnutls_malloc()</code>. 
 <code>username</code>should be ASCII strings or UTF-8 strings prepared using
the "SASLprep" profile of "stringprep".

     <p>The callback function will be called once per handshake.

     <p>The callback function should return 0 on success. 
-1 indicates an error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_psk_set_params_function</h4>

<p><a name="gnutls_005fpsk_005fset_005fparams_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_psk_set_params_function</b> (<var>gnutls_psk_server_credentials_t res, gnutls_params_function * func</var>)<var><a name="index-gnutls_005fpsk_005fset_005fparams_005ffunction-236"></a></var><br>
<blockquote><p><var>res</var>: is a gnutls_psk_server_credentials_t structure

     <p><var>func</var>: is the function to be called

     <p>This function will set a callback in order for the server to get
the Diffie-Hellman or RSA parameters for PSK authentication.  The
callback should return <code>GNUTLS_E_SUCCESS</code> (0) on success. 
</p></blockquote></div>

<h4 class="subheading">gnutls_psk_set_server_credentials_file</h4>

<p><a name="gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffile"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_psk_set_server_credentials_file</b> (<var>gnutls_psk_server_credentials_t res, const char * password_file</var>)<var><a name="index-gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffile-237"></a></var><br>
<blockquote><p><var>res</var>: is a <code>gnutls_psk_server_credentials_t</code> structure.

     <p><var>password_file</var>: is the PSK password file (passwd.psk)

     <p>This function sets the password file, in a
<code>gnutls_psk_server_credentials_t</code> structure.  This password file
holds usernames and keys and will be used for PSK authentication.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise
an error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_psk_set_server_credentials_function</h4>

<p><a name="gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_psk_set_server_credentials_function</b> (<var>gnutls_psk_server_credentials_t cred, gnutls_psk_server_credentials_function * func</var>)<var><a name="index-gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffunction-238"></a></var><br>
<blockquote><p><var>cred</var>: is a <code>gnutls_psk_server_credentials_t</code> structure.

     <p><var>func</var>: is the callback function

     <p>This function can be used to set a callback to retrieve the user's PSK credentials. 
The callback's function form is:
int (*callback)(gnutls_session_t, const char* username,
gnutls_datum_t* key);

     <p><code>username</code>contains the actual username. 
The  <code>key</code>must be filled in using the <code>gnutls_malloc()</code>.

     <p>In case the callback returned a negative number then gnutls will
assume that the username does not exist.

     <p>The callback function will only be called once per handshake.  The
callback function should return 0 on success, while -1 indicates
an error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_psk_set_server_credentials_hint</h4>

<p><a name="gnutls_005fpsk_005fset_005fserver_005fcredentials_005fhint"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_psk_set_server_credentials_hint</b> (<var>gnutls_psk_server_credentials_t res, const char * hint</var>)<var><a name="index-gnutls_005fpsk_005fset_005fserver_005fcredentials_005fhint-239"></a></var><br>
<blockquote><p><var>res</var>: is a <code>gnutls_psk_server_credentials_t</code> structure.

     <p><var>hint</var>: is the PSK identity hint string

     <p>This function sets the identity hint, in a
<code>gnutls_psk_server_credentials_t</code> structure.  This hint is sent to
the client to help it chose a good PSK credential (i.e., username
and password).

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise
an error code is returned.

     <p><strong>Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_psk_set_server_dh_params</h4>

<p><a name="gnutls_005fpsk_005fset_005fserver_005fdh_005fparams"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_psk_set_server_dh_params</b> (<var>gnutls_psk_server_credentials_t res, gnutls_dh_params_t dh_params</var>)<var><a name="index-gnutls_005fpsk_005fset_005fserver_005fdh_005fparams-240"></a></var><br>
<blockquote><p><var>res</var>: is a gnutls_psk_server_credentials_t structure

     <p><var>dh_params</var>: is a structure that holds Diffie-Hellman parameters.

     <p>This function will set the Diffie-Hellman parameters for an
anonymous server to use. These parameters will be used in
Diffie-Hellman exchange with PSK cipher suites. 
</p></blockquote></div>

<h4 class="subheading">gnutls_psk_set_server_params_function</h4>

<p><a name="gnutls_005fpsk_005fset_005fserver_005fparams_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_psk_set_server_params_function</b> (<var>gnutls_psk_server_credentials_t res, gnutls_params_function * func</var>)<var><a name="index-gnutls_005fpsk_005fset_005fserver_005fparams_005ffunction-241"></a></var><br>
<blockquote><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code> structure

     <p><var>func</var>: is the function to be called

     <p>This function will set a callback in order for the server to get
the Diffie-Hellman parameters for PSK authentication.  The callback
should return <code>GNUTLS_E_SUCCESS</code> (0) on success. 
</p></blockquote></div>

<h4 class="subheading">gnutls_record_check_pending</h4>

<p><a name="gnutls_005frecord_005fcheck_005fpending"></a>

<div class="defun">
&mdash; Function: size_t <b>gnutls_record_check_pending</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005frecord_005fcheck_005fpending-242"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>This function checks if there are unread data
in the gnutls buffers. If the return value is
non-zero the next call to <code>gnutls_record_recv()</code>
is guarranteed not to block.

     <p><strong>Returns:</strong> Returns the size of the data or zero. 
</p></blockquote></div>

<h4 class="subheading">gnutls_record_disable_padding</h4>

<p><a name="gnutls_005frecord_005fdisable_005fpadding"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_record_disable_padding</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005frecord_005fdisable_005fpadding-243"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>Used to disabled padding in TLS 1.0 and above.  Normally you do not
need to use this function, but there are buggy clients that
complain if a server pads the encrypted data.  This of course will
disable protection against statistical attacks on the data.

     <p>Normally only servers that require maximum compatibility with everything
out there, need to call this function. 
</p></blockquote></div>

<h4 class="subheading">gnutls_record_get_direction</h4>

<p><a name="gnutls_005frecord_005fget_005fdirection"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_record_get_direction</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005frecord_005fget_005fdirection-244"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>This function provides information about the internals of the
record protocol and is only useful if a prior gnutls function call
(e.g.  <code>gnutls_handshake()</code>) was interrupted for some reason, that
is, if a function returned <code>GNUTLS_E_INTERRUPTED</code> or
<code>GNUTLS_E_AGAIN</code>.  In such a case, you might want to call <code>select()</code>
or <code>poll()</code> before calling the interrupted gnutls function again.  To
tell you whether a file descriptor should be selected for either
reading or writing, <code>gnutls_record_get_direction()</code> returns 0 if the
interrupted function was trying to read data, and 1 if it was
trying to write data.

     <p><strong>Returns:</strong> 0 if trying to read data, 1 if trying to write data. 
</p></blockquote></div>

<h4 class="subheading">gnutls_record_get_max_size</h4>

<p><a name="gnutls_005frecord_005fget_005fmax_005fsize"></a>

<div class="defun">
&mdash; Function: size_t <b>gnutls_record_get_max_size</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005frecord_005fget_005fmax_005fsize-245"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>Get the record size.  The maximum record size is negotiated by the
client after the first handshake message.

     <p><strong>Returns:</strong> The maximum record packet size in this connection. 
</p></blockquote></div>

<h4 class="subheading">gnutls_record_recv</h4>

<p><a name="gnutls_005frecord_005frecv"></a>

<div class="defun">
&mdash; Function: ssize_t <b>gnutls_record_recv</b> (<var>gnutls_session_t session, void * data, size_t data_size</var>)<var><a name="index-gnutls_005frecord_005frecv-246"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>data</var>: the buffer that the data will be read into

     <p><var>data_size</var>: the number of requested bytes

     <p>This function has the similar semantics with <code>recv()</code>.  The only
difference is that it accepts a GnuTLS session, and uses different
error codes. 
In the special case that a server requests a renegotiation, the
client may receive an error code of <code>GNUTLS_E_REHANDSHAKE</code>.  This
message may be simply ignored, replied with an alert
<code>GNUTLS_A_NO_RENEGOTIATION</code>, or replied with a new handshake,
depending on the client's will. 
If <code>EINTR</code> is returned by the internal push function (the default
is <code>recv()</code>) then <code>GNUTLS_E_INTERRUPTED</code> will be returned.  If
<code>GNUTLS_E_INTERRUPTED</code> or <code>GNUTLS_E_AGAIN</code> is returned, you must
call this function again to get the data.  See also
<code>gnutls_record_get_direction()</code>. 
A server may also receive <code>GNUTLS_E_REHANDSHAKE</code> when a client has
initiated a handshake. In that case the server can only initiate a
handshake or terminate the connection.

     <p><strong>Returns:</strong> The number of bytes received and zero on EOF (for stream
connections).  A negative error code is returned in case of an error. 
The number of bytes received might be less than the requested  <code>data_size</code>. 
</p></blockquote></div>

<h4 class="subheading">gnutls_record_recv_seq</h4>

<p><a name="gnutls_005frecord_005frecv_005fseq"></a>

<div class="defun">
&mdash; Function: ssize_t <b>gnutls_record_recv_seq</b> (<var>gnutls_session_t session, void * data, size_t data_size, unsigned char * seq</var>)<var><a name="index-gnutls_005frecord_005frecv_005fseq-247"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>data</var>: the buffer that the data will be read into

     <p><var>data_size</var>: the number of requested bytes

     <p><var>seq</var>: is the packet's 64-bit sequence number. Should have space for 8 bytes.

     <p>This function is the same as <code>gnutls_record_recv()</code>, except that
it returns in addition to data, the sequence number of the data. 
This is useful in DTLS where record packets might be received
out-of-order. The returned 8-byte sequence number is an
integer in big-endian format and should be
treated as a unique message identification.

     <p><strong>Returns:</strong> The number of bytes received and zero on EOF.  A negative
error code is returned in case of an error.  The number of bytes
received might be less than  <code>data_size</code>.

     <p><strong>Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_record_send</h4>

<p><a name="gnutls_005frecord_005fsend"></a>

<div class="defun">
&mdash; Function: ssize_t <b>gnutls_record_send</b> (<var>gnutls_session_t session, const void * data, size_t data_size</var>)<var><a name="index-gnutls_005frecord_005fsend-248"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>data</var>: contains the data to send

     <p><var>data_size</var>: is the length of the data

     <p>This function has the similar semantics with <code>send()</code>.  The only
difference is that it accepts a GnuTLS session, and uses different
error codes. 
Note that if the send buffer is full, <code>send()</code> will block this
function.  See the <code>send()</code> documentation for full information.  You
can replace the default push function by using
<code>gnutls_transport_set_ptr2()</code> with a call to <code>send()</code> with a
MSG_DONTWAIT flag if blocking is a problem. 
If the EINTR is returned by the internal push function (the
default is <code>send()</code>) then <code>GNUTLS_E_INTERRUPTED</code> will be returned. If
<code>GNUTLS_E_INTERRUPTED</code> or <code>GNUTLS_E_AGAIN</code> is returned, you must
call this function again, with the same parameters; alternatively
you could provide a <code>NULL</code> pointer for data, and 0 for
size. cf. <code>gnutls_record_get_direction()</code>.

     <p><strong>Returns:</strong> The number of bytes sent, or a negative error code.  The
number of bytes sent might be less than  <code>data_size</code>.  The maximum
number of bytes this function can send in a single call depends
on the negotiated maximum record size. 
</p></blockquote></div>

<h4 class="subheading">gnutls_record_set_max_size</h4>

<p><a name="gnutls_005frecord_005fset_005fmax_005fsize"></a>

<div class="defun">
&mdash; Function: ssize_t <b>gnutls_record_set_max_size</b> (<var>gnutls_session_t session, size_t size</var>)<var><a name="index-gnutls_005frecord_005fset_005fmax_005fsize-249"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>size</var>: is the new size

     <p>This function sets the maximum record packet size in this
connection.  This property can only be set to clients.  The server
may choose not to accept the requested size.

     <p>Acceptable values are 512(=2^9), 1024(=2^10), 2048(=2^11) and
4096(=2^12).  The requested record size does get in effect
immediately only while sending data. The receive part will take
effect after a successful handshake.

     <p>This function uses a TLS extension called 'max record size'.  Not
all TLS implementations use or even understand this extension.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned,
otherwise a negative error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_rehandshake</h4>

<p><a name="gnutls_005frehandshake"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_rehandshake</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005frehandshake-250"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>This function will renegotiate security parameters with the
client.  This should only be called in case of a server.

     <p>This message informs the peer that we want to renegotiate
parameters (perform a handshake).

     <p>If this function succeeds (returns 0), you must call the
<code>gnutls_handshake()</code> function in order to negotiate the new
parameters.

     <p>Since TLS is full duplex some application data might have been
sent during peer's processing of this message. In that case
one should call <code>gnutls_record_recv()</code> until GNUTLS_E_REHANDSHAKE
is returned to clear any pending data. Care must be taken if
rehandshake is mandatory to terminate if it does not start after
some threshold.

     <p>If the client does not wish to renegotiate parameters he will
should with an alert message, thus the return code will be
<code>GNUTLS_E_WARNING_ALERT_RECEIVED</code> and the alert will be
<code>GNUTLS_A_NO_RENEGOTIATION</code>.  A client may also choose to ignore
this message.

     <p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, otherwise a negative error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_safe_renegotiation_status</h4>

<p><a name="gnutls_005fsafe_005frenegotiation_005fstatus"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_safe_renegotiation_status</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fsafe_005frenegotiation_005fstatus-251"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>Can be used to check whether safe renegotiation is being used
in the current session.

     <p><strong>Returns:</strong> 0 when safe renegotiation is not used and non (0) when
safe renegotiation is used.

     <p><strong>Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_sec_param_get_name</h4>

<p><a name="gnutls_005fsec_005fparam_005fget_005fname"></a>

<div class="defun">
&mdash; Function: const char * <b>gnutls_sec_param_get_name</b> (<var>gnutls_sec_param_t param</var>)<var><a name="index-gnutls_005fsec_005fparam_005fget_005fname-252"></a></var><br>
<blockquote><p><var>param</var>: is a security parameter

     <p>Convert a <code>gnutls_sec_param_t</code> value to a string.

     <p><strong>Returns:</strong> a pointer to a string that contains the name of the
specified public key algorithm, or <code>NULL</code>.

     <p><strong>Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_sec_param_to_pk_bits</h4>

<p><a name="gnutls_005fsec_005fparam_005fto_005fpk_005fbits"></a>

<div class="defun">
&mdash; Function: unsigned int <b>gnutls_sec_param_to_pk_bits</b> (<var>gnutls_pk_algorithm_t algo, gnutls_sec_param_t param</var>)<var><a name="index-gnutls_005fsec_005fparam_005fto_005fpk_005fbits-253"></a></var><br>
<blockquote><p><var>algo</var>: is a public key algorithm

     <p><var>param</var>: is a security parameter

     <p>When generating private and public key pairs a difficult question
is which size of "bits" the modulus will be in RSA and the group size
in DSA. The easy answer is 1024, which is also wrong. This function
will convert a human understandable security parameter to an
appropriate size for the specific algorithm.

     <p><strong>Returns:</strong> The number of bits, or (0).

     <p><strong>Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_server_name_get</h4>

<p><a name="gnutls_005fserver_005fname_005fget"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_server_name_get</b> (<var>gnutls_session_t session, void * data, size_t * data_length, unsigned int * type, unsigned int indx</var>)<var><a name="index-gnutls_005fserver_005fname_005fget-254"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>data</var>: will hold the data

     <p><var>data_length</var>: will hold the data length. Must hold the maximum size of data.

     <p><var>type</var>: will hold the server name indicator type

     <p><var>indx</var>: is the index of the server_name

     <p>This function will allow you to get the name indication (if any), a
client has sent.  The name indication may be any of the enumeration
gnutls_server_name_type_t.

     <p>If  <code>type</code>is GNUTLS_NAME_DNS, then this function is to be used by
servers that support virtual hosting, and the data will be a null
terminated UTF-8 string.

     <p>If  <code>data</code>has not enough size to hold the server name
GNUTLS_E_SHORT_MEMORY_BUFFER is returned, and  <code>data_length</code>will
hold the required size.

     <p><code>index</code>is used to retrieve more than one server names (if sent by
the client).  The first server name has an index of 0, the second 1
and so on.  If no name with the given index exists
GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE is returned.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned,
otherwise a negative error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_server_name_set</h4>

<p><a name="gnutls_005fserver_005fname_005fset"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_server_name_set</b> (<var>gnutls_session_t session, gnutls_server_name_type_t type, const void * name, size_t name_length</var>)<var><a name="index-gnutls_005fserver_005fname_005fset-255"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>type</var>: specifies the indicator type

     <p><var>name</var>: is a string that contains the server name.

     <p><var>name_length</var>: holds the length of name

     <p>This function is to be used by clients that want to inform (via a
TLS extension mechanism) the server of the name they connected to. 
This should be used by clients that connect to servers that do
virtual hosting.

     <p>The value of  <code>name</code>depends on the  <code>type</code>type.  In case of
<code>GNUTLS_NAME_DNS</code>, an ASCII (0)-terminated domain name string,
without the trailing dot, is expected.  IPv4 or IPv6 addresses are
not permitted.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned,
otherwise a negative error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_session_channel_binding</h4>

<p><a name="gnutls_005fsession_005fchannel_005fbinding"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_session_channel_binding</b> (<var>gnutls_session_t session, gnutls_channel_binding_t cbtype, gnutls_datum_t * cb</var>)<var><a name="index-gnutls_005fsession_005fchannel_005fbinding-256"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>cbtype</var>: an <code>gnutls_channel_binding_t</code> enumeration type

     <p><var>cb</var>: output buffer array with data

     <p>Extract given channel binding data of the  <code>cbtype</code>(e.g.,
<code>GNUTLS_CB_TLS_UNIQUE</code>) type.

     <p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success,
<code>GNUTLS_E_UNIMPLEMENTED_FEATURE</code> if the  <code>cbtype</code>is unsupported,
<code>GNUTLS_E_CHANNEL_BINDING_NOT_AVAILABLE</code> if the data is not
currently available, or an error code.

     <p><strong>Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_session_enable_compatibility_mode</h4>

<p><a name="gnutls_005fsession_005fenable_005fcompatibility_005fmode"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_session_enable_compatibility_mode</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fsession_005fenable_005fcompatibility_005fmode-257"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>This function can be used to disable certain (security) features in
TLS in order to maintain maximum compatibility with buggy
clients. It is equivalent to calling:
<code>gnutls_record_disable_padding()</code>

     <p>Normally only servers that require maximum compatibility with
everything out there, need to call this function. 
</p></blockquote></div>

<h4 class="subheading">gnutls_session_get_data</h4>

<p><a name="gnutls_005fsession_005fget_005fdata"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_session_get_data</b> (<var>gnutls_session_t session, void * session_data, size_t * session_data_size</var>)<var><a name="index-gnutls_005fsession_005fget_005fdata-258"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>session_data</var>: is a pointer to space to hold the session.

     <p><var>session_data_size</var>: is the session_data's size, or it will be set by the function.

     <p>Returns all session parameters, in order to support resuming.  The
client should call this, and keep the returned session, if he
wants to resume that current version later by calling
<code>gnutls_session_set_data()</code> This function must be called after a
successful handshake.

     <p>Resuming sessions is really useful and speedups connections after
a successful one.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise
an error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_session_get_data2</h4>

<p><a name="gnutls_005fsession_005fget_005fdata2"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_session_get_data2</b> (<var>gnutls_session_t session, gnutls_datum_t * data</var>)<var><a name="index-gnutls_005fsession_005fget_005fdata2-259"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>data</var>: is a pointer to a datum that will hold the session.

     <p>Returns all session parameters, in order to support resuming.  The
client should call this, and keep the returned session, if he wants
to resume that current version later by calling
<code>gnutls_session_set_data()</code>.  This function must be called after a
successful handshake.  The returned datum must be freed with
<code>gnutls_free()</code>.

     <p>Resuming sessions is really useful and speedups connections after
a successful one.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise
an error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_session_get_id</h4>

<p><a name="gnutls_005fsession_005fget_005fid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_session_get_id</b> (<var>gnutls_session_t session, void * session_id, size_t * session_id_size</var>)<var><a name="index-gnutls_005fsession_005fget_005fid-260"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>session_id</var>: is a pointer to space to hold the session id.

     <p><var>session_id_size</var>: is the session id's size, or it will be set by the function.

     <p>Returns the current session id. This can be used if you want to
check if the next session you tried to resume was actually
resumed.  This is because resumed sessions have the same sessionID
with the original session.

     <p>Session id is some data set by the server, that identify the
current session.  In TLS 1.0 and SSL 3.0 session id is always less
than 32 bytes.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise
an error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_session_get_ptr</h4>

<p><a name="gnutls_005fsession_005fget_005fptr"></a>

<div class="defun">
&mdash; Function: void * <b>gnutls_session_get_ptr</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fsession_005fget_005fptr-261"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>Get user pointer for session.  Useful in callbacks.  This is the
pointer set with <code>gnutls_session_set_ptr()</code>.

     <p><strong>Returns:</strong> the user given pointer from the session structure, or
<code>NULL</code> if it was never set. 
</p></blockquote></div>

<h4 class="subheading">gnutls_session_is_resumed</h4>

<p><a name="gnutls_005fsession_005fis_005fresumed"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_session_is_resumed</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fsession_005fis_005fresumed-262"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>Check whether session is resumed or not.

     <p><strong>Returns:</strong> non zero if this session is resumed, or a zero if this is
a new session. 
</p></blockquote></div>

<h4 class="subheading">gnutls_session_set_data</h4>

<p><a name="gnutls_005fsession_005fset_005fdata"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_session_set_data</b> (<var>gnutls_session_t session, const void * session_data, size_t session_data_size</var>)<var><a name="index-gnutls_005fsession_005fset_005fdata-263"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>session_data</var>: is a pointer to space to hold the session.

     <p><var>session_data_size</var>: is the session's size

     <p>Sets all session parameters, in order to resume a previously
established session.  The session data given must be the one
returned by <code>gnutls_session_get_data()</code>.  This function should be
called before <code>gnutls_handshake()</code>.

     <p>Keep in mind that session resuming is advisory. The server may
choose not to resume the session, thus a full handshake will be
performed.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise
an error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_session_set_ptr</h4>

<p><a name="gnutls_005fsession_005fset_005fptr"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_session_set_ptr</b> (<var>gnutls_session_t session, void * ptr</var>)<var><a name="index-gnutls_005fsession_005fset_005fptr-264"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>ptr</var>: is the user pointer

     <p>This function will set (associate) the user given pointer  <code>ptr</code>to
the session structure.  This is pointer can be accessed with
<code>gnutls_session_get_ptr()</code>. 
</p></blockquote></div>

<h4 class="subheading">gnutls_session_ticket_enable_client</h4>

<p><a name="gnutls_005fsession_005fticket_005fenable_005fclient"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_session_ticket_enable_client</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fsession_005fticket_005fenable_005fclient-265"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>Request that the client should attempt session resumption using
SessionTicket.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, or an
error code.

     <p><strong>Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_session_ticket_enable_server</h4>

<p><a name="gnutls_005fsession_005fticket_005fenable_005fserver"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_session_ticket_enable_server</b> (<var>gnutls_session_t session, const gnutls_datum_t * key</var>)<var><a name="index-gnutls_005fsession_005fticket_005fenable_005fserver-266"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>key</var>: key to encrypt session parameters.

     <p>Request that the server should attempt session resumption using
SessionTicket.   <code>key</code>must be initialized with
<code>gnutls_session_ticket_key_generate()</code>.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, or an
error code.

     <p><strong>Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_session_ticket_key_generate</h4>

<p><a name="gnutls_005fsession_005fticket_005fkey_005fgenerate"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_session_ticket_key_generate</b> (<var>gnutls_datum_t * key</var>)<var><a name="index-gnutls_005fsession_005fticket_005fkey_005fgenerate-267"></a></var><br>
<blockquote><p><var>key</var>: is a pointer to a <code>gnutls_datum_t</code> which will contain a newly
created key.

     <p>Generate a random key to encrypt security parameters within
SessionTicket.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, or an
error code.

     <p><strong>Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_set_default_priority</h4>

<p><a name="gnutls_005fset_005fdefault_005fpriority"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_set_default_priority</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fset_005fdefault_005fpriority-268"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>Sets some default priority on the ciphers, key exchange methods,
macs and compression methods.

     <p><strong>Thisisthesameascalling:</strong>
gnutls_priority_set_direct (session, "NORMAL", NULL);

     <p>This function is kept around for backwards compatibility, but
because of its wide use it is still fully supported.  If you wish
to allow users to provide a string that specify which ciphers to
use (which is recommended), you should use
<code>gnutls_priority_set_direct()</code> or <code>gnutls_priority_set()</code> instead.

     <p><strong>Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_sign_algorithm_get_requested</h4>

<p><a name="gnutls_005fsign_005falgorithm_005fget_005frequested"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_sign_algorithm_get_requested</b> (<var>gnutls_session_t session, size_t indx, gnutls_sign_algorithm_t * algo</var>)<var><a name="index-gnutls_005fsign_005falgorithm_005fget_005frequested-269"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>indx</var>: is an index of the signature algorithm to return

     <p><var>algo</var>: the returned certificate type will be stored there

     <p>Returns the signature algorithm specified by index that was
requested by the peer. If the specified index has no data available
this function returns <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>.  If
the negotiated TLS version does not support signature algorithms
then <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> will be returned even
for the first index.  The first index is 0.

     <p>This function is useful in the certificate callback functions
to assist in selecting the correct certificate.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise
an error code is returned.

     <p><strong>Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_sign_get_id</h4>

<p><a name="gnutls_005fsign_005fget_005fid"></a>

<div class="defun">
&mdash; Function: gnutls_sign_algorithm_t <b>gnutls_sign_get_id</b> (<var>const char * name</var>)<var><a name="index-gnutls_005fsign_005fget_005fid-270"></a></var><br>
<blockquote><p><var>name</var>: is a MAC algorithm name

     <p>The names are compared in a case insensitive way.

     <p><strong>Returns:</strong> return a <code>gnutls_sign_algorithm_t</code> value corresponding to
the specified cipher, or <code>GNUTLS_SIGN_UNKNOWN</code> on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_sign_get_name</h4>

<p><a name="gnutls_005fsign_005fget_005fname"></a>

<div class="defun">
&mdash; Function: const char * <b>gnutls_sign_get_name</b> (<var>gnutls_sign_algorithm_t algorithm</var>)<var><a name="index-gnutls_005fsign_005fget_005fname-271"></a></var><br>
<blockquote><p><var>algorithm</var>: is a sign algorithm

     <p>Convert a <code>gnutls_sign_algorithm_t</code> value to a string.

     <p><strong>Returns:</strong> a string that contains the name of the specified sign
algorithm, or <code>NULL</code>. 
</p></blockquote></div>

<h4 class="subheading">gnutls_sign_list</h4>

<p><a name="gnutls_005fsign_005flist"></a>

<div class="defun">
&mdash; Function: const gnutls_sign_algorithm_t * <b>gnutls_sign_list</b> (<var> void</var>)<var><a name="index-gnutls_005fsign_005flist-272"></a></var><br>
<blockquote>
     <p>Get a list of supported public key signature algorithms.

     <p><strong>Returns:</strong> a (0)-terminated list of <code>gnutls_sign_algorithm_t</code>
integers indicating the available ciphers. 
</p></blockquote></div>

<h4 class="subheading">gnutls_srp_allocate_client_credentials</h4>

<p><a name="gnutls_005fsrp_005fallocate_005fclient_005fcredentials"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_srp_allocate_client_credentials</b> (<var>gnutls_srp_client_credentials_t * sc</var>)<var><a name="index-gnutls_005fsrp_005fallocate_005fclient_005fcredentials-273"></a></var><br>
<blockquote><p><var>sc</var>: is a pointer to a <code>gnutls_srp_server_credentials_t</code> structure.

     <p>This structure is complex enough to manipulate directly thus
this helper function is provided in order to allocate it.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, or an
error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_srp_allocate_server_credentials</h4>

<p><a name="gnutls_005fsrp_005fallocate_005fserver_005fcredentials"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_srp_allocate_server_credentials</b> (<var>gnutls_srp_server_credentials_t * sc</var>)<var><a name="index-gnutls_005fsrp_005fallocate_005fserver_005fcredentials-274"></a></var><br>
<blockquote><p><var>sc</var>: is a pointer to a <code>gnutls_srp_server_credentials_t</code> structure.

     <p>This structure is complex enough to manipulate directly thus this
helper function is provided in order to allocate it.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, or an
error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_srp_base64_decode</h4>

<p><a name="gnutls_005fsrp_005fbase64_005fdecode"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_srp_base64_decode</b> (<var>const gnutls_datum_t * b64_data, char * result, size_t * result_size</var>)<var><a name="index-gnutls_005fsrp_005fbase64_005fdecode-275"></a></var><br>
<blockquote><p><var>b64_data</var>: contain the encoded data

     <p><var>result</var>: the place where decoded data will be copied

     <p><var>result_size</var>: holds the size of the result

     <p>This function will decode the given encoded data, using the base64
encoding found in libsrp.

     <p>Note that  <code>b64_data</code>should be null terminated.

     <p>Warning!  This base64 encoding is not the "standard" encoding, so
do not use it for non-SRP purposes.

     <p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> if the buffer given is not
long enough, or 0 on success. 
</p></blockquote></div>

<h4 class="subheading">gnutls_srp_base64_decode_alloc</h4>

<p><a name="gnutls_005fsrp_005fbase64_005fdecode_005falloc"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_srp_base64_decode_alloc</b> (<var>const gnutls_datum_t * b64_data, gnutls_datum_t * result</var>)<var><a name="index-gnutls_005fsrp_005fbase64_005fdecode_005falloc-276"></a></var><br>
<blockquote><p><var>b64_data</var>: contains the encoded data

     <p><var>result</var>: the place where decoded data lie

     <p>This function will decode the given encoded data. The decoded data
will be allocated, and stored into result.  It will decode using
the base64 algorithm as used in libsrp.

     <p>You should use <code>gnutls_free()</code> to free the returned data.

     <p>Warning!  This base64 encoding is not the "standard" encoding, so
do not use it for non-SRP purposes.

     <p><strong>Returns:</strong> 0 on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_srp_base64_encode</h4>

<p><a name="gnutls_005fsrp_005fbase64_005fencode"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_srp_base64_encode</b> (<var>const gnutls_datum_t * data, char * result, size_t * result_size</var>)<var><a name="index-gnutls_005fsrp_005fbase64_005fencode-277"></a></var><br>
<blockquote><p><var>data</var>: contain the raw data

     <p><var>result</var>: the place where base64 data will be copied

     <p><var>result_size</var>: holds the size of the result

     <p>This function will convert the given data to printable data, using
the base64 encoding, as used in the libsrp.  This is the encoding
used in SRP password files.  If the provided buffer is not long
enough GNUTLS_E_SHORT_MEMORY_BUFFER is returned.

     <p>Warning!  This base64 encoding is not the "standard" encoding, so
do not use it for non-SRP purposes.

     <p><strong>Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> if the buffer given is not
long enough, or 0 on success. 
</p></blockquote></div>

<h4 class="subheading">gnutls_srp_base64_encode_alloc</h4>

<p><a name="gnutls_005fsrp_005fbase64_005fencode_005falloc"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_srp_base64_encode_alloc</b> (<var>const gnutls_datum_t * data, gnutls_datum_t * result</var>)<var><a name="index-gnutls_005fsrp_005fbase64_005fencode_005falloc-278"></a></var><br>
<blockquote><p><var>data</var>: contains the raw data

     <p><var>result</var>: will hold the newly allocated encoded data

     <p>This function will convert the given data to printable data, using
the base64 encoding.  This is the encoding used in SRP password
files.  This function will allocate the required memory to hold
the encoded data.

     <p>You should use <code>gnutls_free()</code> to free the returned data.

     <p>Warning!  This base64 encoding is not the "standard" encoding, so
do not use it for non-SRP purposes.

     <p><strong>Returns:</strong> 0 on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_srp_free_client_credentials</h4>

<p><a name="gnutls_005fsrp_005ffree_005fclient_005fcredentials"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_srp_free_client_credentials</b> (<var>gnutls_srp_client_credentials_t sc</var>)<var><a name="index-gnutls_005fsrp_005ffree_005fclient_005fcredentials-279"></a></var><br>
<blockquote><p><var>sc</var>: is a <code>gnutls_srp_client_credentials_t</code> structure.

     <p>This structure is complex enough to manipulate directly thus
this helper function is provided in order to free (deallocate) it. 
</p></blockquote></div>

<h4 class="subheading">gnutls_srp_free_server_credentials</h4>

<p><a name="gnutls_005fsrp_005ffree_005fserver_005fcredentials"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_srp_free_server_credentials</b> (<var>gnutls_srp_server_credentials_t sc</var>)<var><a name="index-gnutls_005fsrp_005ffree_005fserver_005fcredentials-280"></a></var><br>
<blockquote><p><var>sc</var>: is a <code>gnutls_srp_server_credentials_t</code> structure.

     <p>This structure is complex enough to manipulate directly thus
this helper function is provided in order to free (deallocate) it. 
</p></blockquote></div>

<h4 class="subheading">gnutls_srp_server_get_username</h4>

<p><a name="gnutls_005fsrp_005fserver_005fget_005fusername"></a>

<div class="defun">
&mdash; Function: const char * <b>gnutls_srp_server_get_username</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fsrp_005fserver_005fget_005fusername-281"></a></var><br>
<blockquote><p><var>session</var>: is a gnutls session

     <p>This function will return the username of the peer.  This should
only be called in case of SRP authentication and in case of a
server.  Returns NULL in case of an error.

     <p><strong>Returns:</strong> SRP username of the peer, or NULL in case of error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_srp_set_client_credentials</h4>

<p><a name="gnutls_005fsrp_005fset_005fclient_005fcredentials"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_srp_set_client_credentials</b> (<var>gnutls_srp_client_credentials_t res, const char * username, const char * password</var>)<var><a name="index-gnutls_005fsrp_005fset_005fclient_005fcredentials-282"></a></var><br>
<blockquote><p><var>res</var>: is a <code>gnutls_srp_client_credentials_t</code> structure.

     <p><var>username</var>: is the user's userid

     <p><var>password</var>: is the user's password

     <p>This function sets the username and password, in a
<code>gnutls_srp_client_credentials_t</code> structure.  Those will be used in
SRP authentication.   <code>username</code>and  <code>password</code>should be ASCII
strings or UTF-8 strings prepared using the "SASLprep" profile of
"stringprep".

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, or an
error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_srp_set_client_credentials_function</h4>

<p><a name="gnutls_005fsrp_005fset_005fclient_005fcredentials_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_srp_set_client_credentials_function</b> (<var>gnutls_srp_client_credentials_t cred, gnutls_srp_client_credentials_function * func</var>)<var><a name="index-gnutls_005fsrp_005fset_005fclient_005fcredentials_005ffunction-283"></a></var><br>
<blockquote><p><var>cred</var>: is a <code>gnutls_srp_server_credentials_t</code> structure.

     <p><var>func</var>: is the callback function

     <p>This function can be used to set a callback to retrieve the
username and password for client SRP authentication.  The
callback's function form is:

     <p>int (*callback)(gnutls_session_t, char** username, char**password);

     <p>The  <code>username</code>and  <code>password</code>must be allocated using
<code>gnutls_malloc()</code>.   <code>username</code>and  <code>password</code>should be ASCII strings
or UTF-8 strings prepared using the "SASLprep" profile of
"stringprep".

     <p>The callback function will be called once per handshake before the
initial hello message is sent.

     <p>The callback should not return a negative error code the second
time called, since the handshake procedure will be aborted.

     <p>The callback function should return 0 on success. 
-1 indicates an error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_srp_set_prime_bits</h4>

<p><a name="gnutls_005fsrp_005fset_005fprime_005fbits"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_srp_set_prime_bits</b> (<var>gnutls_session_t session, unsigned int bits</var>)<var><a name="index-gnutls_005fsrp_005fset_005fprime_005fbits-284"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>bits</var>: is the number of bits

     <p>This function sets the minimum accepted number of bits, for use in
an SRP key exchange.  If zero, the default 2048 bits will be used.

     <p>In the client side it sets the minimum accepted number of bits.  If
a server sends a prime with less bits than that
<code>GNUTLS_E_RECEIVED_ILLEGAL_PARAMETER</code> will be returned by the
handshake.

     <p>This function has no effect in server side.

     <p><strong>Since:</strong> 2.6.0
</p></blockquote></div>

<h4 class="subheading">gnutls_srp_set_server_credentials_file</h4>

<p><a name="gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffile"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_srp_set_server_credentials_file</b> (<var>gnutls_srp_server_credentials_t res, const char * password_file, const char * password_conf_file</var>)<var><a name="index-gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffile-285"></a></var><br>
<blockquote><p><var>res</var>: is a <code>gnutls_srp_server_credentials_t</code> structure.

     <p><var>password_file</var>: is the SRP password file (tpasswd)

     <p><var>password_conf_file</var>: is the SRP password conf file (tpasswd.conf)

     <p>This function sets the password files, in a
<code>gnutls_srp_server_credentials_t</code> structure.  Those password files
hold usernames and verifiers and will be used for SRP
authentication.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, or an
error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_srp_set_server_credentials_function</h4>

<p><a name="gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_srp_set_server_credentials_function</b> (<var>gnutls_srp_server_credentials_t cred, gnutls_srp_server_credentials_function * func</var>)<var><a name="index-gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffunction-286"></a></var><br>
<blockquote><p><var>cred</var>: is a <code>gnutls_srp_server_credentials_t</code> structure.

     <p><var>func</var>: is the callback function

     <p>This function can be used to set a callback to retrieve the user's
SRP credentials.  The callback's function form is:

     <p>int (*callback)(gnutls_session_t, const char* username,
gnutls_datum_t* salt, gnutls_datum_t *verifier, gnutls_datum_t* g,
gnutls_datum_t* n);

     <p><code>username</code>contains the actual username. 
The  <code>salt</code>,  <code>verifier</code>,  <code>generator</code>and  <code>prime</code>must be filled
in using the <code>gnutls_malloc()</code>. For convenience  <code>prime</code>and  <code>generator</code>may also be one of the static parameters defined in gnutls.h.

     <p>In case the callback returned a negative number then gnutls will
assume that the username does not exist.

     <p>In order to prevent attackers from guessing valid usernames,
if a user does not exist, g and n values should be filled in
using a random user's parameters. In that case the callback must
return the special value (1).

     <p>The callback function will only be called once per handshake. 
The callback function should return 0 on success, while
-1 indicates an error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_srp_verifier</h4>

<p><a name="gnutls_005fsrp_005fverifier"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_srp_verifier</b> (<var>const char * username, const char * password, const gnutls_datum_t * salt, const gnutls_datum_t * generator, const gnutls_datum_t * prime, gnutls_datum_t * res</var>)<var><a name="index-gnutls_005fsrp_005fverifier-287"></a></var><br>
<blockquote><p><var>username</var>: is the user's name

     <p><var>password</var>: is the user's password

     <p><var>salt</var>: should be some randomly generated bytes

     <p><var>generator</var>: is the generator of the group

     <p><var>prime</var>: is the group's prime

     <p><var>res</var>: where the verifier will be stored.

     <p>This function will create an SRP verifier, as specified in
RFC2945.  The  <code>prime</code>and  <code>generator</code>should be one of the static
parameters defined in gnutls/gnutls.h or may be generated.

     <p>The verifier will be allocated with  <code>gnutls_malloc</code>() and will be stored in
 <code>res</code>using binary format.

     <p><strong>Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, or an
error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_strerror</h4>

<p><a name="gnutls_005fstrerror"></a>

<div class="defun">
&mdash; Function: const char * <b>gnutls_strerror</b> (<var>int error</var>)<var><a name="index-gnutls_005fstrerror-288"></a></var><br>
<blockquote><p><var>error</var>: is a GnuTLS error code, a negative error code

     <p>This function is similar to strerror.  The difference is that it
accepts an error number returned by a gnutls function; In case of
an unknown error a descriptive string is sent instead of <code>NULL</code>.

     <p>Error codes are always a negative error code.

     <p><strong>Returns:</strong> A string explaining the GnuTLS error message. 
</p></blockquote></div>

<h4 class="subheading">gnutls_strerror_name</h4>

<p><a name="gnutls_005fstrerror_005fname"></a>

<div class="defun">
&mdash; Function: const char * <b>gnutls_strerror_name</b> (<var>int error</var>)<var><a name="index-gnutls_005fstrerror_005fname-289"></a></var><br>
<blockquote><p><var>error</var>: is an error returned by a gnutls function.

     <p>Return the GnuTLS error code define as a string.  For example,
gnutls_strerror_name (GNUTLS_E_DH_PRIME_UNACCEPTABLE) will return
the string "GNUTLS_E_DH_PRIME_UNACCEPTABLE".

     <p><strong>Returns:</strong> A string corresponding to the symbol name of the error
code.

     <p><strong>Since:</strong> 2.6.0
</p></blockquote></div>

<h4 class="subheading">gnutls_supplemental_get_name</h4>

<p><a name="gnutls_005fsupplemental_005fget_005fname"></a>

<div class="defun">
&mdash; Function: const char * <b>gnutls_supplemental_get_name</b> (<var>gnutls_supplemental_data_format_type_t type</var>)<var><a name="index-gnutls_005fsupplemental_005fget_005fname-290"></a></var><br>
<blockquote><p><var>type</var>: is a supplemental data format type

     <p>Convert a <code>gnutls_supplemental_data_format_type_t</code> value to a
string.

     <p><strong>Returns:</strong> a string that contains the name of the specified
supplemental data format type, or <code>NULL</code> for unknown types. 
</p></blockquote></div>

<h4 class="subheading">gnutls_transport_get_ptr</h4>

<p><a name="gnutls_005ftransport_005fget_005fptr"></a>

<div class="defun">
&mdash; Function: gnutls_transport_ptr_t <b>gnutls_transport_get_ptr</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005ftransport_005fget_005fptr-291"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p>Used to get the first argument of the transport function (like
PUSH and PULL).  This must have been set using
<code>gnutls_transport_set_ptr()</code>.

     <p><strong>Returns:</strong> The first argument of the transport function. 
</p></blockquote></div>

<h4 class="subheading">gnutls_transport_get_ptr2</h4>

<p><a name="gnutls_005ftransport_005fget_005fptr2"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_transport_get_ptr2</b> (<var>gnutls_session_t session, gnutls_transport_ptr_t * recv_ptr, gnutls_transport_ptr_t * send_ptr</var>)<var><a name="index-gnutls_005ftransport_005fget_005fptr2-292"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>recv_ptr</var>: will hold the value for the pull function

     <p><var>send_ptr</var>: will hold the value for the push function

     <p>Used to get the arguments of the transport functions (like PUSH
and PULL).  These should have been set using
<code>gnutls_transport_set_ptr2()</code>. 
</p></blockquote></div>

<h4 class="subheading">gnutls_transport_set_errno</h4>

<p><a name="gnutls_005ftransport_005fset_005ferrno"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_transport_set_errno</b> (<var>gnutls_session_t session, int err</var>)<var><a name="index-gnutls_005ftransport_005fset_005ferrno-293"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>err</var>: error value to store in session-specific errno variable.

     <p>Store  <code>err</code>in the session-specific errno variable.  Useful values
for  <code>err</code>is EAGAIN and EINTR, other values are treated will be
treated as real errors in the push/pull function.

     <p>This function is useful in replacement push and pull functions set by
<code>gnutls_transport_set_push_function()</code> and
<code>gnutls_transport_set_pull_function()</code> under Windows, where the
replacements may not have access to the same  <code>errno</code>variable that is used by GnuTLS (e.g., the application is linked to
msvcr71.dll and gnutls is linked to msvcrt.dll). 
</p></blockquote></div>

<h4 class="subheading">gnutls_transport_set_errno_function</h4>

<p><a name="gnutls_005ftransport_005fset_005ferrno_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_transport_set_errno_function</b> (<var>gnutls_session_t session, gnutls_errno_func errno_func</var>)<var><a name="index-gnutls_005ftransport_005fset_005ferrno_005ffunction-294"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>errno_func</var>: a callback function similar to <code>write()</code>

     <p>This is the function where you set a function to retrieve errno
after a failed push or pull operation.

     <p><code>errno_func</code>is of the form,
int (*gnutls_errno_func)(gnutls_transport_ptr_t);
and should return the errno.

     <p><strong>Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_transport_set_ptr</h4>

<p><a name="gnutls_005ftransport_005fset_005fptr"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_transport_set_ptr</b> (<var>gnutls_session_t session, gnutls_transport_ptr_t ptr</var>)<var><a name="index-gnutls_005ftransport_005fset_005fptr-295"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>ptr</var>: is the value.

     <p>Used to set the first argument of the transport function (for push
and pull callbacks). In berkeley style sockets this function will set the
connection descriptor. 
</p></blockquote></div>

<h4 class="subheading">gnutls_transport_set_ptr2</h4>

<p><a name="gnutls_005ftransport_005fset_005fptr2"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_transport_set_ptr2</b> (<var>gnutls_session_t session, gnutls_transport_ptr_t recv_ptr, gnutls_transport_ptr_t send_ptr</var>)<var><a name="index-gnutls_005ftransport_005fset_005fptr2-296"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>recv_ptr</var>: is the value for the pull function

     <p><var>send_ptr</var>: is the value for the push function

     <p>Used to set the first argument of the transport function (for push
and pull callbacks). In berkeley style sockets this function will set the
connection descriptor.  With this function you can use two different
pointers for receiving and sending. 
</p></blockquote></div>

<h4 class="subheading">gnutls_transport_set_pull_function</h4>

<p><a name="gnutls_005ftransport_005fset_005fpull_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_transport_set_pull_function</b> (<var>gnutls_session_t session, gnutls_pull_func pull_func</var>)<var><a name="index-gnutls_005ftransport_005fset_005fpull_005ffunction-297"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>pull_func</var>: a callback function similar to <code>read()</code>

     <p>This is the function where you set a function for gnutls to receive
data.  Normally, if you use berkeley style sockets, do not need to
use this function since the default recv(2) will probably be ok. 
The callback should return 0 on connection termination, a positive
number indicating the number of bytes received, and -1 on error.

     <p><code>gnutls_pull_func</code>is of the form,
ssize_t (*gnutls_pull_func)(gnutls_transport_ptr_t, void*, size_t);
</p></blockquote></div>

<h4 class="subheading">gnutls_transport_set_pull_timeout_function</h4>

<p><a name="gnutls_005ftransport_005fset_005fpull_005ftimeout_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_transport_set_pull_timeout_function</b> (<var>gnutls_session_t session, gnutls_pull_timeout_func func</var>)<var><a name="index-gnutls_005ftransport_005fset_005fpull_005ftimeout_005ffunction-298"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>func</var>: a callback function

     <p>This is the function where you set a function for gnutls to know
whether data are ready to be received. It should wait for data a
given time frame in milliseconds. The callback should return 0 on
timeout, a positive number if data can be received, and -1 on error. 
You'll need to override this function if <code>select()</code> is not suitable
for the provided transport calls. 
The callback function is used in DTLS only.

     <p><code>gnutls_pull_timeout_func</code>is of the form,
ssize_t (*gnutls_pull_timeout_func)(gnutls_transport_ptr_t, unsigned int ms);

     <p><strong>Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_transport_set_push_function</h4>

<p><a name="gnutls_005ftransport_005fset_005fpush_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_transport_set_push_function</b> (<var>gnutls_session_t session, gnutls_push_func push_func</var>)<var><a name="index-gnutls_005ftransport_005fset_005fpush_005ffunction-299"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>push_func</var>: a callback function similar to <code>write()</code>

     <p>This is the function where you set a push function for gnutls to
use in order to send data.  If you are going to use berkeley style
sockets, you do not need to use this function since the default
send(2) will probably be ok.  Otherwise you should specify this
function for gnutls to be able to send data. 
The callback should return a positive number indicating the
bytes sent, and -1 on error.

     <p><code>push_func</code>is of the form,
ssize_t (*gnutls_push_func)(gnutls_transport_ptr_t, const void*, size_t);
</p></blockquote></div>

<h4 class="subheading">gnutls_transport_set_vec_push_function</h4>

<p><a name="gnutls_005ftransport_005fset_005fvec_005fpush_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_transport_set_vec_push_function</b> (<var>gnutls_session_t session, gnutls_vec_push_func vec_func</var>)<var><a name="index-gnutls_005ftransport_005fset_005fvec_005fpush_005ffunction-300"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>vec_func</var>: a callback function similar to <code>writev()</code>

     <p>Using this function you can override the default writev(2)
function for gnutls to send data. Setting this callback
instead of <code>gnutls_transport_set_push_function()</code> is recommended
since it introduces less overhead in the TLS handshake process.

     <p><code>vec_func</code>is of the form,
ssize_t (*gnutls_vec_push_func) (gnutls_transport_ptr_t, const giovec_t * iov, int iovcnt);

     <p><strong>Since:</strong> 2.12.0
</p></blockquote></div>

<div class="node">
<a name="Datagram-TLS-API"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#X509-certificate-API">X509 certificate API</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Core-TLS-API">Core TLS API</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#API-reference">API reference</a>

</div>

<h3 class="section">C.2 Datagram TLS API</h3>

<p>The prototypes for the following functions lie in
<samp><span class="file">gnutls/dtls.h</span></samp>.

<h4 class="subheading">gnutls_dtls_cookie_send</h4>

<p><a name="gnutls_005fdtls_005fcookie_005fsend"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_dtls_cookie_send</b> (<var>gnutls_datum_t* key, void* client_data, size_t client_data_size, gnutls_dtls_prestate_st* prestate, gnutls_transport_ptr_t ptr, gnutls_push_func push_func</var>)<var><a name="index-gnutls_005fdtls_005fcookie_005fsend-301"></a></var><br>
<blockquote><p><var>key</var>: is a random key to be used at cookie generation

     <p><var>client_data</var>: contains data identifying the client (i.e. address)

     <p><var>client_data_size</var>: The size of client's data

     <p><var>prestate</var>: The previous cookie returned by <code>gnutls_dtls_cookie_verify()</code>

     <p><var>ptr</var>: A transport pointer to be used by  <code>push_func</code>

     <p><var>push_func</var>: A function that will be used to reply

     <p><strong> Description:</strong> This function can be used to prevent denial of service
attacks to a DTLS server by requiring the client to
reply using a cookie sent by this function. That way
it can be ensured that a client we allocated resources
for (i.e. <code>gnutls_session_t</code>) is the one that the
original incoming packet was originated from.

     <p><strong> Returns:</strong> the number of bytes sent, or a negative error code.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_dtls_cookie_verify</h4>

<p><a name="gnutls_005fdtls_005fcookie_005fverify"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_dtls_cookie_verify</b> (<var>gnutls_datum_t* key, void* client_data, size_t client_data_size, void* _msg, size_t msg_size, gnutls_dtls_prestate_st* prestate</var>)<var><a name="index-gnutls_005fdtls_005fcookie_005fverify-302"></a></var><br>
<blockquote><p><var>key</var>: is a random key to be used at cookie generation

     <p><var>client_data</var>: contains data identifying the client (i.e. address)

     <p><var>client_data_size</var>: The size of client's data

     <p><var>_msg</var>: An incoming message that initiates a connection.

     <p><var>msg_size</var>: The size of the message.

     <p><var>prestate</var>: The cookie of this client.

     <p><strong> Description:</strong> This function will verify an incoming message for
a valid cookie. If a valid cookie is returned then
it should be associated with the session using
<code>gnutls_dtls_prestate_set()</code>;

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> (0) on success, or a negative error code.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_dtls_get_data_mtu</h4>

<p><a name="gnutls_005fdtls_005fget_005fdata_005fmtu"></a>

<div class="defun">
&mdash; Function: unsigned int <b>gnutls_dtls_get_data_mtu</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fdtls_005fget_005fdata_005fmtu-303"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><strong> Description:</strong> This function will return the actual maximum transfer unit for
application data. I.e. DTLS headers are subtracted from the
actual MTU.

     <p><strong> Returns:</strong> the maximum allowed transfer unit.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_dtls_get_mtu</h4>

<p><a name="gnutls_005fdtls_005fget_005fmtu"></a>

<div class="defun">
&mdash; Function: unsigned int <b>gnutls_dtls_get_mtu</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fdtls_005fget_005fmtu-304"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><strong> Description:</strong> This function will return the MTU size as set with
<code>gnutls_dtls_set_mtu()</code>. This is not the actual MTU
of data you can transmit. Use <code>gnutls_dtls_get_data_mtu()</code>
for that reason.

     <p><strong> Returns:</strong> the set maximum transfer unit.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_dtls_prestate_set</h4>

<p><a name="gnutls_005fdtls_005fprestate_005fset"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_dtls_prestate_set</b> (<var>gnutls_session_t session, gnutls_dtls_prestate_st* prestate</var>)<var><a name="index-gnutls_005fdtls_005fprestate_005fset-305"></a></var><br>
<blockquote><p><var>session</var>: a new session

     <p><var>prestate</var>: contains the client's prestate

     <p><strong> Description:</strong> This function will associate the prestate acquired by
the cookie authentication with the client, with the newly
established session.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_dtls_set_mtu</h4>

<p><a name="gnutls_005fdtls_005fset_005fmtu"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_dtls_set_mtu</b> (<var>gnutls_session_t session, unsigned int mtu</var>)<var><a name="index-gnutls_005fdtls_005fset_005fmtu-306"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>mtu</var>: The maximum transfer unit of the interface

     <p><strong> Description:</strong> This function will set the maximum transfer unit of the interface
that DTLS packets are expected to leave from.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_dtls_set_timeouts</h4>

<p><a name="gnutls_005fdtls_005fset_005ftimeouts"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_dtls_set_timeouts</b> (<var>gnutls_session_t session, unsigned int retrans_timeout, unsigned int total_timeout</var>)<var><a name="index-gnutls_005fdtls_005fset_005ftimeouts-307"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>retrans_timeout</var>: The time at which a retransmission will occur in milliseconds

     <p><var>total_timeout</var>: The time at which the connection will be aborted, in milliseconds.

     <p><strong> Description:</strong> This function will set the timeouts required for the DTLS handshake
protocol. The retransmission timeout is the time after which a
message from the peer is not received, the previous messages will
be retransmitted. The total timeout is the time after which the
handshake will be aborted with <code>GNUTLS_E_TIMEDOUT</code>.

     <p>The DTLS protocol recommends the values of 1 sec and 60 seconds
respectively.

     <p>If the retransmission timeout is zero then the handshake will operate
in a non-blocking way, i.e., return <code>GNUTLS_E_AGAIN</code>.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_record_get_discarded</h4>

<p><a name="gnutls_005frecord_005fget_005fdiscarded"></a>

<div class="defun">
&mdash; Function: unsigned int <b>gnutls_record_get_discarded</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005frecord_005fget_005fdiscarded-308"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><strong> Description:</strong> Returns the number of discarded packets in a
DTLS connection.

     <p><strong> Returns:</strong> The number of discarded packets.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<div class="node">
<a name="X509-certificate-API"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#OpenPGP-API">OpenPGP API</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Datagram-TLS-API">Datagram TLS API</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#API-reference">API reference</a>

</div>

<h3 class="section">C.3 <acronym>X.509</acronym> certificate API</h3>

<p><a name="index-X_002e509-Functions-309"></a>
The following functions are to be used for <acronym>X.509</acronym> certificate handling. 
Their prototypes lie in <samp><span class="file">gnutls/x509.h</span></samp>.

<h4 class="subheading">gnutls_pkcs7_deinit</h4>

<p><a name="gnutls_005fpkcs7_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_pkcs7_deinit</b> (<var>gnutls_pkcs7_t pkcs7</var>)<var><a name="index-gnutls_005fpkcs7_005fdeinit-310"></a></var><br>
<blockquote><p><var>pkcs7</var>: The structure to be initialized

     <p><strong> Description:</strong> This function will deinitialize a PKCS7 structure. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs7_delete_crl</h4>

<p><a name="gnutls_005fpkcs7_005fdelete_005fcrl"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs7_delete_crl</b> (<var>gnutls_pkcs7_t pkcs7, int indx</var>)<var><a name="index-gnutls_005fpkcs7_005fdelete_005fcrl-311"></a></var><br>
<blockquote><p><var>pkcs7</var>: should contain a <code>gnutls_pkcs7_t</code> structure

     <p><var>indx</var>: the index of the crl to delete

     <p><strong> Description:</strong> This function will delete a crl from a PKCS7 or RFC2630 crl set. 
Index starts from 0. Returns 0 on success.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs7_delete_crt</h4>

<p><a name="gnutls_005fpkcs7_005fdelete_005fcrt"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs7_delete_crt</b> (<var>gnutls_pkcs7_t pkcs7, int indx</var>)<var><a name="index-gnutls_005fpkcs7_005fdelete_005fcrt-312"></a></var><br>
<blockquote><p><var>pkcs7</var>: should contain a gnutls_pkcs7_t structure

     <p><var>indx</var>: the index of the certificate to delete

     <p><strong> Description:</strong> This function will delete a certificate from a PKCS7 or RFC2630
certificate set.  Index starts from 0. Returns 0 on success.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs7_export</h4>

<p><a name="gnutls_005fpkcs7_005fexport"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs7_export</b> (<var>gnutls_pkcs7_t pkcs7, gnutls_x509_crt_fmt_t format, void * output_data, size_t * output_data_size</var>)<var><a name="index-gnutls_005fpkcs7_005fexport-313"></a></var><br>
<blockquote><p><var>pkcs7</var>: Holds the pkcs7 structure

     <p><var>format</var>: the format of output params. One of PEM or DER.

     <p><var>output_data</var>: will contain a structure PEM or DER encoded

     <p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)

     <p><strong> Description:</strong> This function will export the pkcs7 structure to DER or PEM format.

     <p>If the buffer provided is not long enough to hold the output, then
* <code>output_data_size</code>is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>
will be returned.

     <p>If the structure is PEM encoded, it will have a header
of "BEGIN PKCS7".

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs7_get_crl_count</h4>

<p><a name="gnutls_005fpkcs7_005fget_005fcrl_005fcount"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs7_get_crl_count</b> (<var>gnutls_pkcs7_t pkcs7</var>)<var><a name="index-gnutls_005fpkcs7_005fget_005fcrl_005fcount-314"></a></var><br>
<blockquote><p><var>pkcs7</var>: should contain a gnutls_pkcs7_t structure

     <p><strong> Description:</strong> This function will return the number of certifcates in the PKCS7
or RFC2630 crl set.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs7_get_crl_raw</h4>

<p><a name="gnutls_005fpkcs7_005fget_005fcrl_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs7_get_crl_raw</b> (<var>gnutls_pkcs7_t pkcs7, int indx, void * crl, size_t * crl_size</var>)<var><a name="index-gnutls_005fpkcs7_005fget_005fcrl_005fraw-315"></a></var><br>
<blockquote><p><var>pkcs7</var>: should contain a <code>gnutls_pkcs7_t</code> structure

     <p><var>indx</var>: contains the index of the crl to extract

     <p><var>crl</var>: the contents of the crl will be copied there (may be null)

     <p><var>crl_size</var>: should hold the size of the crl

     <p><strong> Description:</strong> This function will return a crl of the PKCS7 or RFC2630 crl set.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.  If the provided buffer is not long enough,
then  <code>crl_size</code>is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> is
returned.  After the last crl has been read
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> will be returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs7_get_crt_count</h4>

<p><a name="gnutls_005fpkcs7_005fget_005fcrt_005fcount"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs7_get_crt_count</b> (<var>gnutls_pkcs7_t pkcs7</var>)<var><a name="index-gnutls_005fpkcs7_005fget_005fcrt_005fcount-316"></a></var><br>
<blockquote><p><var>pkcs7</var>: should contain a <code>gnutls_pkcs7_t</code> structure

     <p><strong> Description:</strong> This function will return the number of certifcates in the PKCS7
or RFC2630 certificate set.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs7_get_crt_raw</h4>

<p><a name="gnutls_005fpkcs7_005fget_005fcrt_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs7_get_crt_raw</b> (<var>gnutls_pkcs7_t pkcs7, int indx, void * certificate, size_t * certificate_size</var>)<var><a name="index-gnutls_005fpkcs7_005fget_005fcrt_005fraw-317"></a></var><br>
<blockquote><p><var>pkcs7</var>: should contain a gnutls_pkcs7_t structure

     <p><var>indx</var>: contains the index of the certificate to extract

     <p><var>certificate</var>: the contents of the certificate will be copied
there (may be null)

     <p><var>certificate_size</var>: should hold the size of the certificate

     <p><strong> Description:</strong> This function will return a certificate of the PKCS7 or RFC2630
certificate set.

     <p>After the last certificate has been read
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> will be returned.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.  If the provided buffer is not long enough,
then  <code>certificate_size</code>is updated and
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs7_import</h4>

<p><a name="gnutls_005fpkcs7_005fimport"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs7_import</b> (<var>gnutls_pkcs7_t pkcs7, const gnutls_datum_t * data, gnutls_x509_crt_fmt_t format</var>)<var><a name="index-gnutls_005fpkcs7_005fimport-318"></a></var><br>
<blockquote><p><var>pkcs7</var>: The structure to store the parsed PKCS7.

     <p><var>data</var>: The DER or PEM encoded PKCS7.

     <p><var>format</var>: One of DER or PEM

     <p><strong> Description:</strong> This function will convert the given DER or PEM encoded PKCS7 to
the native <code>gnutls_pkcs7_t</code> format.  The output will be stored in
 <code>pkcs7</code>.

     <p>If the PKCS7 is PEM encoded it should have a header of "PKCS7".

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs7_init</h4>

<p><a name="gnutls_005fpkcs7_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs7_init</b> (<var>gnutls_pkcs7_t * pkcs7</var>)<var><a name="index-gnutls_005fpkcs7_005finit-319"></a></var><br>
<blockquote><p><var>pkcs7</var>: The structure to be initialized

     <p><strong> Description:</strong> This function will initialize a PKCS7 structure. PKCS7 structures
usually contain lists of X.509 Certificates and X.509 Certificate
revocation lists.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs7_set_crl</h4>

<p><a name="gnutls_005fpkcs7_005fset_005fcrl"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs7_set_crl</b> (<var>gnutls_pkcs7_t pkcs7, gnutls_x509_crl_t crl</var>)<var><a name="index-gnutls_005fpkcs7_005fset_005fcrl-320"></a></var><br>
<blockquote><p><var>pkcs7</var>: should contain a <code>gnutls_pkcs7_t</code> structure

     <p><var>crl</var>: the DER encoded crl to be added

     <p><strong> Description:</strong> This function will add a parsed CRL to the PKCS7 or RFC2630 crl
set.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs7_set_crl_raw</h4>

<p><a name="gnutls_005fpkcs7_005fset_005fcrl_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs7_set_crl_raw</b> (<var>gnutls_pkcs7_t pkcs7, const gnutls_datum_t * crl</var>)<var><a name="index-gnutls_005fpkcs7_005fset_005fcrl_005fraw-321"></a></var><br>
<blockquote><p><var>pkcs7</var>: should contain a <code>gnutls_pkcs7_t</code> structure

     <p><var>crl</var>: the DER encoded crl to be added

     <p><strong> Description:</strong> This function will add a crl to the PKCS7 or RFC2630 crl set.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs7_set_crt</h4>

<p><a name="gnutls_005fpkcs7_005fset_005fcrt"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs7_set_crt</b> (<var>gnutls_pkcs7_t pkcs7, gnutls_x509_crt_t crt</var>)<var><a name="index-gnutls_005fpkcs7_005fset_005fcrt-322"></a></var><br>
<blockquote><p><var>pkcs7</var>: should contain a <code>gnutls_pkcs7_t</code> structure

     <p><var>crt</var>: the certificate to be copied.

     <p><strong> Description:</strong> This function will add a parsed certificate to the PKCS7 or
RFC2630 certificate set.  This is a wrapper function over
<code>gnutls_pkcs7_set_crt_raw()</code> .

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs7_set_crt_raw</h4>

<p><a name="gnutls_005fpkcs7_005fset_005fcrt_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs7_set_crt_raw</b> (<var>gnutls_pkcs7_t pkcs7, const gnutls_datum_t * crt</var>)<var><a name="index-gnutls_005fpkcs7_005fset_005fcrt_005fraw-323"></a></var><br>
<blockquote><p><var>pkcs7</var>: should contain a <code>gnutls_pkcs7_t</code> structure

     <p><var>crt</var>: the DER encoded certificate to be added

     <p><strong> Description:</strong> This function will add a certificate to the PKCS7 or RFC2630
certificate set.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_check_issuer</h4>

<p><a name="gnutls_005fx509_005fcrl_005fcheck_005fissuer"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_check_issuer</b> (<var>gnutls_x509_crl_t crl, gnutls_x509_crt_t issuer</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fcheck_005fissuer-324"></a></var><br>
<blockquote><p><var>crl</var>: is the CRL to be checked

     <p><var>issuer</var>: is the certificate of a possible issuer

     <p><strong> Description:</strong> This function will check if the given CRL was issued by the given
issuer certificate.  It will return true (1) if the given CRL was
issued by the given issuer, and false (0) if not.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_deinit</h4>

<p><a name="gnutls_005fx509_005fcrl_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_x509_crl_deinit</b> (<var>gnutls_x509_crl_t crl</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fdeinit-325"></a></var><br>
<blockquote><p><var>crl</var>: The structure to be initialized

     <p><strong> Description:</strong> This function will deinitialize a CRL structure. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_export</h4>

<p><a name="gnutls_005fx509_005fcrl_005fexport"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_export</b> (<var>gnutls_x509_crl_t crl, gnutls_x509_crt_fmt_t format, void * output_data, size_t * output_data_size</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fexport-326"></a></var><br>
<blockquote><p><var>crl</var>: Holds the revocation list

     <p><var>format</var>: the format of output params. One of PEM or DER.

     <p><var>output_data</var>: will contain a private key PEM or DER encoded

     <p><var>output_data_size</var>: holds the size of output_data (and will
be replaced by the actual size of parameters)

     <p><strong> Description:</strong> This function will export the revocation list to DER or PEM format.

     <p>If the buffer provided is not long enough to hold the output, then
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> will be returned.

     <p>If the structure is PEM encoded, it will have a header
of "BEGIN X509 CRL".

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. and a negative error code on failure. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_get_authority_key_id</h4>

<p><a name="gnutls_005fx509_005fcrl_005fget_005fauthority_005fkey_005fid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_get_authority_key_id</b> (<var>gnutls_x509_crl_t crl, void * ret, size_t * ret_size, unsigned int * critical</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fget_005fauthority_005fkey_005fid-327"></a></var><br>
<blockquote><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code> structure

     <p><var>ret</var>: The place where the identifier will be copied

     <p><var>ret_size</var>: Holds the size of the result field.

     <p><var>critical</var>: will be non (0) if the extension is marked as critical
(may be null)

     <p><strong> Description:</strong> This function will return the CRL authority's key identifier.  This
is obtained by the X.509 Authority Key identifier extension field
(2.5.29.35).  Note that this function only returns the
keyIdentifier field of the extension.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error code in case of an error.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_get_crt_count</h4>

<p><a name="gnutls_005fx509_005fcrl_005fget_005fcrt_005fcount"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_get_crt_count</b> (<var>gnutls_x509_crl_t crl</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fget_005fcrt_005fcount-328"></a></var><br>
<blockquote><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code> structure

     <p><strong> Description:</strong> This function will return the number of revoked certificates in the
given CRL.

     <p><strong> Returns:</strong> number of certificates, a negative error code on failure. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_get_crt_serial</h4>

<p><a name="gnutls_005fx509_005fcrl_005fget_005fcrt_005fserial"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_get_crt_serial</b> (<var>gnutls_x509_crl_t crl, int indx, unsigned char * serial, size_t * serial_size, time_t * t</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fget_005fcrt_005fserial-329"></a></var><br>
<blockquote><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code> structure

     <p><var>indx</var>: the index of the certificate to extract (starting from 0)

     <p><var>serial</var>: where the serial number will be copied

     <p><var>serial_size</var>: initially holds the size of serial

     <p><var>t</var>: if non null, will hold the time this certificate was revoked

     <p><strong> Description:</strong> This function will retrieve the serial number of the specified, by
the index, revoked certificate.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. and a negative error code on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_get_dn_oid</h4>

<p><a name="gnutls_005fx509_005fcrl_005fget_005fdn_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_get_dn_oid</b> (<var>gnutls_x509_crl_t crl, int indx, void * oid, size_t * sizeof_oid</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fget_005fdn_005foid-330"></a></var><br>
<blockquote><p><var>crl</var>: should contain a gnutls_x509_crl_t structure

     <p><var>indx</var>: Specifies which DN OID to send. Use (0) to get the first one.

     <p><var>oid</var>: a pointer to a structure to hold the name (may be null)

     <p><var>sizeof_oid</var>: initially holds the size of 'oid'

     <p><strong> Description:</strong> This function will extract the requested OID of the name of the CRL
issuer, specified by the given index.

     <p>If oid is null then only the size will be filled.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> if the provided buffer is
not long enough, and in that case the sizeof_oid will be updated
with the required size.  On success 0 is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_get_extension_data</h4>

<p><a name="gnutls_005fx509_005fcrl_005fget_005fextension_005fdata"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_get_extension_data</b> (<var>gnutls_x509_crl_t crl, int indx, void * data, size_t * sizeof_data</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fget_005fextension_005fdata-331"></a></var><br>
<blockquote><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code> structure

     <p><var>indx</var>: Specifies which extension OID to send. Use (0) to get the first one.

     <p><var>data</var>: a pointer to a structure to hold the data (may be null)

     <p><var>sizeof_data</var>: initially holds the size of  <code>oid</code>

     <p><strong> Description:</strong> This function will return the requested extension data in the CRL. 
The extension data will be stored as a string in the provided
buffer.

     <p>Use <code>gnutls_x509_crl_get_extension_info()</code> to extract the OID and
critical flag.  Use <code>gnutls_x509_crl_get_extension_info()</code> instead,
if you want to get data indexed by the extension OID rather than
sequence.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error code in case of an error.  If your have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>
will be returned.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_get_extension_info</h4>

<p><a name="gnutls_005fx509_005fcrl_005fget_005fextension_005finfo"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_get_extension_info</b> (<var>gnutls_x509_crl_t crl, int indx, void * oid, size_t * sizeof_oid, int * critical</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fget_005fextension_005finfo-332"></a></var><br>
<blockquote><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code> structure

     <p><var>indx</var>: Specifies which extension OID to send, use (0) to get the first one.

     <p><var>oid</var>: a pointer to a structure to hold the OID

     <p><var>sizeof_oid</var>: initially holds the maximum size of  <code>oid</code>, on return
holds actual size of  <code>oid</code>.

     <p><var>critical</var>: output variable with critical flag, may be NULL.

     <p><strong> Description:</strong> This function will return the requested extension OID in the CRL,
and the critical flag for it.  The extension OID will be stored as
a string in the provided buffer.  Use
<code>gnutls_x509_crl_get_extension_data()</code> to extract the data.

     <p>If the buffer provided is not long enough to hold the output, then
* <code>sizeof_oid</code>is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> will be
returned.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error code in case of an error.  If your have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>
will be returned.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_get_extension_oid</h4>

<p><a name="gnutls_005fx509_005fcrl_005fget_005fextension_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_get_extension_oid</b> (<var>gnutls_x509_crl_t crl, int indx, void * oid, size_t * sizeof_oid</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fget_005fextension_005foid-333"></a></var><br>
<blockquote><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code> structure

     <p><var>indx</var>: Specifies which extension OID to send, use (0) to get the first one.

     <p><var>oid</var>: a pointer to a structure to hold the OID (may be null)

     <p><var>sizeof_oid</var>: initially holds the size of  <code>oid</code>

     <p><strong> Description:</strong> This function will return the requested extension OID in the CRL. 
The extension OID will be stored as a string in the provided
buffer.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error code in case of an error.  If your have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>
will be returned.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_get_issuer_dn</h4>

<p><a name="gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_get_issuer_dn</b> (<var>const gnutls_x509_crl_t crl, char * buf, size_t * sizeof_buf</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn-334"></a></var><br>
<blockquote><p><var>crl</var>: should contain a gnutls_x509_crl_t structure

     <p><var>buf</var>: a pointer to a structure to hold the peer's name (may be null)

     <p><var>sizeof_buf</var>: initially holds the size of  <code>buf</code>

     <p><strong> Description:</strong> This function will copy the name of the CRL issuer in the provided
buffer. The name will be in the form "C=xxxx,O=yyyy,CN=zzzz" as
described in RFC2253. The output string will be ASCII or UTF-8
encoded, depending on the certificate data.

     <p>If buf is <code>NULL</code> then only the size will be filled.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> if the provided buffer is
not long enough, and in that case the sizeof_buf will be updated
with the required size, and 0 on success. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_get_issuer_dn_by_oid</h4>

<p><a name="gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn_005fby_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_get_issuer_dn_by_oid</b> (<var>gnutls_x509_crl_t crl, const char * oid, int indx, unsigned int raw_flag, void * buf, size_t * sizeof_buf</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn_005fby_005foid-335"></a></var><br>
<blockquote><p><var>crl</var>: should contain a gnutls_x509_crl_t structure

     <p><var>oid</var>: holds an Object Identified in null terminated string

     <p><var>indx</var>: In case multiple same OIDs exist in the RDN, this specifies which to send. Use (0) to get the first one.

     <p><var>raw_flag</var>: If non (0) returns the raw DER data of the DN part.

     <p><var>buf</var>: a pointer to a structure to hold the peer's name (may be null)

     <p><var>sizeof_buf</var>: initially holds the size of  <code>buf</code>

     <p><strong> Description:</strong> This function will extract the part of the name of the CRL issuer
specified by the given OID. The output will be encoded as described
in RFC2253. The output string will be ASCII or UTF-8 encoded,
depending on the certificate data.

     <p>Some helper macros with popular OIDs can be found in gnutls/x509.h
If raw flag is (0), this function will only return known OIDs as
text. Other OIDs will be DER encoded, as described in RFC2253 &ndash; in
hex format with a '\#' prefix.  You can check about known OIDs
using <code>gnutls_x509_dn_oid_known()</code>.

     <p>If buf is null then only the size will be filled.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> if the provided buffer is
not long enough, and in that case the sizeof_buf will be updated
with the required size, and 0 on success. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_get_next_update</h4>

<p><a name="gnutls_005fx509_005fcrl_005fget_005fnext_005fupdate"></a>

<div class="defun">
&mdash; Function: time_t <b>gnutls_x509_crl_get_next_update</b> (<var>gnutls_x509_crl_t crl</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fget_005fnext_005fupdate-336"></a></var><br>
<blockquote><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code> structure

     <p><strong> Description:</strong> This function will return the time the next CRL will be issued. 
This field is optional in a CRL so it might be normal to get an
error instead.

     <p><strong> Returns:</strong> when the next CRL will be issued, or (time_t)-1 on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_get_number</h4>

<p><a name="gnutls_005fx509_005fcrl_005fget_005fnumber"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_get_number</b> (<var>gnutls_x509_crl_t crl, void * ret, size_t * ret_size, unsigned int * critical</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fget_005fnumber-337"></a></var><br>
<blockquote><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code> structure

     <p><var>ret</var>: The place where the number will be copied

     <p><var>ret_size</var>: Holds the size of the result field.

     <p><var>critical</var>: will be non (0) if the extension is marked as critical
(may be null)

     <p><strong> Description:</strong> This function will return the CRL number extension.  This is
obtained by the CRL Number extension field (2.5.29.20).

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error code in case of an error.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_get_raw_issuer_dn</h4>

<p><a name="gnutls_005fx509_005fcrl_005fget_005fraw_005fissuer_005fdn"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_get_raw_issuer_dn</b> (<var>gnutls_x509_crl_t crl, gnutls_datum_t * dn</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fget_005fraw_005fissuer_005fdn-338"></a></var><br>
<blockquote><p><var>crl</var>: should contain a gnutls_x509_crl_t structure

     <p><var>dn</var>: will hold the starting point of the DN

     <p><strong> Description:</strong> This function will return a pointer to the DER encoded DN structure
and the length.

     <p><strong> Returns:</strong> a negative error code on error, and (0) on success.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_get_signature</h4>

<p><a name="gnutls_005fx509_005fcrl_005fget_005fsignature"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_get_signature</b> (<var>gnutls_x509_crl_t crl, char * sig, size_t * sizeof_sig</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fget_005fsignature-339"></a></var><br>
<blockquote><p><var>crl</var>: should contain a gnutls_x509_crl_t structure

     <p><var>sig</var>: a pointer where the signature part will be copied (may be null).

     <p><var>sizeof_sig</var>: initially holds the size of  <code>sig</code>

     <p><strong> Description:</strong> This function will extract the signature field of a CRL.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. and a negative error code on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_get_signature_algorithm</h4>

<p><a name="gnutls_005fx509_005fcrl_005fget_005fsignature_005falgorithm"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_get_signature_algorithm</b> (<var>gnutls_x509_crl_t crl</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fget_005fsignature_005falgorithm-340"></a></var><br>
<blockquote><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code> structure

     <p><strong> Description:</strong> This function will return a value of the <code>gnutls_sign_algorithm_t</code>
enumeration that is the signature algorithm.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_get_this_update</h4>

<p><a name="gnutls_005fx509_005fcrl_005fget_005fthis_005fupdate"></a>

<div class="defun">
&mdash; Function: time_t <b>gnutls_x509_crl_get_this_update</b> (<var>gnutls_x509_crl_t crl</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fget_005fthis_005fupdate-341"></a></var><br>
<blockquote><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code> structure

     <p><strong> Description:</strong> This function will return the time this CRL was issued.

     <p><strong> Returns:</strong> when the CRL was issued, or (time_t)-1 on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_get_version</h4>

<p><a name="gnutls_005fx509_005fcrl_005fget_005fversion"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_get_version</b> (<var>gnutls_x509_crl_t crl</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fget_005fversion-342"></a></var><br>
<blockquote><p><var>crl</var>: should contain a <code>gnutls_x509_crl_t</code> structure

     <p><strong> Description:</strong> This function will return the version of the specified CRL.

     <p><strong> Returns:</strong> The version number, or a negative error code on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_import</h4>

<p><a name="gnutls_005fx509_005fcrl_005fimport"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_import</b> (<var>gnutls_x509_crl_t crl, const gnutls_datum_t * data, gnutls_x509_crt_fmt_t format</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fimport-343"></a></var><br>
<blockquote><p><var>crl</var>: The structure to store the parsed CRL.

     <p><var>data</var>: The DER or PEM encoded CRL.

     <p><var>format</var>: One of DER or PEM

     <p><strong> Description:</strong> This function will convert the given DER or PEM encoded CRL
to the native <code>gnutls_x509_crl_t</code> format. The output will be stored in 'crl'.

     <p>If the CRL is PEM encoded it should have a header of "X509 CRL".

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_init</h4>

<p><a name="gnutls_005fx509_005fcrl_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_init</b> (<var>gnutls_x509_crl_t * crl</var>)<var><a name="index-gnutls_005fx509_005fcrl_005finit-344"></a></var><br>
<blockquote><p><var>crl</var>: The structure to be initialized

     <p><strong> Description:</strong> This function will initialize a CRL structure. CRL stands for
Certificate Revocation List. A revocation list usually contains
lists of certificate serial numbers that have been revoked by an
Authority. The revocation lists are always signed with the
authority's private key.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_list_import</h4>

<p><a name="gnutls_005fx509_005fcrl_005flist_005fimport"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_list_import</b> (<var>gnutls_x509_crl_t * crls, unsigned int * crl_max, const gnutls_datum_t * data, gnutls_x509_crt_fmt_t format, unsigned int flags</var>)<var><a name="index-gnutls_005fx509_005fcrl_005flist_005fimport-345"></a></var><br>
<blockquote><p><var>crls</var>: The structures to store the parsed CRLs. Must not be initialized.

     <p><var>crl_max</var>: Initially must hold the maximum number of crls. It will be updated with the number of crls available.

     <p><var>data</var>: The PEM encoded CRLs

     <p><var>format</var>: One of DER or PEM.

     <p><var>flags</var>: must be (0) or an OR'd sequence of gnutls_certificate_import_flags.

     <p><strong> Description:</strong> This function will convert the given PEM encoded CRL list
to the native gnutls_x509_crl_t format. The output will be stored
in  <code>crls</code>.  They will be automatically initialized.

     <p>If the Certificate is PEM encoded it should have a header of "X509 CRL".

     <p><strong> Returns:</strong> the number of certificates read or a negative error value.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_list_import2</h4>

<p><a name="gnutls_005fx509_005fcrl_005flist_005fimport2"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_list_import2</b> (<var>gnutls_x509_crl_t ** crls, unsigned int * size, const gnutls_datum_t * data, gnutls_x509_crt_fmt_t format, unsigned int flags</var>)<var><a name="index-gnutls_005fx509_005fcrl_005flist_005fimport2-346"></a></var><br>
<blockquote><p><var>crls</var>: The structures to store the parsed crl list. Must not be initialized.

     <p><var>size</var>: It will contain the size of the list.

     <p><var>data</var>: The PEM encoded CRL.

     <p><var>format</var>: One of DER or PEM.

     <p><var>flags</var>: must be (0) or an OR'd sequence of gnutls_certificate_import_flags.

     <p><strong> Description:</strong> This function will convert the given PEM encoded CRL list
to the native gnutls_x509_crl_t format. The output will be stored
in  <code>crls</code>.  They will be automatically initialized.

     <p>If the Certificate is PEM encoded it should have a header of "X509
CRL".

     <p><strong> Returns:</strong> the number of certificates read or a negative error value.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_print</h4>

<p><a name="gnutls_005fx509_005fcrl_005fprint"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_print</b> (<var>gnutls_x509_crl_t crl, gnutls_certificate_print_formats_t format, gnutls_datum_t * out</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fprint-347"></a></var><br>
<blockquote><p><var>crl</var>: The structure to be printed

     <p><var>format</var>: Indicate the format to use

     <p><var>out</var>: Newly allocated datum with (0) terminated string.

     <p><strong> Description:</strong> This function will pretty print a X.509 certificate revocation
list, suitable for display to a human.

     <p>The output  <code>out</code>needs to be deallocate using <code>gnutls_free()</code>.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_set_authority_key_id</h4>

<p><a name="gnutls_005fx509_005fcrl_005fset_005fauthority_005fkey_005fid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_set_authority_key_id</b> (<var>gnutls_x509_crl_t crl, const void * id, size_t id_size</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fset_005fauthority_005fkey_005fid-348"></a></var><br>
<blockquote><p><var>crl</var>: a CRL of type <code>gnutls_x509_crl_t</code>

     <p><var>id</var>: The key ID

     <p><var>id_size</var>: Holds the size of the serial field.

     <p><strong> Description:</strong> This function will set the CRL's authority key ID extension.  Only
the keyIdentifier field can be set with this function. This may
be used by an authority that holds multiple private keys, to distinguish
the used key.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_set_crt</h4>

<p><a name="gnutls_005fx509_005fcrl_005fset_005fcrt"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_set_crt</b> (<var>gnutls_x509_crl_t crl, gnutls_x509_crt_t crt, time_t revocation_time</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fset_005fcrt-349"></a></var><br>
<blockquote><p><var>crl</var>: should contain a gnutls_x509_crl_t structure

     <p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code> with the revoked certificate

     <p><var>revocation_time</var>: The time this certificate was revoked

     <p><strong> Description:</strong> This function will set a revoked certificate's serial number to the CRL.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_set_crt_serial</h4>

<p><a name="gnutls_005fx509_005fcrl_005fset_005fcrt_005fserial"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_set_crt_serial</b> (<var>gnutls_x509_crl_t crl, const void * serial, size_t serial_size, time_t revocation_time</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fset_005fcrt_005fserial-350"></a></var><br>
<blockquote><p><var>crl</var>: should contain a gnutls_x509_crl_t structure

     <p><var>serial</var>: The revoked certificate's serial number

     <p><var>serial_size</var>: Holds the size of the serial field.

     <p><var>revocation_time</var>: The time this certificate was revoked

     <p><strong> Description:</strong> This function will set a revoked certificate's serial number to the CRL.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_set_next_update</h4>

<p><a name="gnutls_005fx509_005fcrl_005fset_005fnext_005fupdate"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_set_next_update</b> (<var>gnutls_x509_crl_t crl, time_t exp_time</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fset_005fnext_005fupdate-351"></a></var><br>
<blockquote><p><var>crl</var>: should contain a gnutls_x509_crl_t structure

     <p><var>exp_time</var>: The actual time

     <p><strong> Description:</strong> This function will set the time this CRL will be updated.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_set_number</h4>

<p><a name="gnutls_005fx509_005fcrl_005fset_005fnumber"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_set_number</b> (<var>gnutls_x509_crl_t crl, const void * nr, size_t nr_size</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fset_005fnumber-352"></a></var><br>
<blockquote><p><var>crl</var>: a CRL of type <code>gnutls_x509_crl_t</code>

     <p><var>nr</var>: The CRL number

     <p><var>nr_size</var>: Holds the size of the nr field.

     <p><strong> Description:</strong> This function will set the CRL's number extension. This
is to be used as a unique and monotonic number assigned to
the CRL by the authority.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_set_this_update</h4>

<p><a name="gnutls_005fx509_005fcrl_005fset_005fthis_005fupdate"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_set_this_update</b> (<var>gnutls_x509_crl_t crl, time_t act_time</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fset_005fthis_005fupdate-353"></a></var><br>
<blockquote><p><var>crl</var>: should contain a gnutls_x509_crl_t structure

     <p><var>act_time</var>: The actual time

     <p><strong> Description:</strong> This function will set the time this CRL was issued.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_set_version</h4>

<p><a name="gnutls_005fx509_005fcrl_005fset_005fversion"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_set_version</b> (<var>gnutls_x509_crl_t crl, unsigned int version</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fset_005fversion-354"></a></var><br>
<blockquote><p><var>crl</var>: should contain a gnutls_x509_crl_t structure

     <p><var>version</var>: holds the version number. For CRLv1 crls must be 1.

     <p><strong> Description:</strong> This function will set the version of the CRL. This
must be one for CRL version 1, and so on. The CRLs generated
by gnutls should have a version number of 2.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_sign2</h4>

<p><a name="gnutls_005fx509_005fcrl_005fsign2"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_sign2</b> (<var>gnutls_x509_crl_t crl, gnutls_x509_crt_t issuer, gnutls_x509_privkey_t issuer_key, gnutls_digest_algorithm_t dig, unsigned int flags</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fsign2-355"></a></var><br>
<blockquote><p><var>crl</var>: should contain a gnutls_x509_crl_t structure

     <p><var>issuer</var>: is the certificate of the certificate issuer

     <p><var>issuer_key</var>: holds the issuer's private key

     <p><var>dig</var>: The message digest to use. GNUTLS_DIG_SHA1 is the safe choice unless you know what you're doing.

     <p><var>flags</var>: must be 0

     <p><strong> Description:</strong> This function will sign the CRL with the issuer's private key, and
will copy the issuer's information into the CRL.

     <p>This must be the last step in a certificate CRL since all
the previously set parameters are now signed.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_verify</h4>

<p><a name="gnutls_005fx509_005fcrl_005fverify"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_verify</b> (<var>gnutls_x509_crl_t crl, const gnutls_x509_crt_t * CA_list, int CA_list_length, unsigned int flags, unsigned int * verify</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fverify-356"></a></var><br>
<blockquote><p><var>crl</var>: is the crl to be verified

     <p><var>CA_list</var>: is a certificate list that is considered to be trusted one

     <p><var>CA_list_length</var>: holds the number of CA certificates in CA_list

     <p><var>flags</var>: Flags that may be used to change the verification algorithm. Use OR of the gnutls_certificate_verify_flags enumerations.

     <p><var>verify</var>: will hold the crl verification output.

     <p><strong> Description:</strong> This function will try to verify the given crl and return its status. 
See <code>gnutls_x509_crt_list_verify()</code> for a detailed description of
return values.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_deinit</h4>

<p><a name="gnutls_005fx509_005fcrq_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_x509_crq_deinit</b> (<var>gnutls_x509_crq_t crq</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fdeinit-357"></a></var><br>
<blockquote><p><var>crq</var>: The structure to be initialized

     <p><strong> Description:</strong> This function will deinitialize a PKCS<code>10</code> certificate request
structure. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_export</h4>

<p><a name="gnutls_005fx509_005fcrq_005fexport"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_export</b> (<var>gnutls_x509_crq_t crq, gnutls_x509_crt_fmt_t format, void * output_data, size_t * output_data_size</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fexport-358"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><var>format</var>: the format of output params. One of PEM or DER.

     <p><var>output_data</var>: will contain a certificate request PEM or DER encoded

     <p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)

     <p><strong> Description:</strong> This function will export the certificate request to a PEM or DER
encoded PKCS10 structure.

     <p>If the buffer provided is not long enough to hold the output, then
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> will be returned and
* <code>output_data_size</code>will be updated.

     <p>If the structure is PEM encoded, it will have a header of "BEGIN
NEW CERTIFICATE REQUEST".

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_get_attribute_by_oid</h4>

<p><a name="gnutls_005fx509_005fcrq_005fget_005fattribute_005fby_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_get_attribute_by_oid</b> (<var>gnutls_x509_crq_t crq, const char * oid, int indx, void * buf, size_t * sizeof_buf</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fget_005fattribute_005fby_005foid-359"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><var>oid</var>: holds an Object Identified in (0)-terminated string

     <p><var>indx</var>: In case multiple same OIDs exist in the attribute list, this
specifies which to send, use (0) to get the first one

     <p><var>buf</var>: a pointer to a structure to hold the attribute data (may be <code>NULL</code>)

     <p><var>sizeof_buf</var>: initially holds the size of  <code>buf</code>

     <p><strong> Description:</strong> This function will return the attribute in the certificate request
specified by the given Object ID.  The attribute will be DER
encoded.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_get_attribute_data</h4>

<p><a name="gnutls_005fx509_005fcrq_005fget_005fattribute_005fdata"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_get_attribute_data</b> (<var>gnutls_x509_crq_t crq, int indx, void * data, size_t * sizeof_data</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fget_005fattribute_005fdata-360"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><var>indx</var>: Specifies which attribute OID to send. Use (0) to get the first one.

     <p><var>data</var>: a pointer to a structure to hold the data (may be null)

     <p><var>sizeof_data</var>: initially holds the size of  <code>oid</code>

     <p><strong> Description:</strong> This function will return the requested attribute data in the
certificate request.  The attribute data will be stored as a string in the
provided buffer.

     <p>Use <code>gnutls_x509_crq_get_attribute_info()</code> to extract the OID. 
Use <code>gnutls_x509_crq_get_attribute_by_oid()</code> instead,
if you want to get data indexed by the attribute OID rather than
sequence.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error code in case of an error.  If your have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>
will be returned.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_get_attribute_info</h4>

<p><a name="gnutls_005fx509_005fcrq_005fget_005fattribute_005finfo"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_get_attribute_info</b> (<var>gnutls_x509_crq_t crq, int indx, void * oid, size_t * sizeof_oid</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fget_005fattribute_005finfo-361"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><var>indx</var>: Specifies which attribute OID to send. Use (0) to get the first one.

     <p><var>oid</var>: a pointer to a structure to hold the OID

     <p><var>sizeof_oid</var>: initially holds the maximum size of  <code>oid</code>, on return
holds actual size of  <code>oid</code>.

     <p><strong> Description:</strong> This function will return the requested attribute OID in the
certificate, and the critical flag for it.  The attribute OID will
be stored as a string in the provided buffer.  Use
<code>gnutls_x509_crq_get_attribute_data()</code> to extract the data.

     <p>If the buffer provided is not long enough to hold the output, then
* <code>sizeof_oid</code>is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> will be
returned.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error code in case of an error.  If your have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>
will be returned.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_get_basic_constraints</h4>

<p><a name="gnutls_005fx509_005fcrq_005fget_005fbasic_005fconstraints"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_get_basic_constraints</b> (<var>gnutls_x509_crq_t crq, unsigned int * critical, unsigned int * ca, int * pathlen</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fget_005fbasic_005fconstraints-362"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><var>critical</var>: will be non (0) if the extension is marked as critical

     <p><var>ca</var>: pointer to output integer indicating CA status, may be NULL,
value is 1 if the certificate CA flag is set, 0 otherwise.

     <p><var>pathlen</var>: pointer to output integer indicating path length (may be
NULL), non-negative error codes indicate a present pathLenConstraint
field and the actual value, -1 indicate that the field is absent.

     <p><strong> Description:</strong> This function will read the certificate's basic constraints, and
return the certificates CA status.  It reads the basicConstraints
X.509 extension (2.5.29.19).

     <p><strong> Returns:</strong> If the certificate is a CA a positive value will be
returned, or (0) if the certificate does not have CA flag set. 
A negative error code may be returned in case of errors.  If the
certificate does not contain the basicConstraints extension
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> will be returned.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_get_challenge_password</h4>

<p><a name="gnutls_005fx509_005fcrq_005fget_005fchallenge_005fpassword"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_get_challenge_password</b> (<var>gnutls_x509_crq_t crq, char * pass, size_t * sizeof_pass</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fget_005fchallenge_005fpassword-363"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><var>pass</var>: will hold a (0)-terminated password string

     <p><var>sizeof_pass</var>: Initially holds the size of  <code>pass</code>.

     <p><strong> Description:</strong> This function will return the challenge password in the request. 
The challenge password is intended to be used for requesting a
revocation of the certificate.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_get_dn</h4>

<p><a name="gnutls_005fx509_005fcrq_005fget_005fdn"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_get_dn</b> (<var>gnutls_x509_crq_t crq, char * buf, size_t * sizeof_buf</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fget_005fdn-364"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><var>buf</var>: a pointer to a structure to hold the name (may be <code>NULL</code>)

     <p><var>sizeof_buf</var>: initially holds the size of  <code>buf</code>

     <p><strong> Description:</strong> This function will copy the name of the Certificate request subject
to the provided buffer.  The name will be in the form
"C=xxxx,O=yyyy,CN=zzzz" as described in RFC 2253. The output string
 <code>buf</code>will be ASCII or UTF-8 encoded, depending on the certificate
data.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> if the provided buffer is not
long enough, and in that case the * <code>sizeof_buf</code>will be updated with
the required size.  On success 0 is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_get_dn_by_oid</h4>

<p><a name="gnutls_005fx509_005fcrq_005fget_005fdn_005fby_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_get_dn_by_oid</b> (<var>gnutls_x509_crq_t crq, const char * oid, int indx, unsigned int raw_flag, void * buf, size_t * sizeof_buf</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fget_005fdn_005fby_005foid-365"></a></var><br>
<blockquote><p><var>crq</var>: should contain a gnutls_x509_crq_t structure

     <p><var>oid</var>: holds an Object Identified in null terminated string

     <p><var>indx</var>: In case multiple same OIDs exist in the RDN, this specifies
which to send. Use (0) to get the first one.

     <p><var>raw_flag</var>: If non (0) returns the raw DER data of the DN part.

     <p><var>buf</var>: a pointer to a structure to hold the name (may be <code>NULL</code>)

     <p><var>sizeof_buf</var>: initially holds the size of  <code>buf</code>

     <p><strong> Description:</strong> This function will extract the part of the name of the Certificate
request subject, specified by the given OID. The output will be
encoded as described in RFC2253. The output string will be ASCII
or UTF-8 encoded, depending on the certificate data.

     <p>Some helper macros with popular OIDs can be found in gnutls/x509.h
If raw flag is (0), this function will only return known OIDs as
text. Other OIDs will be DER encoded, as described in RFC2253 &ndash;
in hex format with a '\#' prefix.  You can check about known OIDs
using <code>gnutls_x509_dn_oid_known()</code>.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> if the provided buffer is
not long enough, and in that case the * <code>sizeof_buf</code>will be
updated with the required size.  On success 0 is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_get_dn_oid</h4>

<p><a name="gnutls_005fx509_005fcrq_005fget_005fdn_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_get_dn_oid</b> (<var>gnutls_x509_crq_t crq, int indx, void * oid, size_t * sizeof_oid</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fget_005fdn_005foid-366"></a></var><br>
<blockquote><p><var>crq</var>: should contain a gnutls_x509_crq_t structure

     <p><var>indx</var>: Specifies which DN OID to send. Use (0) to get the first one.

     <p><var>oid</var>: a pointer to a structure to hold the name (may be <code>NULL</code>)

     <p><var>sizeof_oid</var>: initially holds the size of  <code>oid</code>

     <p><strong> Description:</strong> This function will extract the requested OID of the name of the
certificate request subject, specified by the given index.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> if the provided buffer is
not long enough, and in that case the * <code>sizeof_oid</code>will be
updated with the required size.  On success 0 is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_get_extension_by_oid</h4>

<p><a name="gnutls_005fx509_005fcrq_005fget_005fextension_005fby_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_get_extension_by_oid</b> (<var>gnutls_x509_crq_t crq, const char * oid, int indx, void * buf, size_t * sizeof_buf, unsigned int * critical</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fget_005fextension_005fby_005foid-367"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><var>oid</var>: holds an Object Identified in null terminated string

     <p><var>indx</var>: In case multiple same OIDs exist in the extensions, this
specifies which to send. Use (0) to get the first one.

     <p><var>buf</var>: a pointer to a structure to hold the name (may be null)

     <p><var>sizeof_buf</var>: initially holds the size of  <code>buf</code>

     <p><var>critical</var>: will be non (0) if the extension is marked as critical

     <p><strong> Description:</strong> This function will return the extension specified by the OID in
the certificate.  The extensions will be returned as binary data
DER encoded, in the provided buffer.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error code in case of an error.  If the certificate does not
contain the specified extension
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> will be returned.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_get_extension_data</h4>

<p><a name="gnutls_005fx509_005fcrq_005fget_005fextension_005fdata"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_get_extension_data</b> (<var>gnutls_x509_crq_t crq, int indx, void * data, size_t * sizeof_data</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fget_005fextension_005fdata-368"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><var>indx</var>: Specifies which extension OID to send. Use (0) to get the first one.

     <p><var>data</var>: a pointer to a structure to hold the data (may be null)

     <p><var>sizeof_data</var>: initially holds the size of  <code>oid</code>

     <p><strong> Description:</strong> This function will return the requested extension data in the
certificate.  The extension data will be stored as a string in the
provided buffer.

     <p>Use <code>gnutls_x509_crq_get_extension_info()</code> to extract the OID and
critical flag.  Use <code>gnutls_x509_crq_get_extension_by_oid()</code> instead,
if you want to get data indexed by the extension OID rather than
sequence.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error code in case of an error.  If your have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>
will be returned.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_get_extension_info</h4>

<p><a name="gnutls_005fx509_005fcrq_005fget_005fextension_005finfo"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_get_extension_info</b> (<var>gnutls_x509_crq_t crq, int indx, void * oid, size_t * sizeof_oid, unsigned int * critical</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fget_005fextension_005finfo-369"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><var>indx</var>: Specifies which extension OID to send. Use (0) to get the first one.

     <p><var>oid</var>: a pointer to a structure to hold the OID

     <p><var>sizeof_oid</var>: initially holds the maximum size of  <code>oid</code>, on return
holds actual size of  <code>oid</code>.

     <p><var>critical</var>: output variable with critical flag, may be NULL.

     <p><strong> Description:</strong> This function will return the requested extension OID in the
certificate, and the critical flag for it.  The extension OID will
be stored as a string in the provided buffer.  Use
<code>gnutls_x509_crq_get_extension_data()</code> to extract the data.

     <p>If the buffer provided is not long enough to hold the output, then
* <code>sizeof_oid</code>is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> will be
returned.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error code in case of an error.  If your have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>
will be returned.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_get_key_id</h4>

<p><a name="gnutls_005fx509_005fcrq_005fget_005fkey_005fid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_get_key_id</b> (<var>gnutls_x509_crq_t crq, unsigned int flags, unsigned char * output_data, size_t * output_data_size</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fget_005fkey_005fid-370"></a></var><br>
<blockquote><p><var>crq</var>: a certificate of type <code>gnutls_x509_crq_t</code>

     <p><var>flags</var>: should be 0 for now

     <p><var>output_data</var>: will contain the key ID

     <p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)

     <p><strong> Description:</strong> This function will return a unique ID the depends on the public key
parameters.  This ID can be used in checking whether a certificate
corresponds to the given private key.

     <p>If the buffer provided is not long enough to hold the output, then
* <code>output_data_size</code>is updated and GNUTLS_E_SHORT_MEMORY_BUFFER will
be returned.  The output will normally be a SHA-1 hash output,
which is 20 bytes.

     <p><strong> Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_get_key_purpose_oid</h4>

<p><a name="gnutls_005fx509_005fcrq_005fget_005fkey_005fpurpose_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_get_key_purpose_oid</b> (<var>gnutls_x509_crq_t crq, int indx, void * oid, size_t * sizeof_oid, unsigned int * critical</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fget_005fkey_005fpurpose_005foid-371"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><var>indx</var>: This specifies which OID to return, use (0) to get the first one

     <p><var>oid</var>: a pointer to a buffer to hold the OID (may be <code>NULL</code>)

     <p><var>sizeof_oid</var>: initially holds the size of  <code>oid</code>

     <p><var>critical</var>: output variable with critical flag, may be <code>NULL</code>.

     <p><strong> Description:</strong> This function will extract the key purpose OIDs of the Certificate
specified by the given index.  These are stored in the Extended Key
Usage extension (2.5.29.37).  See the GNUTLS_KP_* definitions for
human readable names.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> if the provided buffer is
not long enough, and in that case the * <code>sizeof_oid</code>will be
updated with the required size.  On success 0 is returned.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_get_key_rsa_raw</h4>

<p><a name="gnutls_005fx509_005fcrq_005fget_005fkey_005frsa_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_get_key_rsa_raw</b> (<var>gnutls_x509_crq_t crq, gnutls_datum_t * m, gnutls_datum_t * e</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fget_005fkey_005frsa_005fraw-372"></a></var><br>
<blockquote><p><var>crq</var>: Holds the certificate

     <p><var>m</var>: will hold the modulus

     <p><var>e</var>: will hold the public exponent

     <p><strong> Description:</strong> This function will export the RSA public key's parameters found in
the given structure.  The new parameters will be allocated using
<code>gnutls_malloc()</code> and will be stored in the appropriate datum.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_get_key_usage</h4>

<p><a name="gnutls_005fx509_005fcrq_005fget_005fkey_005fusage"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_get_key_usage</b> (<var>gnutls_x509_crq_t crq, unsigned int * key_usage, unsigned int * critical</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fget_005fkey_005fusage-373"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><var>key_usage</var>: where the key usage bits will be stored

     <p><var>critical</var>: will be non (0) if the extension is marked as critical

     <p><strong> Description:</strong> This function will return certificate's key usage, by reading the
keyUsage X.509 extension (2.5.29.15).  The key usage value will

     <p><strong> ORed values of the:</strong> <code>GNUTLS_KEY_DIGITAL_SIGNATURE</code>,
<code>GNUTLS_KEY_NON_REPUDIATION</code>, <code>GNUTLS_KEY_KEY_ENCIPHERMENT</code>,
<code>GNUTLS_KEY_DATA_ENCIPHERMENT</code>, <code>GNUTLS_KEY_KEY_AGREEMENT</code>,
<code>GNUTLS_KEY_KEY_CERT_SIGN</code>, <code>GNUTLS_KEY_CRL_SIGN</code>,
<code>GNUTLS_KEY_ENCIPHER_ONLY</code>, <code>GNUTLS_KEY_DECIPHER_ONLY</code>.

     <p><strong> Returns:</strong> the certificate key usage, or a negative error code in case of
parsing error.  If the certificate does not contain the keyUsage
extension <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> will be
returned.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_get_pk_algorithm</h4>

<p><a name="gnutls_005fx509_005fcrq_005fget_005fpk_005falgorithm"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_get_pk_algorithm</b> (<var>gnutls_x509_crq_t crq, unsigned int * bits</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fget_005fpk_005falgorithm-374"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><var>bits</var>: if bits is non-<code>NULL</code> it will hold the size of the parameters' in bits

     <p><strong> Description:</strong> This function will return the public key algorithm of a PKCS<code>10</code>
certificate request.

     <p>If bits is non-<code>NULL</code>, it should have enough size to hold the
parameters size in bits.  For RSA the bits returned is the modulus. 
For DSA the bits returned are of the public exponent.

     <p><strong> Returns:</strong> a member of the <code>gnutls_pk_algorithm_t</code> enumeration on
success, or a negative error code on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_get_subject_alt_name</h4>

<p><a name="gnutls_005fx509_005fcrq_005fget_005fsubject_005falt_005fname"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_get_subject_alt_name</b> (<var>gnutls_x509_crq_t crq, unsigned int seq, void * ret, size_t * ret_size, unsigned int * ret_type, unsigned int * critical</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fget_005fsubject_005falt_005fname-375"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><var>seq</var>: specifies the sequence number of the alt name, 0 for the
first one, 1 for the second etc.

     <p><var>ret</var>: is the place where the alternative name will be copied to

     <p><var>ret_size</var>: holds the size of ret.

     <p><var>ret_type</var>: holds the <code>gnutls_x509_subject_alt_name_t</code> name type

     <p><var>critical</var>: will be non (0) if the extension is marked as critical
(may be null)

     <p><strong> Description:</strong> This function will return the alternative names, contained in the
given certificate.  It is the same as
<code>gnutls_x509_crq_get_subject_alt_name()</code> except for the fact that it
will return the type of the alternative name in  <code>ret_type</code>even if
the function fails for some reason (i.e.  the buffer provided is
not enough).

     <p><strong> Returns:</strong> the alternative subject name type on success, one of the
enumerated <code>gnutls_x509_subject_alt_name_t</code>.  It will return
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> if  <code>ret_size</code>is not large enough to
hold the value.  In that case  <code>ret_size</code>will be updated with the
required size.  If the certificate request does not have an
Alternative name with the specified sequence number then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> is returned.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_get_subject_alt_othername_oid</h4>

<p><a name="gnutls_005fx509_005fcrq_005fget_005fsubject_005falt_005fothername_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_get_subject_alt_othername_oid</b> (<var>gnutls_x509_crq_t crq, unsigned int seq, void * ret, size_t * ret_size</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fget_005fsubject_005falt_005fothername_005foid-376"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><var>seq</var>: specifies the sequence number of the alt name (0 for the first one, 1 for the second etc.)

     <p><var>ret</var>: is the place where the otherName OID will be copied to

     <p><var>ret_size</var>: holds the size of ret.

     <p><strong> Description:</strong> This function will extract the type OID of an otherName Subject
Alternative Name, contained in the given certificate, and return
the type as an enumerated element.

     <p>This function is only useful if
<code>gnutls_x509_crq_get_subject_alt_name()</code> returned
<code>GNUTLS_SAN_OTHERNAME</code>.

     <p><strong> Returns:</strong> the alternative subject name type on success, one of the
enumerated gnutls_x509_subject_alt_name_t.  For supported OIDs,
it will return one of the virtual (GNUTLS_SAN_OTHERNAME_*) types,
e.g. <code>GNUTLS_SAN_OTHERNAME_XMPP</code>, and <code>GNUTLS_SAN_OTHERNAME</code> for
unknown OIDs.  It will return <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> if
 <code>ret_size</code>is not large enough to hold the value.  In that case
 <code>ret_size</code>will be updated with the required size.  If the
certificate does not have an Alternative name with the specified
sequence number and with the otherName type then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> is returned.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_get_version</h4>

<p><a name="gnutls_005fx509_005fcrq_005fget_005fversion"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_get_version</b> (<var>gnutls_x509_crq_t crq</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fget_005fversion-377"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><strong> Description:</strong> This function will return the version of the specified Certificate
request.

     <p><strong> Returns:</strong> version of certificate request, or a negative error code on
error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_import</h4>

<p><a name="gnutls_005fx509_005fcrq_005fimport"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_import</b> (<var>gnutls_x509_crq_t crq, const gnutls_datum_t * data, gnutls_x509_crt_fmt_t format</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fimport-378"></a></var><br>
<blockquote><p><var>crq</var>: The structure to store the parsed certificate request.

     <p><var>data</var>: The DER or PEM encoded certificate.

     <p><var>format</var>: One of DER or PEM

     <p><strong> Description:</strong> This function will convert the given DER or PEM encoded certificate
request to a <code>gnutls_x509_crq_t</code> structure.  The output will be
stored in  <code>crq</code>.

     <p>If the Certificate is PEM encoded it should have a header of "NEW
CERTIFICATE REQUEST".

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_init</h4>

<p><a name="gnutls_005fx509_005fcrq_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_init</b> (<var>gnutls_x509_crq_t * crq</var>)<var><a name="index-gnutls_005fx509_005fcrq_005finit-379"></a></var><br>
<blockquote><p><var>crq</var>: The structure to be initialized

     <p><strong> Description:</strong> This function will initialize a PKCS<code>10</code> certificate request
structure.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_print</h4>

<p><a name="gnutls_005fx509_005fcrq_005fprint"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_print</b> (<var>gnutls_x509_crq_t crq, gnutls_certificate_print_formats_t format, gnutls_datum_t * out</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fprint-380"></a></var><br>
<blockquote><p><var>crq</var>: The structure to be printed

     <p><var>format</var>: Indicate the format to use

     <p><var>out</var>: Newly allocated datum with (0) terminated string.

     <p><strong> Description:</strong> This function will pretty print a certificate request, suitable for
display to a human.

     <p>The output  <code>out</code>needs to be deallocate using <code>gnutls_free()</code>.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_set_attribute_by_oid</h4>

<p><a name="gnutls_005fx509_005fcrq_005fset_005fattribute_005fby_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_set_attribute_by_oid</b> (<var>gnutls_x509_crq_t crq, const char * oid, void * buf, size_t sizeof_buf</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fset_005fattribute_005fby_005foid-381"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><var>oid</var>: holds an Object Identified in (0)-terminated string

     <p><var>buf</var>: a pointer to a structure that holds the attribute data

     <p><var>sizeof_buf</var>: holds the size of  <code>buf</code>

     <p><strong> Description:</strong> This function will set the attribute in the certificate request
specified by the given Object ID.  The attribute must be be DER
encoded.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_set_basic_constraints</h4>

<p><a name="gnutls_005fx509_005fcrq_005fset_005fbasic_005fconstraints"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_set_basic_constraints</b> (<var>gnutls_x509_crq_t crq, unsigned int ca, int pathLenConstraint</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fset_005fbasic_005fconstraints-382"></a></var><br>
<blockquote><p><var>crq</var>: a certificate request of type <code>gnutls_x509_crq_t</code>

     <p><var>ca</var>: true(1) or false(0) depending on the Certificate authority status.

     <p><var>pathLenConstraint</var>: non-negative error codes indicate maximum length of path,
and negative error codes indicate that the pathLenConstraints field should
not be present.

     <p><strong> Description:</strong> This function will set the basicConstraints certificate extension.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_set_challenge_password</h4>

<p><a name="gnutls_005fx509_005fcrq_005fset_005fchallenge_005fpassword"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_set_challenge_password</b> (<var>gnutls_x509_crq_t crq, const char * pass</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fset_005fchallenge_005fpassword-383"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><var>pass</var>: holds a (0)-terminated password

     <p><strong> Description:</strong> This function will set a challenge password to be used when
revoking the request.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_set_dn_by_oid</h4>

<p><a name="gnutls_005fx509_005fcrq_005fset_005fdn_005fby_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_set_dn_by_oid</b> (<var>gnutls_x509_crq_t crq, const char * oid, unsigned int raw_flag, const void * data, unsigned int sizeof_data</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fset_005fdn_005fby_005foid-384"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><var>oid</var>: holds an Object Identifier in a (0)-terminated string

     <p><var>raw_flag</var>: must be 0, or 1 if the data are DER encoded

     <p><var>data</var>: a pointer to the input data

     <p><var>sizeof_data</var>: holds the size of  <code>data</code>

     <p><strong> Description:</strong> This function will set the part of the name of the Certificate
request subject, specified by the given OID.  The input string
should be ASCII or UTF-8 encoded.

     <p>Some helper macros with popular OIDs can be found in gnutls/x509.h
With this function you can only set the known OIDs.  You can test
for known OIDs using <code>gnutls_x509_dn_oid_known()</code>.  For OIDs that are
not known (by gnutls) you should properly DER encode your data, and
call this function with raw_flag set.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_set_key</h4>

<p><a name="gnutls_005fx509_005fcrq_005fset_005fkey"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_set_key</b> (<var>gnutls_x509_crq_t crq, gnutls_x509_privkey_t key</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fset_005fkey-385"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><var>key</var>: holds a private key

     <p><strong> Description:</strong> This function will set the public parameters from the given private
key to the request.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_set_key_purpose_oid</h4>

<p><a name="gnutls_005fx509_005fcrq_005fset_005fkey_005fpurpose_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_set_key_purpose_oid</b> (<var>gnutls_x509_crq_t crq, const void * oid, unsigned int critical</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fset_005fkey_005fpurpose_005foid-386"></a></var><br>
<blockquote><p><var>crq</var>: a certificate of type <code>gnutls_x509_crq_t</code>

     <p><var>oid</var>: a pointer to a (0)-terminated string that holds the OID

     <p><var>critical</var>: Whether this extension will be critical or not

     <p><strong> Description:</strong> This function will set the key purpose OIDs of the Certificate. 
These are stored in the Extended Key Usage extension (2.5.29.37)
See the GNUTLS_KP_* definitions for human readable names.

     <p>Subsequent calls to this function will append OIDs to the OID list.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_set_key_rsa_raw</h4>

<p><a name="gnutls_005fx509_005fcrq_005fset_005fkey_005frsa_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_set_key_rsa_raw</b> (<var>gnutls_x509_crq_t crq, const gnutls_datum_t * m, const gnutls_datum_t * e</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fset_005fkey_005frsa_005fraw-387"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><var>m</var>: holds the modulus

     <p><var>e</var>: holds the public exponent

     <p><strong> Description:</strong> This function will set the public parameters from the given private
key to the request. Only RSA keys are currently supported.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.6.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_set_key_usage</h4>

<p><a name="gnutls_005fx509_005fcrq_005fset_005fkey_005fusage"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_set_key_usage</b> (<var>gnutls_x509_crq_t crq, unsigned int usage</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fset_005fkey_005fusage-388"></a></var><br>
<blockquote><p><var>crq</var>: a certificate request of type <code>gnutls_x509_crq_t</code>

     <p><var>usage</var>: an ORed sequence of the GNUTLS_KEY_* elements.

     <p><strong> Description:</strong> This function will set the keyUsage certificate extension.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_set_subject_alt_name</h4>

<p><a name="gnutls_005fx509_005fcrq_005fset_005fsubject_005falt_005fname"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_set_subject_alt_name</b> (<var>gnutls_x509_crq_t crq, gnutls_x509_subject_alt_name_t nt, const void * data, unsigned int data_size, unsigned int flags</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fset_005fsubject_005falt_005fname-389"></a></var><br>
<blockquote><p><var>crq</var>: a certificate request of type <code>gnutls_x509_crq_t</code>

     <p><var>nt</var>: is one of the <code>gnutls_x509_subject_alt_name_t</code> enumerations

     <p><var>data</var>: The data to be set

     <p><var>data_size</var>: The size of data to be set

     <p><var>flags</var>: <code>GNUTLS_FSAN_SET</code> to clear previous data or
<code>GNUTLS_FSAN_APPEND</code> to append.

     <p><strong> Description:</strong> This function will set the subject alternative name certificate
extension.  It can set the following types:

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_set_version</h4>

<p><a name="gnutls_005fx509_005fcrq_005fset_005fversion"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_set_version</b> (<var>gnutls_x509_crq_t crq, unsigned int version</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fset_005fversion-390"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><var>version</var>: holds the version number, for v1 Requests must be 1

     <p><strong> Description:</strong> This function will set the version of the certificate request.  For
version 1 requests this must be one.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_sign2</h4>

<p><a name="gnutls_005fx509_005fcrq_005fsign2"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_sign2</b> (<var>gnutls_x509_crq_t crq, gnutls_x509_privkey_t key, gnutls_digest_algorithm_t dig, unsigned int flags</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fsign2-391"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><var>key</var>: holds a private key

     <p><var>dig</var>: The message digest to use, i.e., <code>GNUTLS_DIG_SHA1</code>

     <p><var>flags</var>: must be 0

     <p><strong> Description:</strong> This function will sign the certificate request with a private key. 
This must be the same key as the one used in
<code>gnutls_x509_crt_set_key()</code> since a certificate request is self
signed.

     <p>This must be the last step in a certificate request generation
since all the previously set parameters are now signed.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, otherwise a negative error code. 
<code>GNUTLS_E_ASN1_VALUE_NOT_FOUND</code> is returned if you didn't set all
information in the certificate request (e.g., the version using
<code>gnutls_x509_crq_set_version()</code>). 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_verify</h4>

<p><a name="gnutls_005fx509_005fcrq_005fverify"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_verify</b> (<var>gnutls_x509_crq_t crq, unsigned int flags</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fverify-392"></a></var><br>
<blockquote><p><var>crq</var>: is the crq to be verified

     <p><var>flags</var>: Flags that may be used to change the verification algorithm. Use OR of the gnutls_certificate_verify_flags enumerations.

     <p><strong> Description:</strong> This function will verify self signature in the certificate
request and return its status.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned,
<code>GNUTLS_E_PK_SIG_VERIFY_FAILED</code> if verification failed, otherwise a
negative error value.

     <p>Since 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_check_hostname</h4>

<p><a name="gnutls_005fx509_005fcrt_005fcheck_005fhostname"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_check_hostname</b> (<var>gnutls_x509_crt_t cert, const char * hostname</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fcheck_005fhostname-393"></a></var><br>
<blockquote><p><var>cert</var>: should contain an gnutls_x509_crt_t structure

     <p><var>hostname</var>: A null terminated string that contains a DNS name

     <p><strong> Description:</strong> This function will check if the given certificate's subject matches
the given hostname.  This is a basic implementation of the matching
described in RFC2818 (HTTPS), which takes into account wildcards,
and the DNSName/IPAddress subject alternative name PKIX extension.

     <p><strong> Returns:</strong> non (0) for a successful match, and (0) on failure. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_check_issuer</h4>

<p><a name="gnutls_005fx509_005fcrt_005fcheck_005fissuer"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_check_issuer</b> (<var>gnutls_x509_crt_t cert, gnutls_x509_crt_t issuer</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fcheck_005fissuer-394"></a></var><br>
<blockquote><p><var>cert</var>: is the certificate to be checked

     <p><var>issuer</var>: is the certificate of a possible issuer

     <p><strong> Description:</strong> This function will check if the given certificate was issued by the
given issuer.

     <p><strong> Returns:</strong> It will return true (1) if the given certificate is issued
by the given issuer, and false (0) if not.  A negative error code is
returned in case of an error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_check_revocation</h4>

<p><a name="gnutls_005fx509_005fcrt_005fcheck_005frevocation"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_check_revocation</b> (<var>gnutls_x509_crt_t cert, const gnutls_x509_crl_t * crl_list, int crl_list_length</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fcheck_005frevocation-395"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>crl_list</var>: should contain a list of gnutls_x509_crl_t structures

     <p><var>crl_list_length</var>: the length of the crl_list

     <p><strong> Description:</strong> This function will return check if the given certificate is
revoked.  It is assumed that the CRLs have been verified before.

     <p><strong> Returns:</strong> 0 if the certificate is NOT revoked, and 1 if it is.  A
negative error code is returned on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_cpy_crl_dist_points</h4>

<p><a name="gnutls_005fx509_005fcrt_005fcpy_005fcrl_005fdist_005fpoints"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_cpy_crl_dist_points</b> (<var>gnutls_x509_crt_t dst, gnutls_x509_crt_t src</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fcpy_005fcrl_005fdist_005fpoints-396"></a></var><br>
<blockquote><p><var>dst</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>src</var>: the certificate where the dist points will be copied from

     <p><strong> Description:</strong> This function will copy the CRL distribution points certificate
extension, from the source to the destination certificate. 
This may be useful to copy from a CA certificate to issued ones.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_deinit</h4>

<p><a name="gnutls_005fx509_005fcrt_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_x509_crt_deinit</b> (<var>gnutls_x509_crt_t cert</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fdeinit-397"></a></var><br>
<blockquote><p><var>cert</var>: The structure to be deinitialized

     <p><strong> Description:</strong> This function will deinitialize a certificate structure. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_export</h4>

<p><a name="gnutls_005fx509_005fcrt_005fexport"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_export</b> (<var>gnutls_x509_crt_t cert, gnutls_x509_crt_fmt_t format, void * output_data, size_t * output_data_size</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fexport-398"></a></var><br>
<blockquote><p><var>cert</var>: Holds the certificate

     <p><var>format</var>: the format of output params. One of PEM or DER.

     <p><var>output_data</var>: will contain a certificate PEM or DER encoded

     <p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)

     <p><strong> Description:</strong> This function will export the certificate to DER or PEM format.

     <p>If the buffer provided is not long enough to hold the output, then
*output_data_size is updated and GNUTLS_E_SHORT_MEMORY_BUFFER will
be returned.

     <p>If the structure is PEM encoded, it will have a header
of "BEGIN CERTIFICATE".

     <p><strong> Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_activation_time</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005factivation_005ftime"></a>

<div class="defun">
&mdash; Function: time_t <b>gnutls_x509_crt_get_activation_time</b> (<var>gnutls_x509_crt_t cert</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005factivation_005ftime-399"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><strong> Description:</strong> This function will return the time this Certificate was or will be
activated.

     <p><strong> Returns:</strong> activation time, or (time_t)-1 on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_authority_info_access</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fauthority_005finfo_005faccess"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_authority_info_access</b> (<var>gnutls_x509_crt_t crt, unsigned int seq, int what, gnutls_datum_t * data, int * critical</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fauthority_005finfo_005faccess-400"></a></var><br>
<blockquote><p><var>crt</var>: Holds the certificate

     <p><var>seq</var>: specifies the sequence number of the access descriptor (0 for the first one, 1 for the second etc.)

     <p><var>what</var>: what data to get, a <code>gnutls_info_access_what_t</code> type.

     <p><var>data</var>: output data to be freed with <code>gnutls_free()</code>.

     <p><var>critical</var>: pointer to output integer that is set to non-0 if the extension is marked as critical (may be <code>NULL</code>)

     <p><strong> Description:</strong> This function extracts the Authority Information Access (AIA)
extension, see RFC 5280 section 4.2.2.1 for more information.  The
AIA extension holds a sequence of AccessDescription (AD) data:

     <p>&lt;informalexample&gt;&lt;programlisting&gt;

     <p><strong> AuthorityInfoAccessSyntax  :</strong> :=
SEQUENCE SIZE (1..MAX) OF AccessDescription

     <p><strong> AccessDescription  :</strong> :=  SEQUENCE {
accessMethod          OBJECT IDENTIFIER,
accessLocation        GeneralName  }
&lt;/programlisting&gt;&lt;/informalexample&gt;

     <p>The  <code>seq</code>input parameter is used to indicate which member of the
sequence the caller is interested in.  The first member is 0, the
second member 1 and so on.  When the  <code>seq</code>value is out of bounds,
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> is returned.

     <p>The type of data returned in  <code>data</code>is specified via  <code>what</code>which
should be <code>gnutls_info_access_what_t</code> values.

     <p>If  <code>what</code>is <code>GNUTLS_IA_ACCESSMETHOD_OID</code> then  <code>data</code>will hold the
accessMethod OID (e.g., "1.3.6.1.5.5.7.48.1").

     <p>If  <code>what</code>is <code>GNUTLS_IA_ACCESSLOCATION_GENERALNAME_TYPE</code>,  <code>data</code>will
hold the accessLocation GeneralName type (e.g.,
"uniformResourceIdentifier").

     <p>If  <code>what</code>is <code>GNUTLS_IA_URI</code>,  <code>data</code>will hold the accessLocation URI
data.  Requesting this  <code>what</code>value leads to an error if the
accessLocation is not of the "uniformResourceIdentifier" type.

     <p>If  <code>what</code>is <code>GNUTLS_IA_OCSP_URI</code>,  <code>data</code>will hold the OCSP URI. 
Requesting this  <code>what</code>value leads to an error if the accessMethod
is not 1.3.6.1.5.5.7.48.1 aka OSCP, or if accessLocation is not of
the "uniformResourceIdentifier" type.

     <p>If  <code>what</code>is <code>GNUTLS_IA_CAISSUERS_URI</code>,  <code>data</code>will hold the caIssuers
URI.  Requesting this  <code>what</code>value leads to an error if the
accessMethod is not 1.3.6.1.5.5.7.48.2 aka caIssuers, or if
accessLocation is not of the "uniformResourceIdentifier" type.

     <p>More  <code>what</code>values may be allocated in the future as needed.

     <p>If  <code>data</code>is NULL, the function does the same without storing the
output data, that is, it will set  <code>critical</code>and do error checking
as usual.

     <p>The value of the critical flag is returned in * <code>critical</code>.  Supply a
NULL  <code>critical</code>if you want the function to make sure the extension
is non-critical, as required by RFC 5280.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, <code>GNUTLS_E_INVALID_REQUEST</code> on
invalid  <code>crt</code>, <code>GNUTLS_E_CONSTRAINT_ERROR</code> if the extension is
incorrectly marked as critical (use a non-NULL  <code>critical</code>to
override), <code>GNUTLS_E_UNKNOWN_ALGORITHM</code> if the requested OID does
not match (e.g., when using <code>GNUTLS_IA_OCSP_URI</code>), otherwise a
negative error code.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_authority_key_id</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fauthority_005fkey_005fid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_authority_key_id</b> (<var>gnutls_x509_crt_t cert, void * ret, size_t * ret_size, unsigned int * critical</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fauthority_005fkey_005fid-401"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>ret</var>: The place where the identifier will be copied

     <p><var>ret_size</var>: Holds the size of the result field.

     <p><var>critical</var>: will be non (0) if the extension is marked as critical (may be null)

     <p><strong> Description:</strong> This function will return the X.509v3 certificate authority's key
identifier.  This is obtained by the X.509 Authority Key
identifier extension field (2.5.29.35). Note that this function
only returns the keyIdentifier field of the extension.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_basic_constraints</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fbasic_005fconstraints"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_basic_constraints</b> (<var>gnutls_x509_crt_t cert, unsigned int * critical, unsigned int * ca, int * pathlen</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fbasic_005fconstraints-402"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>critical</var>: will be non (0) if the extension is marked as critical

     <p><var>ca</var>: pointer to output integer indicating CA status, may be NULL,
value is 1 if the certificate CA flag is set, 0 otherwise.

     <p><var>pathlen</var>: pointer to output integer indicating path length (may be
NULL), non-negative error codes indicate a present pathLenConstraint
field and the actual value, -1 indicate that the field is absent.

     <p><strong> Description:</strong> This function will read the certificate's basic constraints, and
return the certificates CA status.  It reads the basicConstraints
X.509 extension (2.5.29.19).

     <p><strong> Returns:</strong> If the certificate is a CA a positive value will be
returned, or (0) if the certificate does not have CA flag set.  A
negative error code may be returned in case of errors.  If the
certificate does not contain the basicConstraints extension
GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE will be returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_ca_status</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fca_005fstatus"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_ca_status</b> (<var>gnutls_x509_crt_t cert, unsigned int * critical</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fca_005fstatus-403"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>critical</var>: will be non (0) if the extension is marked as critical

     <p><strong> Description:</strong> This function will return certificates CA status, by reading the
basicConstraints X.509 extension (2.5.29.19). If the certificate is
a CA a positive value will be returned, or (0) if the certificate
does not have CA flag set.

     <p>Use <code>gnutls_x509_crt_get_basic_constraints()</code> if you want to read the
pathLenConstraint field too.

     <p><strong> Returns:</strong> A negative error code may be returned in case of parsing error. 
If the certificate does not contain the basicConstraints extension
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> will be returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_crl_dist_points</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fcrl_005fdist_005fpoints"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_crl_dist_points</b> (<var>gnutls_x509_crt_t cert, unsigned int seq, void * ret, size_t * ret_size, unsigned int * reason_flags, unsigned int * critical</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fcrl_005fdist_005fpoints-404"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>seq</var>: specifies the sequence number of the distribution point (0 for the first one, 1 for the second etc.)

     <p><var>ret</var>: is the place where the distribution point will be copied to

     <p><var>ret_size</var>: holds the size of ret.

     <p><var>reason_flags</var>: Revocation reasons flags.

     <p><var>critical</var>: will be non (0) if the extension is marked as critical (may be null)

     <p><strong> Description:</strong> This function retrieves the CRL distribution points (2.5.29.31),
contained in the given certificate in the X509v3 Certificate
Extensions.

     <p><code>reason_flags</code>should be an ORed sequence of
<code>GNUTLS_CRL_REASON_UNUSED</code>, <code>GNUTLS_CRL_REASON_KEY_COMPROMISE</code>,
<code>GNUTLS_CRL_REASON_CA_COMPROMISE</code>,
<code>GNUTLS_CRL_REASON_AFFILIATION_CHANGED</code>,
<code>GNUTLS_CRL_REASON_SUPERSEEDED</code>,
<code>GNUTLS_CRL_REASON_CESSATION_OF_OPERATION</code>,
<code>GNUTLS_CRL_REASON_CERTIFICATE_HOLD</code>,
<code>GNUTLS_CRL_REASON_PRIVILEGE_WITHDRAWN</code>,
<code>GNUTLS_CRL_REASON_AA_COMPROMISE</code>, or (0) for all possible reasons.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> and updates  <code>ret_size</code>if
 <code>ret_size</code>is not enough to hold the distribution point, or the
type of the distribution point if everything was ok. The type is
one of the enumerated <code>gnutls_x509_subject_alt_name_t</code>.  If the
certificate does not have an Alternative name with the specified
sequence number then <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> is
returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_dn</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fdn"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_dn</b> (<var>gnutls_x509_crt_t cert, char * buf, size_t * buf_size</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fdn-405"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>buf</var>: a pointer to a structure to hold the name (may be null)

     <p><var>buf_size</var>: initially holds the size of  <code>buf</code>

     <p><strong> Description:</strong> This function will copy the name of the Certificate in the provided
buffer. The name will be in the form "C=xxxx,O=yyyy,CN=zzzz" as
described in RFC2253. The output string will be ASCII or UTF-8
encoded, depending on the certificate data.

     <p>If  <code>buf</code>is null then only the size will be filled. If the  <code>raw_flag</code>is not specified the output is always null terminated, although the
 <code>buf_size</code>will not include the null character.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> if the provided buffer is not
long enough, and in that case the  <code>buf_size</code>will be updated
with the required size.  On success 0 is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_dn_by_oid</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fdn_005fby_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_dn_by_oid</b> (<var>gnutls_x509_crt_t cert, const char * oid, int indx, unsigned int raw_flag, void * buf, size_t * buf_size</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fdn_005fby_005foid-406"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>oid</var>: holds an Object Identified in null terminated string

     <p><var>indx</var>: In case multiple same OIDs exist in the RDN, this specifies which to send. Use (0) to get the first one.

     <p><var>raw_flag</var>: If non (0) returns the raw DER data of the DN part.

     <p><var>buf</var>: a pointer where the DN part will be copied (may be null).

     <p><var>buf_size</var>: initially holds the size of  <code>buf</code>

     <p><strong> Description:</strong> This function will extract the part of the name of the Certificate
subject specified by the given OID. The output, if the raw flag is
not used, will be encoded as described in RFC2253. Thus a string
that is ASCII or UTF-8 encoded, depending on the certificate data.

     <p>Some helper macros with popular OIDs can be found in gnutls/x509.h
If raw flag is (0), this function will only return known OIDs as
text. Other OIDs will be DER encoded, as described in RFC2253 &ndash;
in hex format with a '\#' prefix.  You can check about known OIDs
using <code>gnutls_x509_dn_oid_known()</code>.

     <p>If  <code>buf</code>is null then only the size will be filled. If the  <code>raw_flag</code>is not specified the output is always null terminated, although the
 <code>buf_size</code>will not include the null character.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> if the provided buffer is
not long enough, and in that case the *buf_size will be updated
with the required size.  On success 0 is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_dn_oid</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fdn_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_dn_oid</b> (<var>gnutls_x509_crt_t cert, int indx, void * oid, size_t * oid_size</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fdn_005foid-407"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>indx</var>: This specifies which OID to return. Use (0) to get the first one.

     <p><var>oid</var>: a pointer to a buffer to hold the OID (may be null)

     <p><var>oid_size</var>: initially holds the size of  <code>oid</code>

     <p><strong> Description:</strong> This function will extract the OIDs of the name of the Certificate
subject specified by the given index.

     <p>If  <code>oid</code>is null then only the size will be filled. If the  <code>raw_flag</code>is not specified the output is always null terminated, although the
 <code>oid_size</code>will not include the null character.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> if the provided buffer is
not long enough, and in that case the  <code>oid_size</code>will be updated
with the required size.  On success 0 is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_expiration_time</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fexpiration_005ftime"></a>

<div class="defun">
&mdash; Function: time_t <b>gnutls_x509_crt_get_expiration_time</b> (<var>gnutls_x509_crt_t cert</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fexpiration_005ftime-408"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><strong> Description:</strong> This function will return the time this Certificate was or will be
expired.

     <p><strong> Returns:</strong> expiration time, or (time_t)-1 on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_extension_by_oid</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fextension_005fby_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_extension_by_oid</b> (<var>gnutls_x509_crt_t cert, const char * oid, int indx, void * buf, size_t * buf_size, unsigned int * critical</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fextension_005fby_005foid-409"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>oid</var>: holds an Object Identified in null terminated string

     <p><var>indx</var>: In case multiple same OIDs exist in the extensions, this specifies which to send. Use (0) to get the first one.

     <p><var>buf</var>: a pointer to a structure to hold the name (may be null)

     <p><var>buf_size</var>: initially holds the size of  <code>buf</code>

     <p><var>critical</var>: will be non (0) if the extension is marked as critical

     <p><strong> Description:</strong> This function will return the extension specified by the OID in the
certificate.  The extensions will be returned as binary data DER
encoded, in the provided buffer.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned,
otherwise a negative error code is returned. If the certificate does not
contain the specified extension
GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE will be returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_extension_data</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fextension_005fdata"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_extension_data</b> (<var>gnutls_x509_crt_t cert, int indx, void * data, size_t * sizeof_data</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fextension_005fdata-410"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>indx</var>: Specifies which extension OID to send. Use (0) to get the first one.

     <p><var>data</var>: a pointer to a structure to hold the data (may be null)

     <p><var>sizeof_data</var>: initially holds the size of  <code>oid</code>

     <p><strong> Description:</strong> This function will return the requested extension data in the
certificate.  The extension data will be stored as a string in the
provided buffer.

     <p>Use <code>gnutls_x509_crt_get_extension_info()</code> to extract the OID and
critical flag.  Use <code>gnutls_x509_crt_get_extension_by_oid()</code> instead,
if you want to get data indexed by the extension OID rather than
sequence.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned,
otherwise a negative error code is returned.  If you have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>
will be returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_extension_info</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fextension_005finfo"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_extension_info</b> (<var>gnutls_x509_crt_t cert, int indx, void * oid, size_t * oid_size, unsigned int * critical</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fextension_005finfo-411"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>indx</var>: Specifies which extension OID to send. Use (0) to get the first one.

     <p><var>oid</var>: a pointer to a structure to hold the OID

     <p><var>oid_size</var>: initially holds the maximum size of  <code>oid</code>, on return
holds actual size of  <code>oid</code>.

     <p><var>critical</var>: output variable with critical flag, may be NULL.

     <p><strong> Description:</strong> This function will return the requested extension OID in the
certificate, and the critical flag for it.  The extension OID will
be stored as a string in the provided buffer.  Use
<code>gnutls_x509_crt_get_extension_data()</code> to extract the data.

     <p>If the buffer provided is not long enough to hold the output, then
* <code>oid_size</code>is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> will be
returned.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned,
otherwise a negative error code is returned.  If you have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>
will be returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_extension_oid</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fextension_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_extension_oid</b> (<var>gnutls_x509_crt_t cert, int indx, void * oid, size_t * oid_size</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fextension_005foid-412"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>indx</var>: Specifies which extension OID to send. Use (0) to get the first one.

     <p><var>oid</var>: a pointer to a structure to hold the OID (may be null)

     <p><var>oid_size</var>: initially holds the size of  <code>oid</code>

     <p><strong> Description:</strong> This function will return the requested extension OID in the certificate. 
The extension OID will be stored as a string in the provided buffer.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned,
otherwise a negative error code is returned.  If you have reached the
last extension available <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>
will be returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_fingerprint</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005ffingerprint"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_fingerprint</b> (<var>gnutls_x509_crt_t cert, gnutls_digest_algorithm_t algo, void * buf, size_t * buf_size</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005ffingerprint-413"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>algo</var>: is a digest algorithm

     <p><var>buf</var>: a pointer to a structure to hold the fingerprint (may be null)

     <p><var>buf_size</var>: initially holds the size of  <code>buf</code>

     <p><strong> Description:</strong> This function will calculate and copy the certificate's fingerprint
in the provided buffer.

     <p>If the buffer is null then only the size will be filled.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> if the provided buffer is
not long enough, and in that case the *buf_size will be updated
with the required size.  On success 0 is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_issuer</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fissuer"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_issuer</b> (<var>gnutls_x509_crt_t cert, gnutls_x509_dn_t * dn</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fissuer-414"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>dn</var>: output variable with pointer to opaque DN

     <p><strong> Description:</strong> Return the Certificate's Issuer DN as an opaque data type.  You may
use <code>gnutls_x509_dn_get_rdn_ava()</code> to decode the DN.

     <p>Note that  <code>dn</code>should be treated as constant. Because points
into the  <code>cert</code>object, you may not deallocate  <code>cert</code>and continue to access  <code>dn</code>.

     <p><strong> Returns:</strong> Returns 0 on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_issuer_alt_name</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fname"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_issuer_alt_name</b> (<var>gnutls_x509_crt_t cert, unsigned int seq, void * ret, size_t * ret_size, unsigned int * critical</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fname-415"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>seq</var>: specifies the sequence number of the alt name (0 for the first one, 1 for the second etc.)

     <p><var>ret</var>: is the place where the alternative name will be copied to

     <p><var>ret_size</var>: holds the size of ret.

     <p><var>critical</var>: will be non (0) if the extension is marked as critical (may be null)

     <p><strong> Description:</strong> This function retrieves the Issuer Alternative Name (2.5.29.18),
contained in the given certificate in the X509v3 Certificate
Extensions.

     <p>When the SAN type is otherName, it will extract the data in the
otherName's value field, and <code>GNUTLS_SAN_OTHERNAME</code> is returned. 
You may use <code>gnutls_x509_crt_get_subject_alt_othername_oid()</code> to get
the corresponding OID and the "virtual" SAN types (e.g.,
<code>GNUTLS_SAN_OTHERNAME_XMPP</code>).

     <p>If an otherName OID is known, the data will be decoded.  Otherwise
the returned data will be DER encoded, and you will have to decode
it yourself.  Currently, only the RFC 3920 id-on-xmppAddr Issuer
AltName is recognized.

     <p><strong> Returns:</strong> the alternative issuer name type on success, one of the
enumerated <code>gnutls_x509_subject_alt_name_t</code>.  It will return
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> if  <code>ret_size</code>is not large enough
to hold the value.  In that case  <code>ret_size</code>will be updated with
the required size.  If the certificate does not have an
Alternative name with the specified sequence number then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> is returned.

     <p><strong> Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_issuer_alt_name2</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fname2"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_issuer_alt_name2</b> (<var>gnutls_x509_crt_t cert, unsigned int seq, void * ret, size_t * ret_size, unsigned int * ret_type, unsigned int * critical</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fname2-416"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>seq</var>: specifies the sequence number of the alt name (0 for the first one, 1 for the second etc.)

     <p><var>ret</var>: is the place where the alternative name will be copied to

     <p><var>ret_size</var>: holds the size of ret.

     <p><var>ret_type</var>: holds the type of the alternative name (one of gnutls_x509_subject_alt_name_t).

     <p><var>critical</var>: will be non (0) if the extension is marked as critical (may be null)

     <p><strong> Description:</strong> This function will return the alternative names, contained in the
given certificate. It is the same as
<code>gnutls_x509_crt_get_issuer_alt_name()</code> except for the fact that it
will return the type of the alternative name in  <code>ret_type</code>even if
the function fails for some reason (i.e.  the buffer provided is
not enough).

     <p><strong> Returns:</strong> the alternative issuer name type on success, one of the
enumerated <code>gnutls_x509_subject_alt_name_t</code>.  It will return
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> if  <code>ret_size</code>is not large enough
to hold the value.  In that case  <code>ret_size</code>will be updated with
the required size.  If the certificate does not have an
Alternative name with the specified sequence number then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> is returned.

     <p><strong> Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_issuer_alt_othername_oid</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fothername_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_issuer_alt_othername_oid</b> (<var>gnutls_x509_crt_t cert, unsigned int seq, void * ret, size_t * ret_size</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fothername_005foid-417"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>seq</var>: specifies the sequence number of the alt name (0 for the first one, 1 for the second etc.)

     <p><var>ret</var>: is the place where the otherName OID will be copied to

     <p><var>ret_size</var>: holds the size of ret.

     <p><strong> Description:</strong> This function will extract the type OID of an otherName Subject
Alternative Name, contained in the given certificate, and return
the type as an enumerated element.

     <p>If  <code>oid</code>is null then only the size will be filled. If the  <code>raw_flag</code>is not specified the output is always null terminated, although the
 <code>oid_size</code>will not include the null character.

     <p>This function is only useful if
<code>gnutls_x509_crt_get_issuer_alt_name()</code> returned
<code>GNUTLS_SAN_OTHERNAME</code>.

     <p><strong> Returns:</strong> the alternative issuer name type on success, one of the
enumerated gnutls_x509_subject_alt_name_t.  For supported OIDs, it
will return one of the virtual (GNUTLS_SAN_OTHERNAME_*) types,
e.g. <code>GNUTLS_SAN_OTHERNAME_XMPP</code>, and <code>GNUTLS_SAN_OTHERNAME</code> for
unknown OIDs.  It will return <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> if
 <code>ret_size</code>is not large enough to hold the value.  In that case
 <code>ret_size</code>will be updated with the required size.  If the
certificate does not have an Alternative name with the specified
sequence number and with the otherName type then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> is returned.

     <p><strong> Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_issuer_dn</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_issuer_dn</b> (<var>gnutls_x509_crt_t cert, char * buf, size_t * buf_size</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn-418"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>buf</var>: a pointer to a structure to hold the name (may be null)

     <p><var>buf_size</var>: initially holds the size of  <code>buf</code>

     <p><strong> Description:</strong> This function will copy the name of the Certificate issuer in the
provided buffer. The name will be in the form
"C=xxxx,O=yyyy,CN=zzzz" as described in RFC2253. The output string
will be ASCII or UTF-8 encoded, depending on the certificate data.

     <p>If  <code>buf</code>is null then only the size will be filled. If the  <code>raw_flag</code>is not specified the output is always null terminated, although the
 <code>buf_size</code>will not include the null character.

     <p><strong> Returns:</strong> GNUTLS_E_SHORT_MEMORY_BUFFER if the provided buffer is not
long enough, and in that case the  <code>buf_size</code>will be updated with
the required size.  On success 0 is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_issuer_dn_by_oid</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn_005fby_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_issuer_dn_by_oid</b> (<var>gnutls_x509_crt_t cert, const char * oid, int indx, unsigned int raw_flag, void * buf, size_t * buf_size</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn_005fby_005foid-419"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>oid</var>: holds an Object Identified in null terminated string

     <p><var>indx</var>: In case multiple same OIDs exist in the RDN, this specifies which to send. Use (0) to get the first one.

     <p><var>raw_flag</var>: If non (0) returns the raw DER data of the DN part.

     <p><var>buf</var>: a pointer to a structure to hold the name (may be null)

     <p><var>buf_size</var>: initially holds the size of  <code>buf</code>

     <p><strong> Description:</strong> This function will extract the part of the name of the Certificate
issuer specified by the given OID. The output, if the raw flag is not
used, will be encoded as described in RFC2253. Thus a string that is
ASCII or UTF-8 encoded, depending on the certificate data.

     <p>Some helper macros with popular OIDs can be found in gnutls/x509.h
If raw flag is (0), this function will only return known OIDs as
text. Other OIDs will be DER encoded, as described in RFC2253 &ndash;
in hex format with a '\#' prefix.  You can check about known OIDs
using <code>gnutls_x509_dn_oid_known()</code>.

     <p>If  <code>buf</code>is null then only the size will be filled. If the  <code>raw_flag</code>is not specified the output is always null terminated, although the
 <code>buf_size</code>will not include the null character.

     <p><strong> Returns:</strong> GNUTLS_E_SHORT_MEMORY_BUFFER if the provided buffer is not
long enough, and in that case the  <code>buf_size</code>will be updated
with the required size.  On success 0 is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_issuer_dn_oid</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_issuer_dn_oid</b> (<var>gnutls_x509_crt_t cert, int indx, void * oid, size_t * oid_size</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn_005foid-420"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>indx</var>: This specifies which OID to return. Use (0) to get the first one.

     <p><var>oid</var>: a pointer to a buffer to hold the OID (may be null)

     <p><var>oid_size</var>: initially holds the size of  <code>oid</code>

     <p><strong> Description:</strong> This function will extract the OIDs of the name of the Certificate
issuer specified by the given index.

     <p>If  <code>oid</code>is null then only the size will be filled. If the  <code>raw_flag</code>is not specified the output is always null terminated, although the
 <code>oid_size</code>will not include the null character.

     <p><strong> Returns:</strong> GNUTLS_E_SHORT_MEMORY_BUFFER if the provided buffer is not
long enough, and in that case the  <code>oid_size</code>will be updated
with the required size.  On success 0 is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_issuer_unique_id</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fissuer_005funique_005fid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_issuer_unique_id</b> (<var>gnutls_x509_crt_t crt, char * buf, size_t * buf_size</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fissuer_005funique_005fid-421"></a></var><br>
<blockquote><p><var>crt</var>: Holds the certificate

     <p><var>buf</var>: user allocated memory buffer, will hold the unique id

     <p><var>buf_size</var>: size of user allocated memory buffer (on input), will hold
actual size of the unique ID on return.

     <p><strong> Description:</strong> This function will extract the issuerUniqueID value (if present) for
the given certificate.

     <p>If the user allocated memory buffer is not large enough to hold the
full subjectUniqueID, then a GNUTLS_E_SHORT_MEMORY_BUFFER error will be
returned, and buf_size will be set to the actual length.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, otherwise a negative error code.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_key_id</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fkey_005fid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_key_id</b> (<var>gnutls_x509_crt_t crt, unsigned int flags, unsigned char * output_data, size_t * output_data_size</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fkey_005fid-422"></a></var><br>
<blockquote><p><var>crt</var>: Holds the certificate

     <p><var>flags</var>: should be 0 for now

     <p><var>output_data</var>: will contain the key ID

     <p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)

     <p><strong> Description:</strong> This function will return a unique ID the depends on the public
key parameters. This ID can be used in checking whether a
certificate corresponds to the given private key.

     <p>If the buffer provided is not long enough to hold the output, then
*output_data_size is updated and GNUTLS_E_SHORT_MEMORY_BUFFER will
be returned.  The output will normally be a SHA-1 hash output,
which is 20 bytes.

     <p><strong> Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_key_purpose_oid</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fkey_005fpurpose_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_key_purpose_oid</b> (<var>gnutls_x509_crt_t cert, int indx, void * oid, size_t * oid_size, unsigned int * critical</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fkey_005fpurpose_005foid-423"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>indx</var>: This specifies which OID to return. Use (0) to get the first one.

     <p><var>oid</var>: a pointer to a buffer to hold the OID (may be null)

     <p><var>oid_size</var>: initially holds the size of  <code>oid</code>

     <p><var>critical</var>: output flag to indicate criticality of extension

     <p><strong> Description:</strong> This function will extract the key purpose OIDs of the Certificate
specified by the given index.  These are stored in the Extended Key
Usage extension (2.5.29.37) See the GNUTLS_KP_* definitions for
human readable names.

     <p>If  <code>oid</code>is null then only the size will be filled. If the  <code>raw_flag</code>is not specified the output is always null terminated, although the
 <code>oid_size</code>will not include the null character.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> if the provided buffer is
not long enough, and in that case the *oid_size will be updated
with the required size.  On success 0 is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_key_usage</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fkey_005fusage"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_key_usage</b> (<var>gnutls_x509_crt_t cert, unsigned int * key_usage, unsigned int * critical</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fkey_005fusage-424"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>key_usage</var>: where the key usage bits will be stored

     <p><var>critical</var>: will be non (0) if the extension is marked as critical

     <p><strong> Description:</strong> This function will return certificate's key usage, by reading the
keyUsage X.509 extension (2.5.29.15). The key usage value will ORed
values of the: <code>GNUTLS_KEY_DIGITAL_SIGNATURE</code>,
<code>GNUTLS_KEY_NON_REPUDIATION</code>, <code>GNUTLS_KEY_KEY_ENCIPHERMENT</code>,
<code>GNUTLS_KEY_DATA_ENCIPHERMENT</code>, <code>GNUTLS_KEY_KEY_AGREEMENT</code>,
<code>GNUTLS_KEY_KEY_CERT_SIGN</code>, <code>GNUTLS_KEY_CRL_SIGN</code>,
<code>GNUTLS_KEY_ENCIPHER_ONLY</code>, <code>GNUTLS_KEY_DECIPHER_ONLY</code>.

     <p><strong> Returns:</strong> the certificate key usage, or a negative error code in case of
parsing error.  If the certificate does not contain the keyUsage
extension <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> will be
returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_pk_algorithm</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fpk_005falgorithm"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_pk_algorithm</b> (<var>gnutls_x509_crt_t cert, unsigned int * bits</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fpk_005falgorithm-425"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>bits</var>: if bits is non null it will hold the size of the parameters' in bits

     <p><strong> Description:</strong> This function will return the public key algorithm of an X.509
certificate.

     <p>If bits is non null, it should have enough size to hold the parameters
size in bits. For RSA the bits returned is the modulus. 
For DSA the bits returned are of the public
exponent.

     <p><strong> Returns:</strong> a member of the <code>gnutls_pk_algorithm_t</code> enumeration on
success, or a negative error code on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_pk_dsa_raw</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fpk_005fdsa_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_pk_dsa_raw</b> (<var>gnutls_x509_crt_t crt, gnutls_datum_t * p, gnutls_datum_t * q, gnutls_datum_t * g, gnutls_datum_t * y</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fpk_005fdsa_005fraw-426"></a></var><br>
<blockquote><p><var>crt</var>: Holds the certificate

     <p><var>p</var>: will hold the p

     <p><var>q</var>: will hold the q

     <p><var>g</var>: will hold the g

     <p><var>y</var>: will hold the y

     <p><strong> Description:</strong> This function will export the DSA public key's parameters found in
the given certificate.  The new parameters will be allocated using
<code>gnutls_malloc()</code> and will be stored in the appropriate datum.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, otherwise a negative error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_pk_rsa_raw</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fpk_005frsa_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_pk_rsa_raw</b> (<var>gnutls_x509_crt_t crt, gnutls_datum_t * m, gnutls_datum_t * e</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fpk_005frsa_005fraw-427"></a></var><br>
<blockquote><p><var>crt</var>: Holds the certificate

     <p><var>m</var>: will hold the modulus

     <p><var>e</var>: will hold the public exponent

     <p><strong> Description:</strong> This function will export the RSA public key's parameters found in
the given structure.  The new parameters will be allocated using
<code>gnutls_malloc()</code> and will be stored in the appropriate datum.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, otherwise a negative error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_proxy</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fproxy"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_proxy</b> (<var>gnutls_x509_crt_t cert, unsigned int * critical, int * pathlen, char ** policyLanguage, char ** policy, size_t * sizeof_policy</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fproxy-428"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>critical</var>: will be non (0) if the extension is marked as critical

     <p><var>pathlen</var>: pointer to output integer indicating path length (may be
NULL), non-negative error codes indicate a present pCPathLenConstraint
field and the actual value, -1 indicate that the field is absent.

     <p><var>policyLanguage</var>: output variable with OID of policy language

     <p><var>policy</var>: output variable with policy data

     <p><var>sizeof_policy</var>: output variable size of policy data

     <p><strong> Description:</strong> This function will get information from a proxy certificate.  It
reads the ProxyCertInfo X.509 extension (1.3.6.1.5.5.7.1.14).

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned,
otherwise a negative error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_raw_dn</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fraw_005fdn"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_raw_dn</b> (<var>gnutls_x509_crt_t cert, gnutls_datum_t * start</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fraw_005fdn-429"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>start</var>: will hold the starting point of the DN

     <p><strong> Description:</strong> This function will return a pointer to the DER encoded DN structure and
the length.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. or a negative error code on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_raw_issuer_dn</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fraw_005fissuer_005fdn"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_raw_issuer_dn</b> (<var>gnutls_x509_crt_t cert, gnutls_datum_t * start</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fraw_005fissuer_005fdn-430"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>start</var>: will hold the starting point of the DN

     <p><strong> Description:</strong> This function will return a pointer to the DER encoded DN structure
and the length.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.or a negative error code on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_serial</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fserial"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_serial</b> (<var>gnutls_x509_crt_t cert, void * result, size_t * result_size</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fserial-431"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>result</var>: The place where the serial number will be copied

     <p><var>result_size</var>: Holds the size of the result field.

     <p><strong> Description:</strong> This function will return the X.509 certificate's serial number. 
This is obtained by the X509 Certificate serialNumber field. Serial
is not always a 32 or 64bit number. Some CAs use large serial
numbers, thus it may be wise to handle it as something opaque.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_signature</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fsignature"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_signature</b> (<var>gnutls_x509_crt_t cert, char * sig, size_t * sizeof_sig</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fsignature-432"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>sig</var>: a pointer where the signature part will be copied (may be null).

     <p><var>sizeof_sig</var>: initially holds the size of  <code>sig</code>

     <p><strong> Description:</strong> This function will extract the signature field of a certificate.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. and a negative error code on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_signature_algorithm</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fsignature_005falgorithm"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_signature_algorithm</b> (<var>gnutls_x509_crt_t cert</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fsignature_005falgorithm-433"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><strong> Description:</strong> This function will return a value of the <code>gnutls_sign_algorithm_t</code>
enumeration that is the signature algorithm that has been used to
sign this certificate.

     <p><strong> Returns:</strong> a <code>gnutls_sign_algorithm_t</code> value, or a negative error code on
error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_subject</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fsubject"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_subject</b> (<var>gnutls_x509_crt_t cert, gnutls_x509_dn_t * dn</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fsubject-434"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>dn</var>: output variable with pointer to opaque DN.

     <p><strong> Description:</strong> Return the Certificate's Subject DN as an opaque data type.  You
may use <code>gnutls_x509_dn_get_rdn_ava()</code> to decode the DN.

     <p>Note that  <code>dn</code>should be treated as constant. Because points
into the  <code>cert</code>object, you may not deallocate  <code>cert</code>and continue to access  <code>dn</code>.

     <p><strong> Returns:</strong> Returns 0 on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_subject_alt_name</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fname"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_subject_alt_name</b> (<var>gnutls_x509_crt_t cert, unsigned int seq, void * ret, size_t * ret_size, unsigned int * critical</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fname-435"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>seq</var>: specifies the sequence number of the alt name (0 for the first one, 1 for the second etc.)

     <p><var>ret</var>: is the place where the alternative name will be copied to

     <p><var>ret_size</var>: holds the size of ret.

     <p><var>critical</var>: will be non (0) if the extension is marked as critical (may be null)

     <p><strong> Description:</strong> This function retrieves the Alternative Name (2.5.29.17), contained
in the given certificate in the X509v3 Certificate Extensions.

     <p>When the SAN type is otherName, it will extract the data in the
otherName's value field, and <code>GNUTLS_SAN_OTHERNAME</code> is returned. 
You may use <code>gnutls_x509_crt_get_subject_alt_othername_oid()</code> to get
the corresponding OID and the "virtual" SAN types (e.g.,
<code>GNUTLS_SAN_OTHERNAME_XMPP</code>).

     <p>If an otherName OID is known, the data will be decoded.  Otherwise
the returned data will be DER encoded, and you will have to decode
it yourself.  Currently, only the RFC 3920 id-on-xmppAddr SAN is
recognized.

     <p><strong> Returns:</strong> the alternative subject name type on success, one of the
enumerated <code>gnutls_x509_subject_alt_name_t</code>.  It will return
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> if  <code>ret_size</code>is not large enough to
hold the value.  In that case  <code>ret_size</code>will be updated with the
required size.  If the certificate does not have an Alternative
name with the specified sequence number then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_subject_alt_name2</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fname2"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_subject_alt_name2</b> (<var>gnutls_x509_crt_t cert, unsigned int seq, void * ret, size_t * ret_size, unsigned int * ret_type, unsigned int * critical</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fname2-436"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>seq</var>: specifies the sequence number of the alt name (0 for the first one, 1 for the second etc.)

     <p><var>ret</var>: is the place where the alternative name will be copied to

     <p><var>ret_size</var>: holds the size of ret.

     <p><var>ret_type</var>: holds the type of the alternative name (one of gnutls_x509_subject_alt_name_t).

     <p><var>critical</var>: will be non (0) if the extension is marked as critical (may be null)

     <p><strong> Description:</strong> This function will return the alternative names, contained in the
given certificate. It is the same as
<code>gnutls_x509_crt_get_subject_alt_name()</code> except for the fact that it
will return the type of the alternative name in  <code>ret_type</code>even if
the function fails for some reason (i.e.  the buffer provided is
not enough).

     <p><strong> Returns:</strong> the alternative subject name type on success, one of the
enumerated <code>gnutls_x509_subject_alt_name_t</code>.  It will return
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> if  <code>ret_size</code>is not large enough
to hold the value.  In that case  <code>ret_size</code>will be updated with
the required size.  If the certificate does not have an
Alternative name with the specified sequence number then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_subject_alt_othername_oid</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fothername_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_subject_alt_othername_oid</b> (<var>gnutls_x509_crt_t cert, unsigned int seq, void * oid, size_t * oid_size</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fothername_005foid-437"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>seq</var>: specifies the sequence number of the alt name (0 for the first one, 1 for the second etc.)

     <p><var>oid</var>: is the place where the otherName OID will be copied to

     <p><var>oid_size</var>: holds the size of ret.

     <p><strong> Description:</strong> This function will extract the type OID of an otherName Subject
Alternative Name, contained in the given certificate, and return
the type as an enumerated element.

     <p>This function is only useful if
<code>gnutls_x509_crt_get_subject_alt_name()</code> returned
<code>GNUTLS_SAN_OTHERNAME</code>.

     <p>If  <code>oid</code>is null then only the size will be filled. If the  <code>raw_flag</code>is not specified the output is always null terminated, although the
 <code>oid_size</code>will not include the null character.

     <p><strong> Returns:</strong> the alternative subject name type on success, one of the
enumerated gnutls_x509_subject_alt_name_t.  For supported OIDs, it
will return one of the virtual (GNUTLS_SAN_OTHERNAME_*) types,
e.g. <code>GNUTLS_SAN_OTHERNAME_XMPP</code>, and <code>GNUTLS_SAN_OTHERNAME</code> for
unknown OIDs.  It will return <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> if
 <code>ret_size</code>is not large enough to hold the value.  In that case
 <code>ret_size</code>will be updated with the required size.  If the
certificate does not have an Alternative name with the specified
sequence number and with the otherName type then
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_subject_key_id</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fsubject_005fkey_005fid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_subject_key_id</b> (<var>gnutls_x509_crt_t cert, void * ret, size_t * ret_size, unsigned int * critical</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fsubject_005fkey_005fid-438"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>ret</var>: The place where the identifier will be copied

     <p><var>ret_size</var>: Holds the size of the result field.

     <p><var>critical</var>: will be non (0) if the extension is marked as critical (may be null)

     <p><strong> Description:</strong> This function will return the X.509v3 certificate's subject key
identifier.  This is obtained by the X.509 Subject Key identifier
extension field (2.5.29.14).

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_subject_unique_id</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fsubject_005funique_005fid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_subject_unique_id</b> (<var>gnutls_x509_crt_t crt, char * buf, size_t * buf_size</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fsubject_005funique_005fid-439"></a></var><br>
<blockquote><p><var>crt</var>: Holds the certificate

     <p><var>buf</var>: user allocated memory buffer, will hold the unique id

     <p><var>buf_size</var>: size of user allocated memory buffer (on input), will hold
actual size of the unique ID on return.

     <p><strong> Description:</strong> This function will extract the subjectUniqueID value (if present) for
the given certificate.

     <p>If the user allocated memory buffer is not large enough to hold the
full subjectUniqueID, then a GNUTLS_E_SHORT_MEMORY_BUFFER error will be
returned, and buf_size will be set to the actual length.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, otherwise a negative error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_version</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fversion"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_version</b> (<var>gnutls_x509_crt_t cert</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fversion-440"></a></var><br>
<blockquote><p><var>cert</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><strong> Description:</strong> This function will return the version of the specified Certificate.

     <p><strong> Returns:</strong> version of certificate, or a negative error code on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_import</h4>

<p><a name="gnutls_005fx509_005fcrt_005fimport"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_import</b> (<var>gnutls_x509_crt_t cert, const gnutls_datum_t * data, gnutls_x509_crt_fmt_t format</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fimport-441"></a></var><br>
<blockquote><p><var>cert</var>: The structure to store the parsed certificate.

     <p><var>data</var>: The DER or PEM encoded certificate.

     <p><var>format</var>: One of DER or PEM

     <p><strong> Description:</strong> This function will convert the given DER or PEM encoded Certificate
to the native gnutls_x509_crt_t format. The output will be stored
in  <code>cert</code>.

     <p>If the Certificate is PEM encoded it should have a header of "X509
CERTIFICATE", or "CERTIFICATE".

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_init</h4>

<p><a name="gnutls_005fx509_005fcrt_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_init</b> (<var>gnutls_x509_crt_t * cert</var>)<var><a name="index-gnutls_005fx509_005fcrt_005finit-442"></a></var><br>
<blockquote><p><var>cert</var>: The structure to be initialized

     <p><strong> Description:</strong> This function will initialize an X.509 certificate structure.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_list_import</h4>

<p><a name="gnutls_005fx509_005fcrt_005flist_005fimport"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_list_import</b> (<var>gnutls_x509_crt_t * certs, unsigned int * cert_max, const gnutls_datum_t * data, gnutls_x509_crt_fmt_t format, unsigned int flags</var>)<var><a name="index-gnutls_005fx509_005fcrt_005flist_005fimport-443"></a></var><br>
<blockquote><p><var>certs</var>: The structures to store the parsed certificate. Must not be initialized.

     <p><var>cert_max</var>: Initially must hold the maximum number of certs. It will be updated with the number of certs available.

     <p><var>data</var>: The PEM encoded certificate.

     <p><var>format</var>: One of DER or PEM.

     <p><var>flags</var>: must be (0) or an OR'd sequence of gnutls_certificate_import_flags.

     <p><strong> Description:</strong> This function will convert the given PEM encoded certificate list
to the native gnutls_x509_crt_t format. The output will be stored
in  <code>certs</code>.  They will be automatically initialized.

     <p>The flag <code>GNUTLS_X509_CRT_LIST_IMPORT_FAIL_IF_EXCEED</code> will cause
import to fail if the certificates in the provided buffer are more
than the available structures. The <code>GNUTLS_X509_CRT_LIST_FAIL_IF_UNSORTED</code>
flag will cause the function to fail if the provided list is not
sorted from subject to issuer.

     <p>If the Certificate is PEM encoded it should have a header of "X509
CERTIFICATE", or "CERTIFICATE".

     <p><strong> Returns:</strong> the number of certificates read or a negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_list_import2</h4>

<p><a name="gnutls_005fx509_005fcrt_005flist_005fimport2"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_list_import2</b> (<var>gnutls_x509_crt_t ** certs, unsigned int * size, const gnutls_datum_t * data, gnutls_x509_crt_fmt_t format, unsigned int flags</var>)<var><a name="index-gnutls_005fx509_005fcrt_005flist_005fimport2-444"></a></var><br>
<blockquote><p><var>certs</var>: The structures to store the parsed certificate. Must not be initialized.

     <p><var>size</var>: It will contain the size of the list.

     <p><var>data</var>: The PEM encoded certificate.

     <p><var>format</var>: One of DER or PEM.

     <p><var>flags</var>: must be (0) or an OR'd sequence of gnutls_certificate_import_flags.

     <p><strong> Description:</strong> This function will convert the given PEM encoded certificate list
to the native gnutls_x509_crt_t format. The output will be stored
in  <code>certs</code>.  They will be automatically initialized.

     <p>If the Certificate is PEM encoded it should have a header of "X509
CERTIFICATE", or "CERTIFICATE".

     <p><strong> Returns:</strong> the number of certificates read or a negative error value.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_list_verify</h4>

<p><a name="gnutls_005fx509_005fcrt_005flist_005fverify"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_list_verify</b> (<var>const gnutls_x509_crt_t * cert_list, int cert_list_length, const gnutls_x509_crt_t * CA_list, int CA_list_length, const gnutls_x509_crl_t * CRL_list, int CRL_list_length, unsigned int flags, unsigned int * verify</var>)<var><a name="index-gnutls_005fx509_005fcrt_005flist_005fverify-445"></a></var><br>
<blockquote><p><var>cert_list</var>: is the certificate list to be verified

     <p><var>cert_list_length</var>: holds the number of certificate in cert_list

     <p><var>CA_list</var>: is the CA list which will be used in verification

     <p><var>CA_list_length</var>: holds the number of CA certificate in CA_list

     <p><var>CRL_list</var>: holds a list of CRLs.

     <p><var>CRL_list_length</var>: the length of CRL list.

     <p><var>flags</var>: Flags that may be used to change the verification algorithm. Use OR of the gnutls_certificate_verify_flags enumerations.

     <p><var>verify</var>: will hold the certificate verification output.

     <p><strong> Description:</strong> This function will try to verify the given certificate list and
return its status.  If no flags are specified (0), this function
will use the basicConstraints (2.5.29.19) PKIX extension. This
means that only a certificate authority is allowed to sign a
certificate.

     <p>You must also check the peer's name in order to check if the verified
certificate belongs to the actual peer.

     <p>The certificate verification output will be put in  <code>verify</code>and will
be one or more of the gnutls_certificate_status_t enumerated
elements bitwise or'd.  For a more detailed verification status use
<code>gnutls_x509_crt_verify()</code> per list element.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_print</h4>

<p><a name="gnutls_005fx509_005fcrt_005fprint"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_print</b> (<var>gnutls_x509_crt_t cert, gnutls_certificate_print_formats_t format, gnutls_datum_t * out</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fprint-446"></a></var><br>
<blockquote><p><var>cert</var>: The structure to be printed

     <p><var>format</var>: Indicate the format to use

     <p><var>out</var>: Newly allocated datum with (0) terminated string.

     <p><strong> Description:</strong> This function will pretty print a X.509 certificate, suitable for
display to a human.

     <p>If the format is <code>GNUTLS_CRT_PRINT_FULL</code> then all fields of the
certificate will be output, on multiple lines.  The
<code>GNUTLS_CRT_PRINT_ONELINE</code> format will generate one line with some
selected fields, which is useful for logging purposes.

     <p>The output  <code>out</code>needs to be deallocate using <code>gnutls_free()</code>.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_set_activation_time</h4>

<p><a name="gnutls_005fx509_005fcrt_005fset_005factivation_005ftime"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_set_activation_time</b> (<var>gnutls_x509_crt_t cert, time_t act_time</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fset_005factivation_005ftime-447"></a></var><br>
<blockquote><p><var>cert</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>act_time</var>: The actual time

     <p><strong> Description:</strong> This function will set the time this Certificate was or will be
activated.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_set_authority_key_id</h4>

<p><a name="gnutls_005fx509_005fcrt_005fset_005fauthority_005fkey_005fid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_set_authority_key_id</b> (<var>gnutls_x509_crt_t cert, const void * id, size_t id_size</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fset_005fauthority_005fkey_005fid-448"></a></var><br>
<blockquote><p><var>cert</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>id</var>: The key ID

     <p><var>id_size</var>: Holds the size of the serial field.

     <p><strong> Description:</strong> This function will set the X.509 certificate's authority key ID extension. 
Only the keyIdentifier field can be set with this function.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_set_basic_constraints</h4>

<p><a name="gnutls_005fx509_005fcrt_005fset_005fbasic_005fconstraints"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_set_basic_constraints</b> (<var>gnutls_x509_crt_t crt, unsigned int ca, int pathLenConstraint</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fset_005fbasic_005fconstraints-449"></a></var><br>
<blockquote><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>ca</var>: true(1) or false(0). Depending on the Certificate authority status.

     <p><var>pathLenConstraint</var>: non-negative error codes indicate maximum length of path,
and negative error codes indicate that the pathLenConstraints field should
not be present.

     <p><strong> Description:</strong> This function will set the basicConstraints certificate extension.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_set_ca_status</h4>

<p><a name="gnutls_005fx509_005fcrt_005fset_005fca_005fstatus"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_set_ca_status</b> (<var>gnutls_x509_crt_t crt, unsigned int ca</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fset_005fca_005fstatus-450"></a></var><br>
<blockquote><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>ca</var>: true(1) or false(0). Depending on the Certificate authority status.

     <p><strong> Description:</strong> This function will set the basicConstraints certificate extension. 
Use <code>gnutls_x509_crt_set_basic_constraints()</code> if you want to control
the pathLenConstraint field too.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_set_crl_dist_points</h4>

<p><a name="gnutls_005fx509_005fcrt_005fset_005fcrl_005fdist_005fpoints"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_set_crl_dist_points</b> (<var>gnutls_x509_crt_t crt, gnutls_x509_subject_alt_name_t type, const void * data_string, unsigned int reason_flags</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fset_005fcrl_005fdist_005fpoints-451"></a></var><br>
<blockquote><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>type</var>: is one of the gnutls_x509_subject_alt_name_t enumerations

     <p><var>data_string</var>: The data to be set

     <p><var>reason_flags</var>: revocation reasons

     <p><strong> Description:</strong> This function will set the CRL distribution points certificate extension.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_set_crl_dist_points2</h4>

<p><a name="gnutls_005fx509_005fcrt_005fset_005fcrl_005fdist_005fpoints2"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_set_crl_dist_points2</b> (<var>gnutls_x509_crt_t crt, gnutls_x509_subject_alt_name_t type, const void * data, unsigned int data_size, unsigned int reason_flags</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fset_005fcrl_005fdist_005fpoints2-452"></a></var><br>
<blockquote><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>type</var>: is one of the gnutls_x509_subject_alt_name_t enumerations

     <p><var>data</var>: The data to be set

     <p><var>data_size</var>: The data size

     <p><var>reason_flags</var>: revocation reasons

     <p><strong> Description:</strong> This function will set the CRL distribution points certificate extension.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.6.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_set_crq</h4>

<p><a name="gnutls_005fx509_005fcrt_005fset_005fcrq"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_set_crq</b> (<var>gnutls_x509_crt_t crt, gnutls_x509_crq_t crq</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fset_005fcrq-453"></a></var><br>
<blockquote><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>crq</var>: holds a certificate request

     <p><strong> Description:</strong> This function will set the name and public parameters as well as
the extensions from the given certificate request to the certificate. 
Only RSA keys are currently supported.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_set_crq_extensions</h4>

<p><a name="gnutls_005fx509_005fcrt_005fset_005fcrq_005fextensions"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_set_crq_extensions</b> (<var>gnutls_x509_crt_t crt, gnutls_x509_crq_t crq</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fset_005fcrq_005fextensions-454"></a></var><br>
<blockquote><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>crq</var>: holds a certificate request

     <p><strong> Description:</strong> This function will set extensions from the given request to the
certificate.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_set_dn_by_oid</h4>

<p><a name="gnutls_005fx509_005fcrt_005fset_005fdn_005fby_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_set_dn_by_oid</b> (<var>gnutls_x509_crt_t crt, const char * oid, unsigned int raw_flag, const void * name, unsigned int sizeof_name</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fset_005fdn_005fby_005foid-455"></a></var><br>
<blockquote><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>oid</var>: holds an Object Identifier in a null terminated string

     <p><var>raw_flag</var>: must be 0, or 1 if the data are DER encoded

     <p><var>name</var>: a pointer to the name

     <p><var>sizeof_name</var>: holds the size of  <code>name</code>

     <p><strong> Description:</strong> This function will set the part of the name of the Certificate
subject, specified by the given OID. The input string should be
ASCII or UTF-8 encoded.

     <p>Some helper macros with popular OIDs can be found in gnutls/x509.h
With this function you can only set the known OIDs. You can test
for known OIDs using <code>gnutls_x509_dn_oid_known()</code>. For OIDs that are
not known (by gnutls) you should properly DER encode your data,
and call this function with  <code>raw_flag</code>set.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_set_expiration_time</h4>

<p><a name="gnutls_005fx509_005fcrt_005fset_005fexpiration_005ftime"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_set_expiration_time</b> (<var>gnutls_x509_crt_t cert, time_t exp_time</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fset_005fexpiration_005ftime-456"></a></var><br>
<blockquote><p><var>cert</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>exp_time</var>: The actual time

     <p><strong> Description:</strong> This function will set the time this Certificate will expire.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_set_extension_by_oid</h4>

<p><a name="gnutls_005fx509_005fcrt_005fset_005fextension_005fby_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_set_extension_by_oid</b> (<var>gnutls_x509_crt_t crt, const char * oid, const void * buf, size_t sizeof_buf, unsigned int critical</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fset_005fextension_005fby_005foid-457"></a></var><br>
<blockquote><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>oid</var>: holds an Object Identified in null terminated string

     <p><var>buf</var>: a pointer to a DER encoded data

     <p><var>sizeof_buf</var>: holds the size of  <code>buf</code>

     <p><var>critical</var>: should be non (0) if the extension is to be marked as critical

     <p><strong> Description:</strong> This function will set an the extension, by the specified OID, in
the certificate.  The extension data should be binary data DER
encoded.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_set_issuer_dn_by_oid</h4>

<p><a name="gnutls_005fx509_005fcrt_005fset_005fissuer_005fdn_005fby_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_set_issuer_dn_by_oid</b> (<var>gnutls_x509_crt_t crt, const char * oid, unsigned int raw_flag, const void * name, unsigned int sizeof_name</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fset_005fissuer_005fdn_005fby_005foid-458"></a></var><br>
<blockquote><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>oid</var>: holds an Object Identifier in a null terminated string

     <p><var>raw_flag</var>: must be 0, or 1 if the data are DER encoded

     <p><var>name</var>: a pointer to the name

     <p><var>sizeof_name</var>: holds the size of  <code>name</code>

     <p><strong> Description:</strong> This function will set the part of the name of the Certificate
issuer, specified by the given OID.  The input string should be
ASCII or UTF-8 encoded.

     <p>Some helper macros with popular OIDs can be found in gnutls/x509.h
With this function you can only set the known OIDs. You can test
for known OIDs using <code>gnutls_x509_dn_oid_known()</code>. For OIDs that are
not known (by gnutls) you should properly DER encode your data,
and call this function with  <code>raw_flag</code>set.

     <p>Normally you do not need to call this function, since the signing
operation will copy the signer's name as the issuer of the
certificate.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_set_key</h4>

<p><a name="gnutls_005fx509_005fcrt_005fset_005fkey"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_set_key</b> (<var>gnutls_x509_crt_t crt, gnutls_x509_privkey_t key</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fset_005fkey-459"></a></var><br>
<blockquote><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>key</var>: holds a private key

     <p><strong> Description:</strong> This function will set the public parameters from the given
private key to the certificate. Only RSA keys are currently
supported.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_set_key_purpose_oid</h4>

<p><a name="gnutls_005fx509_005fcrt_005fset_005fkey_005fpurpose_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_set_key_purpose_oid</b> (<var>gnutls_x509_crt_t cert, const void * oid, unsigned int critical</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fset_005fkey_005fpurpose_005foid-460"></a></var><br>
<blockquote><p><var>cert</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>oid</var>: a pointer to a null terminated string that holds the OID

     <p><var>critical</var>: Whether this extension will be critical or not

     <p><strong> Description:</strong> This function will set the key purpose OIDs of the Certificate. 
These are stored in the Extended Key Usage extension (2.5.29.37)
See the GNUTLS_KP_* definitions for human readable names.

     <p>Subsequent calls to this function will append OIDs to the OID list.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned,
otherwise a negative error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_set_key_usage</h4>

<p><a name="gnutls_005fx509_005fcrt_005fset_005fkey_005fusage"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_set_key_usage</b> (<var>gnutls_x509_crt_t crt, unsigned int usage</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fset_005fkey_005fusage-461"></a></var><br>
<blockquote><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>usage</var>: an ORed sequence of the GNUTLS_KEY_* elements.

     <p><strong> Description:</strong> This function will set the keyUsage certificate extension.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_set_proxy</h4>

<p><a name="gnutls_005fx509_005fcrt_005fset_005fproxy"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_set_proxy</b> (<var>gnutls_x509_crt_t crt, int pathLenConstraint, const char * policyLanguage, const char * policy, size_t sizeof_policy</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fset_005fproxy-462"></a></var><br>
<blockquote><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>pathLenConstraint</var>: non-negative error codes indicate maximum length of path,
and negative error codes indicate that the pathLenConstraints field should
not be present.

     <p><var>policyLanguage</var>: OID describing the language of  <code>policy</code>.

     <p><var>policy</var>: opaque byte array with policy language, can be <code>NULL</code>

     <p><var>sizeof_policy</var>: size of  <code>policy</code>.

     <p><strong> Description:</strong> This function will set the proxyCertInfo extension.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_set_proxy_dn</h4>

<p><a name="gnutls_005fx509_005fcrt_005fset_005fproxy_005fdn"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_set_proxy_dn</b> (<var>gnutls_x509_crt_t crt, gnutls_x509_crt_t eecrt, unsigned int raw_flag, const void * name, unsigned int sizeof_name</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fset_005fproxy_005fdn-463"></a></var><br>
<blockquote><p><var>crt</var>: a gnutls_x509_crt_t structure with the new proxy cert

     <p><var>eecrt</var>: the end entity certificate that will be issuing the proxy

     <p><var>raw_flag</var>: must be 0, or 1 if the CN is DER encoded

     <p><var>name</var>: a pointer to the CN name, may be NULL (but MUST then be added later)

     <p><var>sizeof_name</var>: holds the size of  <code>name</code>

     <p><strong> Description:</strong> This function will set the subject in  <code>crt</code>to the end entity's
 <code>eecrt</code>subject name, and add a single Common Name component  <code>name</code>of size  <code>sizeof_name</code>.  This corresponds to the required proxy
certificate naming style.  Note that if  <code>name</code>is <code>NULL</code>, you MUST
set it later by using <code>gnutls_x509_crt_set_dn_by_oid()</code> or similar.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_set_serial</h4>

<p><a name="gnutls_005fx509_005fcrt_005fset_005fserial"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_set_serial</b> (<var>gnutls_x509_crt_t cert, const void * serial, size_t serial_size</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fset_005fserial-464"></a></var><br>
<blockquote><p><var>cert</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>serial</var>: The serial number

     <p><var>serial_size</var>: Holds the size of the serial field.

     <p><strong> Description:</strong> This function will set the X.509 certificate's serial number. 
Serial is not always a 32 or 64bit number.  Some CAs use large
serial numbers, thus it may be wise to handle it as something
opaque.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_set_subject_alternative_name</h4>

<p><a name="gnutls_005fx509_005fcrt_005fset_005fsubject_005falternative_005fname"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_set_subject_alternative_name</b> (<var>gnutls_x509_crt_t crt, gnutls_x509_subject_alt_name_t type, const char * data_string</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fset_005fsubject_005falternative_005fname-465"></a></var><br>
<blockquote><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>type</var>: is one of the gnutls_x509_subject_alt_name_t enumerations

     <p><var>data_string</var>: The data to be set, a (0) terminated string

     <p><strong> Description:</strong> This function will set the subject alternative name certificate
extension. This function assumes that data can be expressed as a null
terminated string.

     <p>The name of the function is unfortunate since it is incosistent with
<code>gnutls_x509_crt_get_subject_alt_name()</code>.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_set_subject_alt_name</h4>

<p><a name="gnutls_005fx509_005fcrt_005fset_005fsubject_005falt_005fname"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_set_subject_alt_name</b> (<var>gnutls_x509_crt_t crt, gnutls_x509_subject_alt_name_t type, const void * data, unsigned int data_size, unsigned int flags</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fset_005fsubject_005falt_005fname-466"></a></var><br>
<blockquote><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>type</var>: is one of the gnutls_x509_subject_alt_name_t enumerations

     <p><var>data</var>: The data to be set

     <p><var>data_size</var>: The size of data to be set

     <p><var>flags</var>: GNUTLS_FSAN_SET to clear previous data or GNUTLS_FSAN_APPEND to append.

     <p><strong> Description:</strong> This function will set the subject alternative name certificate
extension. It can set the following types:

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.6.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_set_subject_key_id</h4>

<p><a name="gnutls_005fx509_005fcrt_005fset_005fsubject_005fkey_005fid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_set_subject_key_id</b> (<var>gnutls_x509_crt_t cert, const void * id, size_t id_size</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fset_005fsubject_005fkey_005fid-467"></a></var><br>
<blockquote><p><var>cert</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>id</var>: The key ID

     <p><var>id_size</var>: Holds the size of the serial field.

     <p><strong> Description:</strong> This function will set the X.509 certificate's subject key ID
extension.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_set_version</h4>

<p><a name="gnutls_005fx509_005fcrt_005fset_005fversion"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_set_version</b> (<var>gnutls_x509_crt_t crt, unsigned int version</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fset_005fversion-468"></a></var><br>
<blockquote><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>version</var>: holds the version number. For X.509v1 certificates must be 1.

     <p><strong> Description:</strong> This function will set the version of the certificate.  This must
be one for X.509 version 1, and so on.  Plain certificates without
extensions must have version set to one.

     <p>To create well-formed certificates, you must specify version 3 if
you use any certificate extensions.  Extensions are created by
functions such as <code>gnutls_x509_crt_set_subject_alt_name()</code>
or <code>gnutls_x509_crt_set_key_usage()</code>.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_sign</h4>

<p><a name="gnutls_005fx509_005fcrt_005fsign"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_sign</b> (<var>gnutls_x509_crt_t crt, gnutls_x509_crt_t issuer, gnutls_x509_privkey_t issuer_key</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fsign-469"></a></var><br>
<blockquote><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>issuer</var>: is the certificate of the certificate issuer

     <p><var>issuer_key</var>: holds the issuer's private key

     <p><strong> Description:</strong> This function is the same a <code>gnutls_x509_crt_sign2()</code> with no flags,
and SHA1 as the hash algorithm.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_sign2</h4>

<p><a name="gnutls_005fx509_005fcrt_005fsign2"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_sign2</b> (<var>gnutls_x509_crt_t crt, gnutls_x509_crt_t issuer, gnutls_x509_privkey_t issuer_key, gnutls_digest_algorithm_t dig, unsigned int flags</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fsign2-470"></a></var><br>
<blockquote><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>issuer</var>: is the certificate of the certificate issuer

     <p><var>issuer_key</var>: holds the issuer's private key

     <p><var>dig</var>: The message digest to use, <code>GNUTLS_DIG_SHA1</code> is a safe choice

     <p><var>flags</var>: must be 0

     <p><strong> Description:</strong> This function will sign the certificate with the issuer's private key, and
will copy the issuer's information into the certificate.

     <p>This must be the last step in a certificate generation since all
the previously set parameters are now signed.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_verify</h4>

<p><a name="gnutls_005fx509_005fcrt_005fverify"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_verify</b> (<var>gnutls_x509_crt_t cert, const gnutls_x509_crt_t * CA_list, int CA_list_length, unsigned int flags, unsigned int * verify</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fverify-471"></a></var><br>
<blockquote><p><var>cert</var>: is the certificate to be verified

     <p><var>CA_list</var>: is one certificate that is considered to be trusted one

     <p><var>CA_list_length</var>: holds the number of CA certificate in CA_list

     <p><var>flags</var>: Flags that may be used to change the verification algorithm. Use OR of the gnutls_certificate_verify_flags enumerations.

     <p><var>verify</var>: will hold the certificate verification output.

     <p><strong> Description:</strong> This function will try to verify the given certificate and return
its status.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_dn_deinit</h4>

<p><a name="gnutls_005fx509_005fdn_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_x509_dn_deinit</b> (<var>gnutls_x509_dn_t dn</var>)<var><a name="index-gnutls_005fx509_005fdn_005fdeinit-472"></a></var><br>
<blockquote><p><var>dn</var>: a DN opaque object pointer.

     <p><strong> Description:</strong> This function deallocates the DN object as returned by
<code>gnutls_x509_dn_import()</code>.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_dn_export</h4>

<p><a name="gnutls_005fx509_005fdn_005fexport"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_dn_export</b> (<var>gnutls_x509_dn_t dn, gnutls_x509_crt_fmt_t format, void * output_data, size_t * output_data_size</var>)<var><a name="index-gnutls_005fx509_005fdn_005fexport-473"></a></var><br>
<blockquote><p><var>dn</var>: Holds the opaque DN object

     <p><var>format</var>: the format of output params. One of PEM or DER.

     <p><var>output_data</var>: will contain a DN PEM or DER encoded

     <p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)

     <p><strong> Description:</strong> This function will export the DN to DER or PEM format.

     <p>If the buffer provided is not long enough to hold the output, then
* <code>output_data_size</code>is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>
will be returned.

     <p>If the structure is PEM encoded, it will have a header
of "BEGIN NAME".

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_dn_get_rdn_ava</h4>

<p><a name="gnutls_005fx509_005fdn_005fget_005frdn_005fava"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_dn_get_rdn_ava</b> (<var>gnutls_x509_dn_t dn, int irdn, int iava, gnutls_x509_ava_st * ava</var>)<var><a name="index-gnutls_005fx509_005fdn_005fget_005frdn_005fava-474"></a></var><br>
<blockquote><p><var>dn</var>: input variable with opaque DN pointer

     <p><var>irdn</var>: index of RDN

     <p><var>iava</var>: index of AVA.

     <p><var>ava</var>: Pointer to structure which will hold output information.

     <p><strong> Description:</strong> Get pointers to data within the DN.

     <p>Note that  <code>ava</code>will contain pointers into the  <code>dn</code>structure, so you
should not modify any data or deallocate it.  Note also that the DN
in turn points into the original certificate structure, and thus
you may not deallocate the certificate and continue to access  <code>dn</code>.

     <p><strong> Returns:</strong> Returns 0 on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_dn_import</h4>

<p><a name="gnutls_005fx509_005fdn_005fimport"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_dn_import</b> (<var>gnutls_x509_dn_t dn, const gnutls_datum_t * data</var>)<var><a name="index-gnutls_005fx509_005fdn_005fimport-475"></a></var><br>
<blockquote><p><var>dn</var>: the structure that will hold the imported DN

     <p><var>data</var>: should contain a DER encoded RDN sequence

     <p><strong> Description:</strong> This function parses an RDN sequence and stores the result to a
<code>gnutls_x509_dn_t</code> structure. The structure must have been initialized
with <code>gnutls_x509_dn_init()</code>. You may use <code>gnutls_x509_dn_get_rdn_ava()</code> to
decode the DN.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_dn_init</h4>

<p><a name="gnutls_005fx509_005fdn_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_dn_init</b> (<var>gnutls_x509_dn_t * dn</var>)<var><a name="index-gnutls_005fx509_005fdn_005finit-476"></a></var><br>
<blockquote><p><var>dn</var>: the object to be initialized

     <p><strong> Description:</strong> This function initializes a <code>gnutls_x509_dn_t</code> structure.

     <p>The object returned must be deallocated using
<code>gnutls_x509_dn_deinit()</code>.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_dn_oid_known</h4>

<p><a name="gnutls_005fx509_005fdn_005foid_005fknown"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_dn_oid_known</b> (<var>const char * oid</var>)<var><a name="index-gnutls_005fx509_005fdn_005foid_005fknown-477"></a></var><br>
<blockquote><p><var>oid</var>: holds an Object Identifier in a null terminated string

     <p><strong> Description:</strong> This function will inform about known DN OIDs. This is useful since
functions like <code>gnutls_x509_crt_set_dn_by_oid()</code> use the information
on known OIDs to properly encode their input. Object Identifiers
that are not known are not encoded by these functions, and their
input is stored directly into the ASN.1 structure. In that case of
unknown OIDs, you have the responsibility of DER encoding your
data.

     <p><strong> Returns:</strong> 1 on known OIDs and 0 otherwise. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_privkey_cpy</h4>

<p><a name="gnutls_005fx509_005fprivkey_005fcpy"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_privkey_cpy</b> (<var>gnutls_x509_privkey_t dst, gnutls_x509_privkey_t src</var>)<var><a name="index-gnutls_005fx509_005fprivkey_005fcpy-478"></a></var><br>
<blockquote><p><var>dst</var>: The destination key, which should be initialized.

     <p><var>src</var>: The source key

     <p><strong> Description:</strong> This function will copy a private key from source to destination
key. Destination has to be initialized.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_privkey_deinit</h4>

<p><a name="gnutls_005fx509_005fprivkey_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_x509_privkey_deinit</b> (<var>gnutls_x509_privkey_t key</var>)<var><a name="index-gnutls_005fx509_005fprivkey_005fdeinit-479"></a></var><br>
<blockquote><p><var>key</var>: The structure to be deinitialized

     <p><strong> Description:</strong> This function will deinitialize a private key structure. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_privkey_export</h4>

<p><a name="gnutls_005fx509_005fprivkey_005fexport"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_privkey_export</b> (<var>gnutls_x509_privkey_t key, gnutls_x509_crt_fmt_t format, void * output_data, size_t * output_data_size</var>)<var><a name="index-gnutls_005fx509_005fprivkey_005fexport-480"></a></var><br>
<blockquote><p><var>key</var>: Holds the key

     <p><var>format</var>: the format of output params. One of PEM or DER.

     <p><var>output_data</var>: will contain a private key PEM or DER encoded

     <p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)

     <p><strong> Description:</strong> This function will export the private key to a PKCS1 structure for
RSA keys, or an integer sequence for DSA keys.  The DSA keys are in
the same format with the parameters used by openssl.

     <p>If the buffer provided is not long enough to hold the output, then
* <code>output_data_size</code>is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code>
will be returned.

     <p>If the structure is PEM encoded, it will have a header
of "BEGIN RSA PRIVATE KEY".

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_privkey_export_dsa_raw</h4>

<p><a name="gnutls_005fx509_005fprivkey_005fexport_005fdsa_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_privkey_export_dsa_raw</b> (<var>gnutls_x509_privkey_t key, gnutls_datum_t * p, gnutls_datum_t * q, gnutls_datum_t * g, gnutls_datum_t * y, gnutls_datum_t * x</var>)<var><a name="index-gnutls_005fx509_005fprivkey_005fexport_005fdsa_005fraw-481"></a></var><br>
<blockquote><p><var>key</var>: a structure that holds the DSA parameters

     <p><var>p</var>: will hold the p

     <p><var>q</var>: will hold the q

     <p><var>g</var>: will hold the g

     <p><var>y</var>: will hold the y

     <p><var>x</var>: will hold the x

     <p><strong> Description:</strong> This function will export the DSA private key's parameters found
in the given structure. The new parameters will be allocated using
<code>gnutls_malloc()</code> and will be stored in the appropriate datum.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_privkey_export_ecc_raw</h4>

<p><a name="gnutls_005fx509_005fprivkey_005fexport_005fecc_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_privkey_export_ecc_raw</b> (<var>gnutls_x509_privkey_t key, gnutls_ecc_curve_t * curve, gnutls_datum_t * x, gnutls_datum_t * y, gnutls_datum_t* k</var>)<var><a name="index-gnutls_005fx509_005fprivkey_005fexport_005fecc_005fraw-482"></a></var><br>
<blockquote><p><var>key</var>: a structure that holds the rsa parameters

     <p><var>curve</var>: will hold the curve

     <p><var>x</var>: will hold the x coordinate

     <p><var>y</var>: will hold the y coordinate

     <p><var>k</var>: will hold the private key

     <p><strong> Description:</strong> This function will export the ECC private key's parameters found
in the given structure. The new parameters will be allocated using
<code>gnutls_malloc()</code> and will be stored in the appropriate datum.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_privkey_export_pkcs8</h4>

<p><a name="gnutls_005fx509_005fprivkey_005fexport_005fpkcs8"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_privkey_export_pkcs8</b> (<var>gnutls_x509_privkey_t key, gnutls_x509_crt_fmt_t format, const char * password, unsigned int flags, void * output_data, size_t * output_data_size</var>)<var><a name="index-gnutls_005fx509_005fprivkey_005fexport_005fpkcs8-483"></a></var><br>
<blockquote><p><var>key</var>: Holds the key

     <p><var>format</var>: the format of output params. One of PEM or DER.

     <p><var>password</var>: the password that will be used to encrypt the key.

     <p><var>flags</var>: an ORed sequence of gnutls_pkcs_encrypt_flags_t

     <p><var>output_data</var>: will contain a private key PEM or DER encoded

     <p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)

     <p><strong> Description:</strong> This function will export the private key to a PKCS8 structure. 
Both RSA and DSA keys can be exported. For DSA keys we use
PKCS <code>11</code> definitions. If the flags do not specify the encryption
cipher, then the default 3DES (PBES2) will be used.

     <p>The  <code>password</code>can be either ASCII or UTF-8 in the default PBES2
encryption schemas, or ASCII for the PKCS12 schemas.

     <p>If the buffer provided is not long enough to hold the output, then
*output_data_size is updated and GNUTLS_E_SHORT_MEMORY_BUFFER will
be returned.

     <p>If the structure is PEM encoded, it will have a header
of "BEGIN ENCRYPTED PRIVATE KEY" or "BEGIN PRIVATE KEY" if
encryption is not used.

     <p><strong> Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_privkey_export_rsa_raw</h4>

<p><a name="gnutls_005fx509_005fprivkey_005fexport_005frsa_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_privkey_export_rsa_raw</b> (<var>gnutls_x509_privkey_t key, gnutls_datum_t * m, gnutls_datum_t * e, gnutls_datum_t * d, gnutls_datum_t * p, gnutls_datum_t * q, gnutls_datum_t * u</var>)<var><a name="index-gnutls_005fx509_005fprivkey_005fexport_005frsa_005fraw-484"></a></var><br>
<blockquote><p><var>key</var>: a structure that holds the rsa parameters

     <p><var>m</var>: will hold the modulus

     <p><var>e</var>: will hold the public exponent

     <p><var>d</var>: will hold the private exponent

     <p><var>p</var>: will hold the first prime (p)

     <p><var>q</var>: will hold the second prime (q)

     <p><var>u</var>: will hold the coefficient

     <p><strong> Description:</strong> This function will export the RSA private key's parameters found
in the given structure. The new parameters will be allocated using
<code>gnutls_malloc()</code> and will be stored in the appropriate datum.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_privkey_export_rsa_raw2</h4>

<p><a name="gnutls_005fx509_005fprivkey_005fexport_005frsa_005fraw2"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_privkey_export_rsa_raw2</b> (<var>gnutls_x509_privkey_t key, gnutls_datum_t * m, gnutls_datum_t * e, gnutls_datum_t * d, gnutls_datum_t * p, gnutls_datum_t * q, gnutls_datum_t * u, gnutls_datum_t * e1, gnutls_datum_t * e2</var>)<var><a name="index-gnutls_005fx509_005fprivkey_005fexport_005frsa_005fraw2-485"></a></var><br>
<blockquote><p><var>key</var>: a structure that holds the rsa parameters

     <p><var>m</var>: will hold the modulus

     <p><var>e</var>: will hold the public exponent

     <p><var>d</var>: will hold the private exponent

     <p><var>p</var>: will hold the first prime (p)

     <p><var>q</var>: will hold the second prime (q)

     <p><var>u</var>: will hold the coefficient

     <p><var>e1</var>: will hold e1 = d mod (p-1)

     <p><var>e2</var>: will hold e2 = d mod (q-1)

     <p><strong> Description:</strong> This function will export the RSA private key's parameters found
in the given structure. The new parameters will be allocated using
<code>gnutls_malloc()</code> and will be stored in the appropriate datum.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_privkey_fix</h4>

<p><a name="gnutls_005fx509_005fprivkey_005ffix"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_privkey_fix</b> (<var>gnutls_x509_privkey_t key</var>)<var><a name="index-gnutls_005fx509_005fprivkey_005ffix-486"></a></var><br>
<blockquote><p><var>key</var>: Holds the key

     <p><strong> Description:</strong> This function will recalculate the secondary parameters in a key. 
In RSA keys, this can be the coefficient and exponent1,2.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_privkey_generate</h4>

<p><a name="gnutls_005fx509_005fprivkey_005fgenerate"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_privkey_generate</b> (<var>gnutls_x509_privkey_t key, gnutls_pk_algorithm_t algo, unsigned int bits, unsigned int flags</var>)<var><a name="index-gnutls_005fx509_005fprivkey_005fgenerate-487"></a></var><br>
<blockquote><p><var>key</var>: should contain a <code>gnutls_x509_privkey_t</code> structure

     <p><var>algo</var>: is one of the algorithms in <code>gnutls_pk_algorithm_t</code>.

     <p><var>bits</var>: the size of the modulus

     <p><var>flags</var>: unused for now.  Must be 0.

     <p><strong> Description:</strong> This function will generate a random private key. Note that this
function must be called on an empty private key.

     <p>Do not set the number of bits directly, use <code>gnutls_sec_param_to_pk_bits()</code>.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_privkey_get_key_id</h4>

<p><a name="gnutls_005fx509_005fprivkey_005fget_005fkey_005fid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_privkey_get_key_id</b> (<var>gnutls_x509_privkey_t key, unsigned int flags, unsigned char * output_data, size_t * output_data_size</var>)<var><a name="index-gnutls_005fx509_005fprivkey_005fget_005fkey_005fid-488"></a></var><br>
<blockquote><p><var>key</var>: Holds the key

     <p><var>flags</var>: should be 0 for now

     <p><var>output_data</var>: will contain the key ID

     <p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)

     <p><strong> Description:</strong> This function will return a unique ID the depends on the public key
parameters. This ID can be used in checking whether a certificate
corresponds to the given key.

     <p>If the buffer provided is not long enough to hold the output, then
* <code>output_data_size</code>is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> will
be returned.  The output will normally be a SHA-1 hash output,
which is 20 bytes.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_privkey_get_pk_algorithm</h4>

<p><a name="gnutls_005fx509_005fprivkey_005fget_005fpk_005falgorithm"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_privkey_get_pk_algorithm</b> (<var>gnutls_x509_privkey_t key</var>)<var><a name="index-gnutls_005fx509_005fprivkey_005fget_005fpk_005falgorithm-489"></a></var><br>
<blockquote><p><var>key</var>: should contain a <code>gnutls_x509_privkey_t</code> structure

     <p><strong> Description:</strong> This function will return the public key algorithm of a private
key.

     <p><strong> Returns:</strong> a member of the <code>gnutls_pk_algorithm_t</code> enumeration on
success, or a negative error code on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_privkey_import</h4>

<p><a name="gnutls_005fx509_005fprivkey_005fimport"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_privkey_import</b> (<var>gnutls_x509_privkey_t key, const gnutls_datum_t * data, gnutls_x509_crt_fmt_t format</var>)<var><a name="index-gnutls_005fx509_005fprivkey_005fimport-490"></a></var><br>
<blockquote><p><var>key</var>: The structure to store the parsed key

     <p><var>data</var>: The DER or PEM encoded certificate.

     <p><var>format</var>: One of DER or PEM

     <p><strong> Description:</strong> This function will convert the given DER or PEM encoded key to the
native <code>gnutls_x509_privkey_t</code> format. The output will be stored in
 <code>key</code>.

     <p>If the key is PEM encoded it should have a header of "RSA PRIVATE
KEY", or "DSA PRIVATE KEY".

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_privkey_import_dsa_raw</h4>

<p><a name="gnutls_005fx509_005fprivkey_005fimport_005fdsa_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_privkey_import_dsa_raw</b> (<var>gnutls_x509_privkey_t key, const gnutls_datum_t * p, const gnutls_datum_t * q, const gnutls_datum_t * g, const gnutls_datum_t * y, const gnutls_datum_t * x</var>)<var><a name="index-gnutls_005fx509_005fprivkey_005fimport_005fdsa_005fraw-491"></a></var><br>
<blockquote><p><var>key</var>: The structure to store the parsed key

     <p><var>p</var>: holds the p

     <p><var>q</var>: holds the q

     <p><var>g</var>: holds the g

     <p><var>y</var>: holds the y

     <p><var>x</var>: holds the x

     <p><strong> Description:</strong> This function will convert the given DSA raw parameters to the
native <code>gnutls_x509_privkey_t</code> format.  The output will be stored
in  <code>key</code>.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_privkey_import_ecc_raw</h4>

<p><a name="gnutls_005fx509_005fprivkey_005fimport_005fecc_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_privkey_import_ecc_raw</b> (<var>gnutls_x509_privkey_t key, gnutls_ecc_curve_t curve, const gnutls_datum_t * x, const gnutls_datum_t * y, const gnutls_datum_t * k</var>)<var><a name="index-gnutls_005fx509_005fprivkey_005fimport_005fecc_005fraw-492"></a></var><br>
<blockquote><p><var>key</var>: The structure to store the parsed key

     <p><var>curve</var>: holds the curve

     <p><var>x</var>: holds the x

     <p><var>y</var>: holds the y

     <p><var>k</var>: holds the k

     <p><strong> Description:</strong> This function will convert the given elliptic curve parameters to the
native <code>gnutls_x509_privkey_t</code> format.  The output will be stored
in  <code>key</code>.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_privkey_import_pkcs8</h4>

<p><a name="gnutls_005fx509_005fprivkey_005fimport_005fpkcs8"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_privkey_import_pkcs8</b> (<var>gnutls_x509_privkey_t key, const gnutls_datum_t * data, gnutls_x509_crt_fmt_t format, const char * password, unsigned int flags</var>)<var><a name="index-gnutls_005fx509_005fprivkey_005fimport_005fpkcs8-493"></a></var><br>
<blockquote><p><var>key</var>: The structure to store the parsed key

     <p><var>data</var>: The DER or PEM encoded key.

     <p><var>format</var>: One of DER or PEM

     <p><var>password</var>: the password to decrypt the key (if it is encrypted).

     <p><var>flags</var>: 0 if encrypted or GNUTLS_PKCS_PLAIN if not encrypted.

     <p><strong> Description:</strong> This function will convert the given DER or PEM encoded PKCS8 2.0
encrypted key to the native gnutls_x509_privkey_t format. The
output will be stored in  <code>key</code>.  Both RSA and DSA keys can be
imported, and flags can only be used to indicate an unencrypted
key.

     <p>The  <code>password</code>can be either ASCII or UTF-8 in the default PBES2
encryption schemas, or ASCII for the PKCS12 schemas.

     <p>If the Certificate is PEM encoded it should have a header of
"ENCRYPTED PRIVATE KEY", or "PRIVATE KEY". You only need to
specify the flags if the key is DER encoded, since in that case
the encryption status cannot be auto-detected.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_privkey_import_rsa_raw</h4>

<p><a name="gnutls_005fx509_005fprivkey_005fimport_005frsa_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_privkey_import_rsa_raw</b> (<var>gnutls_x509_privkey_t key, const gnutls_datum_t * m, const gnutls_datum_t * e, const gnutls_datum_t * d, const gnutls_datum_t * p, const gnutls_datum_t * q, const gnutls_datum_t * u</var>)<var><a name="index-gnutls_005fx509_005fprivkey_005fimport_005frsa_005fraw-494"></a></var><br>
<blockquote><p><var>key</var>: The structure to store the parsed key

     <p><var>m</var>: holds the modulus

     <p><var>e</var>: holds the public exponent

     <p><var>d</var>: holds the private exponent

     <p><var>p</var>: holds the first prime (p)

     <p><var>q</var>: holds the second prime (q)

     <p><var>u</var>: holds the coefficient

     <p><strong> Description:</strong> This function will convert the given RSA raw parameters to the
native <code>gnutls_x509_privkey_t</code> format.  The output will be stored in
 <code>key</code>.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_privkey_import_rsa_raw2</h4>

<p><a name="gnutls_005fx509_005fprivkey_005fimport_005frsa_005fraw2"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_privkey_import_rsa_raw2</b> (<var>gnutls_x509_privkey_t key, const gnutls_datum_t * m, const gnutls_datum_t * e, const gnutls_datum_t * d, const gnutls_datum_t * p, const gnutls_datum_t * q, const gnutls_datum_t * u, const gnutls_datum_t * e1, const gnutls_datum_t * e2</var>)<var><a name="index-gnutls_005fx509_005fprivkey_005fimport_005frsa_005fraw2-495"></a></var><br>
<blockquote><p><var>key</var>: The structure to store the parsed key

     <p><var>m</var>: holds the modulus

     <p><var>e</var>: holds the public exponent

     <p><var>d</var>: holds the private exponent

     <p><var>p</var>: holds the first prime (p)

     <p><var>q</var>: holds the second prime (q)

     <p><var>u</var>: holds the coefficient

     <p><var>e1</var>: holds e1 = d mod (p-1)

     <p><var>e2</var>: holds e2 = d mod (q-1)

     <p><strong> Description:</strong> This function will convert the given RSA raw parameters to the
native <code>gnutls_x509_privkey_t</code> format.  The output will be stored in
 <code>key</code>.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_privkey_init</h4>

<p><a name="gnutls_005fx509_005fprivkey_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_privkey_init</b> (<var>gnutls_x509_privkey_t * key</var>)<var><a name="index-gnutls_005fx509_005fprivkey_005finit-496"></a></var><br>
<blockquote><p><var>key</var>: The structure to be initialized

     <p><strong> Description:</strong> This function will initialize an private key structure.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_privkey_sec_param</h4>

<p><a name="gnutls_005fx509_005fprivkey_005fsec_005fparam"></a>

<div class="defun">
&mdash; Function: gnutls_sec_param_t <b>gnutls_x509_privkey_sec_param</b> (<var>gnutls_x509_privkey_t key</var>)<var><a name="index-gnutls_005fx509_005fprivkey_005fsec_005fparam-497"></a></var><br>
<blockquote><p><var>key</var>: a key structure

     <p><strong> Description:</strong> This function will return the security parameter appropriate with
this private key.

     <p><strong> Returns:</strong> On success, a valid security parameter is returned otherwise
<code>GNUTLS_SEC_PARAM_UNKNOWN</code> is returned.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_privkey_verify_params</h4>

<p><a name="gnutls_005fx509_005fprivkey_005fverify_005fparams"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_privkey_verify_params</b> (<var>gnutls_x509_privkey_t key</var>)<var><a name="index-gnutls_005fx509_005fprivkey_005fverify_005fparams-498"></a></var><br>
<blockquote><p><var>key</var>: should contain a <code>gnutls_x509_privkey_t</code> structure

     <p><strong> Description:</strong> This function will verify the private key parameters.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_rdn_get</h4>

<p><a name="gnutls_005fx509_005frdn_005fget"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_rdn_get</b> (<var>const gnutls_datum_t * idn, char * buf, size_t * sizeof_buf</var>)<var><a name="index-gnutls_005fx509_005frdn_005fget-499"></a></var><br>
<blockquote><p><var>idn</var>: should contain a DER encoded RDN sequence

     <p><var>buf</var>: a pointer to a structure to hold the peer's name

     <p><var>sizeof_buf</var>: holds the size of  <code>buf</code>

     <p><strong> Description:</strong> This function will return the name of the given RDN sequence.  The
name will be in the form "C=xxxx,O=yyyy,CN=zzzz" as described in
RFC2253.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, or
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> is returned and * <code>sizeof_buf</code>is
updated if the provided buffer is not long enough, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_rdn_get_by_oid</h4>

<p><a name="gnutls_005fx509_005frdn_005fget_005fby_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_rdn_get_by_oid</b> (<var>const gnutls_datum_t * idn, const char * oid, int indx, unsigned int raw_flag, void * buf, size_t * sizeof_buf</var>)<var><a name="index-gnutls_005fx509_005frdn_005fget_005fby_005foid-500"></a></var><br>
<blockquote><p><var>idn</var>: should contain a DER encoded RDN sequence

     <p><var>oid</var>: an Object Identifier

     <p><var>indx</var>: In case multiple same OIDs exist in the RDN indicates which
to send. Use 0 for the first one.

     <p><var>raw_flag</var>: If non (0) then the raw DER data are returned.

     <p><var>buf</var>: a pointer to a structure to hold the peer's name

     <p><var>sizeof_buf</var>: holds the size of  <code>buf</code>

     <p><strong> Description:</strong> This function will return the name of the given Object identifier,
of the RDN sequence.  The name will be encoded using the rules
from RFC2253.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, or
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> is returned and * <code>sizeof_buf</code>is
updated if the provided buffer is not long enough, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_rdn_get_oid</h4>

<p><a name="gnutls_005fx509_005frdn_005fget_005foid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_rdn_get_oid</b> (<var>const gnutls_datum_t * idn, int indx, void * buf, size_t * sizeof_buf</var>)<var><a name="index-gnutls_005fx509_005frdn_005fget_005foid-501"></a></var><br>
<blockquote><p><var>idn</var>: should contain a DER encoded RDN sequence

     <p><var>indx</var>: Indicates which OID to return. Use 0 for the first one.

     <p><var>buf</var>: a pointer to a structure to hold the peer's name OID

     <p><var>sizeof_buf</var>: holds the size of  <code>buf</code>

     <p><strong> Description:</strong> This function will return the specified Object identifier, of the
RDN sequence.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, or
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> is returned and * <code>sizeof_buf</code>is
updated if the provided buffer is not long enough, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_trust_list_add_cas</h4>

<p><a name="gnutls_005fx509_005ftrust_005flist_005fadd_005fcas"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_trust_list_add_cas</b> (<var>gnutls_x509_trust_list_t list, const gnutls_x509_crt_t * clist, int clist_size, unsigned int flags</var>)<var><a name="index-gnutls_005fx509_005ftrust_005flist_005fadd_005fcas-502"></a></var><br>
<blockquote><p><var>list</var>: The structure of the list

     <p><var>clist</var>: A list of CAs

     <p><var>clist_size</var>: The length of the CA list

     <p><var>flags</var>: should be 0.

     <p><strong> Description:</strong> This function will add the given certificate authorities
to the trusted list. The list of CAs must not be deinitialized
during this structure's lifetime.

     <p><strong> Returns:</strong> The number of added elements is returned.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_trust_list_add_crls</h4>

<p><a name="gnutls_005fx509_005ftrust_005flist_005fadd_005fcrls"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_trust_list_add_crls</b> (<var>gnutls_x509_trust_list_t list, const gnutls_x509_crl_t * crl_list, int crl_size, unsigned int flags, unsigned int verification_flags</var>)<var><a name="index-gnutls_005fx509_005ftrust_005flist_005fadd_005fcrls-503"></a></var><br>
<blockquote><p><var>list</var>: The structure of the list

     <p><var>crl_list</var>: A list of CRLs

     <p><var>crl_size</var>: The length of the CRL list

     <p><var>flags</var>: if GNUTLS_TL_VERIFY_CRL is given the CRLs will be verified before being added.

     <p><var>verification_flags</var>: gnutls_certificate_verify_flags if flags specifies GNUTLS_TL_VERIFY_CRL

     <p><strong> Description:</strong> This function will add the given certificate revocation lists
to the trusted list. The list of CRLs must not be deinitialized
during this structure's lifetime.

     <p>This function must be called after <code>gnutls_x509_trust_list_add_cas()</code>
to allow verifying the CRLs for validity.

     <p><strong> Returns:</strong> The number of added elements is returned.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_trust_list_add_named_crt</h4>

<p><a name="gnutls_005fx509_005ftrust_005flist_005fadd_005fnamed_005fcrt"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_trust_list_add_named_crt</b> (<var>gnutls_x509_trust_list_t list, gnutls_x509_crt_t cert, const void * name, size_t name_size, unsigned int flags</var>)<var><a name="index-gnutls_005fx509_005ftrust_005flist_005fadd_005fnamed_005fcrt-504"></a></var><br>
<blockquote><p><var>list</var>: The structure of the list

     <p><var>cert</var>: A certificate

     <p><var>name</var>: An identifier for the certificate

     <p><var>name_size</var>: The size of the identifier

     <p><var>flags</var>: should be 0.

     <p><strong> Description:</strong> This function will add the given certificate to the trusted
list and associate it with a name. The certificate will not be
be used for verification with <code>gnutls_x509_trust_list_verify_crt()</code>
but only with <code>gnutls_x509_trust_list_verify_named_crt()</code>.

     <p>In principle this function can be used to set individual "server"
certificates that are trusted by the user for that specific server
but for no other purposes.

     <p>The certificate must not be deinitialized during the lifetime
of the trusted list.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_trust_list_deinit</h4>

<p><a name="gnutls_005fx509_005ftrust_005flist_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_x509_trust_list_deinit</b> (<var>gnutls_x509_trust_list_t list, unsigned int all</var>)<var><a name="index-gnutls_005fx509_005ftrust_005flist_005fdeinit-505"></a></var><br>
<blockquote><p><var>list</var>: The structure to be deinitialized

     <p><var>all</var>: if non-(0) it will deinitialize all the certificates and CRLs contained in the structure.

     <p><strong> Description:</strong> This function will deinitialize a trust list.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_trust_list_get_issuer</h4>

<p><a name="gnutls_005fx509_005ftrust_005flist_005fget_005fissuer"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_trust_list_get_issuer</b> (<var>gnutls_x509_trust_list_t list, gnutls_x509_crt_t cert, gnutls_x509_crt_t * issuer, unsigned int flags</var>)<var><a name="index-gnutls_005fx509_005ftrust_005flist_005fget_005fissuer-506"></a></var><br>
<blockquote><p><var>list</var>: The structure of the list

     <p><var>cert</var>: is the certificate to find issuer for

     <p><var>issuer</var>: Will hold the issuer if any. Should be treated as constant.

     <p><var>flags</var>: Use (0).

     <p><strong> Description:</strong> This function will attempt to find the issuer of the
given certificate.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_trust_list_init</h4>

<p><a name="gnutls_005fx509_005ftrust_005flist_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_trust_list_init</b> (<var>gnutls_x509_trust_list_t * list, unsigned int size</var>)<var><a name="index-gnutls_005fx509_005ftrust_005flist_005finit-507"></a></var><br>
<blockquote><p><var>list</var>: The structure to be initialized

     <p><var>size</var>: The size of the internal hash table. Use (0) for default size.

     <p><strong> Description:</strong> This function will initialize an X.509 trust list structure.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_trust_list_verify_crt</h4>

<p><a name="gnutls_005fx509_005ftrust_005flist_005fverify_005fcrt"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_trust_list_verify_crt</b> (<var>gnutls_x509_trust_list_t list, gnutls_x509_crt_t * cert_list, unsigned int cert_list_size, unsigned int flags, unsigned int * verify, gnutls_verify_output_function func</var>)<var><a name="index-gnutls_005fx509_005ftrust_005flist_005fverify_005fcrt-508"></a></var><br>
<blockquote><p><var>list</var>: The structure of the list

     <p><var>cert_list</var>: is the certificate list to be verified

     <p><var>cert_list_size</var>: is the certificate list size

     <p><var>flags</var>: Flags that may be used to change the verification algorithm. Use OR of the gnutls_certificate_verify_flags enumerations.

     <p><var>verify</var>: will hold the certificate verification output.

     <p><var>func</var>: If non-null will be called on each chain element verification with the output.

     <p><strong> Description:</strong> This function will try to verify the given certificate and return
its status.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_trust_list_verify_named_crt</h4>

<p><a name="gnutls_005fx509_005ftrust_005flist_005fverify_005fnamed_005fcrt"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_trust_list_verify_named_crt</b> (<var>gnutls_x509_trust_list_t list, gnutls_x509_crt_t cert, const void * name, size_t name_size, unsigned int flags, unsigned int * verify, gnutls_verify_output_function func</var>)<var><a name="index-gnutls_005fx509_005ftrust_005flist_005fverify_005fnamed_005fcrt-509"></a></var><br>
<blockquote><p><var>list</var>: The structure of the list

     <p><var>cert</var>: is the certificate to be verified

     <p><var>name</var>: is the certificate's name

     <p><var>name_size</var>: is the certificate's name size

     <p><var>flags</var>: Flags that may be used to change the verification algorithm. Use OR of the gnutls_certificate_verify_flags enumerations.

     <p><var>verify</var>: will hold the certificate verification output.

     <p><var>func</var>: If non-null will be called on each chain element verification with the output.

     <p><strong> Description:</strong> This function will try to find a matching named certificate. If a
match is found the certificate is considered valid. In addition to that
this function will also check CRLs.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<div class="node">
<a name="OpenPGP-API"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#PKCS-12-API">PKCS 12 API</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#X509-certificate-API">X509 certificate API</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#API-reference">API reference</a>

</div>

<h3 class="section">C.4 <acronym>OpenPGP</acronym> API</h3>

<p><a name="index-OpenPGP-API-510"></a>
The following functions are to be used for <acronym>OpenPGP</acronym>
certificate handling.  Their prototypes lie in
<samp><span class="file">gnutls/openpgp.h</span></samp>.

<h4 class="subheading">gnutls_certificate_set_openpgp_key</h4>

<p><a name="gnutls_005fcertificate_005fset_005fopenpgp_005fkey"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_certificate_set_openpgp_key</b> (<var>gnutls_certificate_credentials_t res, gnutls_openpgp_crt_t crt, gnutls_openpgp_privkey_t pkey</var>)<var><a name="index-gnutls_005fcertificate_005fset_005fopenpgp_005fkey-511"></a></var><br>
<blockquote><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code> structure.

     <p><var>crt</var>: contains an openpgp public key

     <p><var>pkey</var>: is an openpgp private key

     <p><strong> Description:</strong> This function sets a certificate/private key pair in the
gnutls_certificate_credentials_t structure.  This function may be
called more than once (in case multiple keys/certificates exist
for the server).

     <p>Note that this function requires that the preferred key ids have
been set and be used. See <code>gnutls_openpgp_crt_set_preferred_key_id()</code>. 
Otherwise the master key will be used.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned,
otherwise a negative error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_set_openpgp_key_file</h4>

<p><a name="gnutls_005fcertificate_005fset_005fopenpgp_005fkey_005ffile"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_certificate_set_openpgp_key_file</b> (<var>gnutls_certificate_credentials_t res, const char * certfile, const char * keyfile, gnutls_openpgp_crt_fmt_t format</var>)<var><a name="index-gnutls_005fcertificate_005fset_005fopenpgp_005fkey_005ffile-512"></a></var><br>
<blockquote><p><var>res</var>: the destination context to save the data.

     <p><var>certfile</var>: the file that contains the public key.

     <p><var>keyfile</var>: the file that contains the secret key.

     <p><var>format</var>: the format of the keys

     <p><strong> Description:</strong> This funtion is used to load OpenPGP keys into the GnuTLS
credentials structure. The file should contain at least one valid non encrypted subkey.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_set_openpgp_key_file2</h4>

<p><a name="gnutls_005fcertificate_005fset_005fopenpgp_005fkey_005ffile2"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_certificate_set_openpgp_key_file2</b> (<var>gnutls_certificate_credentials_t res, const char * certfile, const char * keyfile, const char * subkey_id, gnutls_openpgp_crt_fmt_t format</var>)<var><a name="index-gnutls_005fcertificate_005fset_005fopenpgp_005fkey_005ffile2-513"></a></var><br>
<blockquote><p><var>res</var>: the destination context to save the data.

     <p><var>certfile</var>: the file that contains the public key.

     <p><var>keyfile</var>: the file that contains the secret key.

     <p><var>subkey_id</var>: a hex encoded subkey id

     <p><var>format</var>: the format of the keys

     <p><strong> Description:</strong> This funtion is used to load OpenPGP keys into the GnuTLS credential
structure. The file should contain at least one valid non encrypted subkey.

     <p>The special keyword "auto" is also accepted as  <code>subkey_id</code>.  In that
case the <code>gnutls_openpgp_crt_get_auth_subkey()</code> will be used to
retrieve the subkey.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_set_openpgp_key_mem</h4>

<p><a name="gnutls_005fcertificate_005fset_005fopenpgp_005fkey_005fmem"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_certificate_set_openpgp_key_mem</b> (<var>gnutls_certificate_credentials_t res, const gnutls_datum_t * cert, const gnutls_datum_t * key, gnutls_openpgp_crt_fmt_t format</var>)<var><a name="index-gnutls_005fcertificate_005fset_005fopenpgp_005fkey_005fmem-514"></a></var><br>
<blockquote><p><var>res</var>: the destination context to save the data.

     <p><var>cert</var>: the datum that contains the public key.

     <p><var>key</var>: the datum that contains the secret key.

     <p><var>format</var>: the format of the keys

     <p><strong> Description:</strong> This funtion is used to load OpenPGP keys into the GnuTLS credential
structure. The datum should contain at least one valid non encrypted subkey.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_set_openpgp_key_mem2</h4>

<p><a name="gnutls_005fcertificate_005fset_005fopenpgp_005fkey_005fmem2"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_certificate_set_openpgp_key_mem2</b> (<var>gnutls_certificate_credentials_t res, const gnutls_datum_t * cert, const gnutls_datum_t * key, const char * subkey_id, gnutls_openpgp_crt_fmt_t format</var>)<var><a name="index-gnutls_005fcertificate_005fset_005fopenpgp_005fkey_005fmem2-515"></a></var><br>
<blockquote><p><var>res</var>: the destination context to save the data.

     <p><var>cert</var>: the datum that contains the public key.

     <p><var>key</var>: the datum that contains the secret key.

     <p><var>subkey_id</var>: a hex encoded subkey id

     <p><var>format</var>: the format of the keys

     <p><strong> Description:</strong> This funtion is used to load OpenPGP keys into the GnuTLS
credentials structure. The datum should contain at least one valid non encrypted subkey.

     <p>The special keyword "auto" is also accepted as  <code>subkey_id</code>.  In that
case the <code>gnutls_openpgp_crt_get_auth_subkey()</code> will be used to
retrieve the subkey.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_set_openpgp_keyring_file</h4>

<p><a name="gnutls_005fcertificate_005fset_005fopenpgp_005fkeyring_005ffile"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_certificate_set_openpgp_keyring_file</b> (<var>gnutls_certificate_credentials_t c, const char * file, gnutls_openpgp_crt_fmt_t format</var>)<var><a name="index-gnutls_005fcertificate_005fset_005fopenpgp_005fkeyring_005ffile-516"></a></var><br>
<blockquote><p><var>c</var>: A certificate credentials structure

     <p><var>file</var>: filename of the keyring.

     <p><var>format</var>: format of keyring.

     <p><strong> Description:</strong> The function is used to set keyrings that will be used internally
by various OpenPGP functions. For example to find a key when it
is needed for an operations. The keyring will also be used at the
verification functions.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_set_openpgp_keyring_mem</h4>

<p><a name="gnutls_005fcertificate_005fset_005fopenpgp_005fkeyring_005fmem"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_certificate_set_openpgp_keyring_mem</b> (<var>gnutls_certificate_credentials_t c, const opaque * data, size_t dlen, gnutls_openpgp_crt_fmt_t format</var>)<var><a name="index-gnutls_005fcertificate_005fset_005fopenpgp_005fkeyring_005fmem-517"></a></var><br>
<blockquote><p><var>c</var>: A certificate credentials structure

     <p><var>data</var>: buffer with keyring data.

     <p><var>dlen</var>: length of data buffer.

     <p><var>format</var>: the format of the keyring

     <p><strong> Description:</strong> The function is used to set keyrings that will be used internally
by various OpenPGP functions. For example to find a key when it
is needed for an operations. The keyring will also be used at the
verification functions.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_check_hostname</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fcheck_005fhostname"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_check_hostname</b> (<var>gnutls_openpgp_crt_t key, const char * hostname</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fcheck_005fhostname-518"></a></var><br>
<blockquote><p><var>key</var>: should contain a <code>gnutls_openpgp_crt_t</code> structure

     <p><var>hostname</var>: A null terminated string that contains a DNS name

     <p><strong> Description:</strong> This function will check if the given key's owner matches the
given hostname. This is a basic implementation of the matching
described in RFC2818 (HTTPS), which takes into account wildcards.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_deinit</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_openpgp_crt_deinit</b> (<var>gnutls_openpgp_crt_t key</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fdeinit-519"></a></var><br>
<blockquote><p><var>key</var>: The structure to be initialized

     <p><strong> Description:</strong> This function will deinitialize a key structure. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_export</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fexport"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_export</b> (<var>gnutls_openpgp_crt_t key, gnutls_openpgp_crt_fmt_t format, void * output_data, size_t * output_data_size</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fexport-520"></a></var><br>
<blockquote><p><var>key</var>: Holds the key.

     <p><var>format</var>: One of gnutls_openpgp_crt_fmt_t elements.

     <p><var>output_data</var>: will contain the key base64 encoded or raw

     <p><var>output_data_size</var>: holds the size of output_data (and will
be replaced by the actual size of parameters)

     <p><strong> Description:</strong> This function will convert the given key to RAW or Base64 format. 
If the buffer provided is not long enough to hold the output, then
<code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> will be returned.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_get_auth_subkey</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fget_005fauth_005fsubkey"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_get_auth_subkey</b> (<var>gnutls_openpgp_crt_t crt, gnutls_openpgp_keyid_t keyid, unsigned int flag</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fget_005fauth_005fsubkey-521"></a></var><br>
<blockquote><p><var>crt</var>: the structure that contains the OpenPGP public key.

     <p><var>keyid</var>: the struct to save the keyid.

     <p><var>flag</var>: Non (0) indicates that a valid subkey is always returned.

     <p><strong> Description:</strong> Returns the 64-bit keyID of the first valid OpenPGP subkey marked
for authentication.  If flag is non (0) and no authentication
subkey exists, then a valid subkey will be returned even if it is
not marked for authentication. 
Returns the 64-bit keyID of the first valid OpenPGP subkey marked
for authentication.  If flag is non (0) and no authentication
subkey exists, then a valid subkey will be returned even if it is
not marked for authentication.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_get_creation_time</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fget_005fcreation_005ftime"></a>

<div class="defun">
&mdash; Function: time_t <b>gnutls_openpgp_crt_get_creation_time</b> (<var>gnutls_openpgp_crt_t key</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fget_005fcreation_005ftime-522"></a></var><br>
<blockquote><p><var>key</var>: the structure that contains the OpenPGP public key.

     <p><strong> Description:</strong> Get key creation time.

     <p><strong> Returns:</strong> the timestamp when the OpenPGP key was created. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_get_expiration_time</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fget_005fexpiration_005ftime"></a>

<div class="defun">
&mdash; Function: time_t <b>gnutls_openpgp_crt_get_expiration_time</b> (<var>gnutls_openpgp_crt_t key</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fget_005fexpiration_005ftime-523"></a></var><br>
<blockquote><p><var>key</var>: the structure that contains the OpenPGP public key.

     <p><strong> Description:</strong> Get key expiration time.  A value of '0' means that the key doesn't
expire at all.

     <p><strong> Returns:</strong> the time when the OpenPGP key expires. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_get_fingerprint</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fget_005ffingerprint"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_get_fingerprint</b> (<var>gnutls_openpgp_crt_t key, void * fpr, size_t * fprlen</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fget_005ffingerprint-524"></a></var><br>
<blockquote><p><var>key</var>: the raw data that contains the OpenPGP public key.

     <p><var>fpr</var>: the buffer to save the fingerprint, must hold at least 20 bytes.

     <p><var>fprlen</var>: the integer to save the length of the fingerprint.

     <p><strong> Description:</strong> Get key fingerprint.  Depending on the algorithm, the fingerprint
can be 16 or 20 bytes.

     <p><strong> Returns:</strong> On success, 0 is returned.  Otherwise, an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_get_key_id</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fget_005fkey_005fid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_get_key_id</b> (<var>gnutls_openpgp_crt_t key, gnutls_openpgp_keyid_t keyid</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fget_005fkey_005fid-525"></a></var><br>
<blockquote><p><var>key</var>: the structure that contains the OpenPGP public key.

     <p><var>keyid</var>: the buffer to save the keyid.

     <p><strong> Description:</strong> Get key id string.

     <p><strong> Returns:</strong> the 64-bit keyID of the OpenPGP key.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_get_key_usage</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fget_005fkey_005fusage"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_get_key_usage</b> (<var>gnutls_openpgp_crt_t key, unsigned int * key_usage</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fget_005fkey_005fusage-526"></a></var><br>
<blockquote><p><var>key</var>: should contain a gnutls_openpgp_crt_t structure

     <p><var>key_usage</var>: where the key usage bits will be stored

     <p><strong> Description:</strong> This function will return certificate's key usage, by checking the
key algorithm. The key usage value will ORed values of the:
<code>GNUTLS_KEY_DIGITAL_SIGNATURE</code>, <code>GNUTLS_KEY_KEY_ENCIPHERMENT</code>.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_get_name</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fget_005fname"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_get_name</b> (<var>gnutls_openpgp_crt_t key, int idx, char * buf, size_t * sizeof_buf</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fget_005fname-527"></a></var><br>
<blockquote><p><var>key</var>: the structure that contains the OpenPGP public key.

     <p><var>idx</var>: the index of the ID to extract

     <p><var>buf</var>: a pointer to a structure to hold the name, may be <code>NULL</code>
to only get the  <code>sizeof_buf</code>.

     <p><var>sizeof_buf</var>: holds the maximum size of  <code>buf</code>, on return hold the
actual/required size of  <code>buf</code>.

     <p><strong> Description:</strong> Extracts the userID from the parsed OpenPGP key.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, and if the index of the ID
does not exist <code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code>, or an
error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_get_pk_algorithm</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fget_005fpk_005falgorithm"></a>

<div class="defun">
&mdash; Function: gnutls_pk_algorithm_t <b>gnutls_openpgp_crt_get_pk_algorithm</b> (<var>gnutls_openpgp_crt_t key, unsigned int * bits</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fget_005fpk_005falgorithm-528"></a></var><br>
<blockquote><p><var>key</var>: is an OpenPGP key

     <p><var>bits</var>: if bits is non null it will hold the size of the parameters' in bits

     <p><strong> Description:</strong> This function will return the public key algorithm of an OpenPGP
certificate.

     <p>If bits is non null, it should have enough size to hold the parameters
size in bits. For RSA the bits returned is the modulus. 
For DSA the bits returned are of the public exponent.

     <p><strong> Returns:</strong> a member of the <code>gnutls_pk_algorithm_t</code> enumeration on
success, or GNUTLS_PK_UNKNOWN on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_get_pk_dsa_raw</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fget_005fpk_005fdsa_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_get_pk_dsa_raw</b> (<var>gnutls_openpgp_crt_t crt, gnutls_datum_t * p, gnutls_datum_t * q, gnutls_datum_t * g, gnutls_datum_t * y</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fget_005fpk_005fdsa_005fraw-529"></a></var><br>
<blockquote><p><var>crt</var>: Holds the certificate

     <p><var>p</var>: will hold the p

     <p><var>q</var>: will hold the q

     <p><var>g</var>: will hold the g

     <p><var>y</var>: will hold the y

     <p><strong> Description:</strong> This function will export the DSA public key's parameters found in
the given certificate.  The new parameters will be allocated using
<code>gnutls_malloc()</code> and will be stored in the appropriate datum.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, otherwise a negative error code.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_get_pk_rsa_raw</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fget_005fpk_005frsa_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_get_pk_rsa_raw</b> (<var>gnutls_openpgp_crt_t crt, gnutls_datum_t * m, gnutls_datum_t * e</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fget_005fpk_005frsa_005fraw-530"></a></var><br>
<blockquote><p><var>crt</var>: Holds the certificate

     <p><var>m</var>: will hold the modulus

     <p><var>e</var>: will hold the public exponent

     <p><strong> Description:</strong> This function will export the RSA public key's parameters found in
the given structure.  The new parameters will be allocated using
<code>gnutls_malloc()</code> and will be stored in the appropriate datum.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, otherwise a negative error code.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_get_preferred_key_id</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fget_005fpreferred_005fkey_005fid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_get_preferred_key_id</b> (<var>gnutls_openpgp_crt_t key, gnutls_openpgp_keyid_t keyid</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fget_005fpreferred_005fkey_005fid-531"></a></var><br>
<blockquote><p><var>key</var>: the structure that contains the OpenPGP public key.

     <p><var>keyid</var>: the struct to save the keyid.

     <p><strong> Description:</strong> Get preferred key id.  If it hasn't been set it returns
<code>GNUTLS_E_INVALID_REQUEST</code>.

     <p><strong> Returns:</strong> the 64-bit preferred keyID of the OpenPGP key. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_get_revoked_status</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fget_005frevoked_005fstatus"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_get_revoked_status</b> (<var>gnutls_openpgp_crt_t key</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fget_005frevoked_005fstatus-532"></a></var><br>
<blockquote><p><var>key</var>: the structure that contains the OpenPGP public key.

     <p><strong> Description:</strong> Get revocation status of key.

     <p><strong> Returns:</strong> true (1) if the key has been revoked, or false (0) if it
has not.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_get_subkey_count</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fcount"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_get_subkey_count</b> (<var>gnutls_openpgp_crt_t key</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fcount-533"></a></var><br>
<blockquote><p><var>key</var>: is an OpenPGP key

     <p><strong> Description:</strong> This function will return the number of subkeys present in the
given OpenPGP certificate.

     <p><strong> Returns:</strong> the number of subkeys, or a negative error code on error.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_get_subkey_creation_time</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fcreation_005ftime"></a>

<div class="defun">
&mdash; Function: time_t <b>gnutls_openpgp_crt_get_subkey_creation_time</b> (<var>gnutls_openpgp_crt_t key, unsigned int idx</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fcreation_005ftime-534"></a></var><br>
<blockquote><p><var>key</var>: the structure that contains the OpenPGP public key.

     <p><var>idx</var>: the subkey index

     <p><strong> Description:</strong> Get subkey creation time.

     <p><strong> Returns:</strong> the timestamp when the OpenPGP sub-key was created.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_get_subkey_expiration_time</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fexpiration_005ftime"></a>

<div class="defun">
&mdash; Function: time_t <b>gnutls_openpgp_crt_get_subkey_expiration_time</b> (<var>gnutls_openpgp_crt_t key, unsigned int idx</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fexpiration_005ftime-535"></a></var><br>
<blockquote><p><var>key</var>: the structure that contains the OpenPGP public key.

     <p><var>idx</var>: the subkey index

     <p><strong> Description:</strong> Get subkey expiration time.  A value of '0' means that the key
doesn't expire at all.

     <p><strong> Returns:</strong> the time when the OpenPGP key expires.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_get_subkey_fingerprint</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005ffingerprint"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_get_subkey_fingerprint</b> (<var>gnutls_openpgp_crt_t key, unsigned int idx, void * fpr, size_t * fprlen</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005ffingerprint-536"></a></var><br>
<blockquote><p><var>key</var>: the raw data that contains the OpenPGP public key.

     <p><var>idx</var>: the subkey index

     <p><var>fpr</var>: the buffer to save the fingerprint, must hold at least 20 bytes.

     <p><var>fprlen</var>: the integer to save the length of the fingerprint.

     <p><strong> Description:</strong> Get key fingerprint of a subkey.  Depending on the algorithm, the
fingerprint can be 16 or 20 bytes.

     <p><strong> Returns:</strong> On success, 0 is returned.  Otherwise, an error code.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_get_subkey_id</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_get_subkey_id</b> (<var>gnutls_openpgp_crt_t key, unsigned int idx, gnutls_openpgp_keyid_t keyid</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fid-537"></a></var><br>
<blockquote><p><var>key</var>: the structure that contains the OpenPGP public key.

     <p><var>idx</var>: the subkey index

     <p><var>keyid</var>: the buffer to save the keyid.

     <p><strong> Description:</strong> Get the subkey's key-id.

     <p><strong> Returns:</strong> the 64-bit keyID of the OpenPGP key. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_get_subkey_idx</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fidx"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_get_subkey_idx</b> (<var>gnutls_openpgp_crt_t key, const gnutls_openpgp_keyid_t keyid</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fidx-538"></a></var><br>
<blockquote><p><var>key</var>: the structure that contains the OpenPGP public key.

     <p><var>keyid</var>: the keyid.

     <p><strong> Description:</strong> Get subkey's index.

     <p><strong> Returns:</strong> the index of the subkey or a negative error value.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_get_subkey_pk_algorithm</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fpk_005falgorithm"></a>

<div class="defun">
&mdash; Function: gnutls_pk_algorithm_t <b>gnutls_openpgp_crt_get_subkey_pk_algorithm</b> (<var>gnutls_openpgp_crt_t key, unsigned int idx, unsigned int * bits</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fpk_005falgorithm-539"></a></var><br>
<blockquote><p><var>key</var>: is an OpenPGP key

     <p><var>idx</var>: is the subkey index

     <p><var>bits</var>: if bits is non null it will hold the size of the parameters' in bits

     <p><strong> Description:</strong> This function will return the public key algorithm of a subkey of an OpenPGP
certificate.

     <p>If bits is non null, it should have enough size to hold the
parameters size in bits.  For RSA the bits returned is the modulus. 
For DSA the bits returned are of the public exponent.

     <p><strong> Returns:</strong> a member of the <code>gnutls_pk_algorithm_t</code> enumeration on
success, or GNUTLS_PK_UNKNOWN on error.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_get_subkey_pk_dsa_raw</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fpk_005fdsa_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_get_subkey_pk_dsa_raw</b> (<var>gnutls_openpgp_crt_t crt, unsigned int idx, gnutls_datum_t * p, gnutls_datum_t * q, gnutls_datum_t * g, gnutls_datum_t * y</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fpk_005fdsa_005fraw-540"></a></var><br>
<blockquote><p><var>crt</var>: Holds the certificate

     <p><var>idx</var>: Is the subkey index

     <p><var>p</var>: will hold the p

     <p><var>q</var>: will hold the q

     <p><var>g</var>: will hold the g

     <p><var>y</var>: will hold the y

     <p><strong> Description:</strong> This function will export the DSA public key's parameters found in
the given certificate.  The new parameters will be allocated using
<code>gnutls_malloc()</code> and will be stored in the appropriate datum.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, otherwise a negative error code.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_get_subkey_pk_rsa_raw</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fpk_005frsa_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_get_subkey_pk_rsa_raw</b> (<var>gnutls_openpgp_crt_t crt, unsigned int idx, gnutls_datum_t * m, gnutls_datum_t * e</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fpk_005frsa_005fraw-541"></a></var><br>
<blockquote><p><var>crt</var>: Holds the certificate

     <p><var>idx</var>: Is the subkey index

     <p><var>m</var>: will hold the modulus

     <p><var>e</var>: will hold the public exponent

     <p><strong> Description:</strong> This function will export the RSA public key's parameters found in
the given structure.  The new parameters will be allocated using
<code>gnutls_malloc()</code> and will be stored in the appropriate datum.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, otherwise a negative error code.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_get_subkey_revoked_status</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005frevoked_005fstatus"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_get_subkey_revoked_status</b> (<var>gnutls_openpgp_crt_t key, unsigned int idx</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005frevoked_005fstatus-542"></a></var><br>
<blockquote><p><var>key</var>: the structure that contains the OpenPGP public key.

     <p><var>idx</var>: is the subkey index

     <p><strong> Description:</strong> Get subkey revocation status.  A negative error code indicates an error.

     <p><strong> Returns:</strong> true (1) if the key has been revoked, or false (0) if it
has not.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_get_subkey_usage</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fusage"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_get_subkey_usage</b> (<var>gnutls_openpgp_crt_t key, unsigned int idx, unsigned int * key_usage</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fusage-543"></a></var><br>
<blockquote><p><var>key</var>: should contain a gnutls_openpgp_crt_t structure

     <p><var>idx</var>: the subkey index

     <p><var>key_usage</var>: where the key usage bits will be stored

     <p><strong> Description:</strong> This function will return certificate's key usage, by checking the
key algorithm.  The key usage value will ORed values of
<code>GNUTLS_KEY_DIGITAL_SIGNATURE</code> or <code>GNUTLS_KEY_KEY_ENCIPHERMENT</code>.

     <p>A negative error code may be returned in case of parsing error.

     <p><strong> Returns:</strong> key usage value.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_get_version</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fget_005fversion"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_get_version</b> (<var>gnutls_openpgp_crt_t key</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fget_005fversion-544"></a></var><br>
<blockquote><p><var>key</var>: the structure that contains the OpenPGP public key.

     <p><strong> Description:</strong> Extract the version of the OpenPGP key.

     <p><strong> Returns:</strong> the version number is returned, or a negative error code on errors. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_import</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fimport"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_import</b> (<var>gnutls_openpgp_crt_t key, const gnutls_datum_t * data, gnutls_openpgp_crt_fmt_t format</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fimport-545"></a></var><br>
<blockquote><p><var>key</var>: The structure to store the parsed key.

     <p><var>data</var>: The RAW or BASE64 encoded key.

     <p><var>format</var>: One of gnutls_openpgp_crt_fmt_t elements.

     <p><strong> Description:</strong> This function will convert the given RAW or Base64 encoded key to
the native <code>gnutls_openpgp_crt_t</code> format. The output will be stored
in 'key'.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_init</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_init</b> (<var>gnutls_openpgp_crt_t * key</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005finit-546"></a></var><br>
<blockquote><p><var>key</var>: The structure to be initialized

     <p><strong> Description:</strong> This function will initialize an OpenPGP key structure.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_print</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fprint"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_print</b> (<var>gnutls_openpgp_crt_t cert, gnutls_certificate_print_formats_t format, gnutls_datum_t * out</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fprint-547"></a></var><br>
<blockquote><p><var>cert</var>: The structure to be printed

     <p><var>format</var>: Indicate the format to use

     <p><var>out</var>: Newly allocated datum with (0) terminated string.

     <p><strong> Description:</strong> This function will pretty print an OpenPGP certificate, suitable
for display to a human.

     <p>The format should be (0) for future compatibility.

     <p>The output  <code>out</code>needs to be deallocate using <code>gnutls_free()</code>.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_set_preferred_key_id</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fset_005fpreferred_005fkey_005fid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_set_preferred_key_id</b> (<var>gnutls_openpgp_crt_t key, const gnutls_openpgp_keyid_t keyid</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fset_005fpreferred_005fkey_005fid-548"></a></var><br>
<blockquote><p><var>key</var>: the structure that contains the OpenPGP public key.

     <p><var>keyid</var>: the selected keyid

     <p><strong> Description:</strong> This allows setting a preferred key id for the given certificate. 
This key will be used by functions that involve key handling.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned,
otherwise a negative error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_verify_ring</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fverify_005fring"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_verify_ring</b> (<var>gnutls_openpgp_crt_t key, gnutls_openpgp_keyring_t keyring, unsigned int flags, unsigned int * verify</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fverify_005fring-549"></a></var><br>
<blockquote><p><var>key</var>: the structure that holds the key.

     <p><var>keyring</var>: holds the keyring to check against

     <p><var>flags</var>: unused (should be 0)

     <p><var>verify</var>: will hold the certificate verification output.

     <p><strong> Description:</strong> Verify all signatures in the key, using the given set of keys
(keyring).

     <p>The key verification output will be put in  <code>verify</code>and will be one
or more of the <code>gnutls_certificate_status_t</code> enumerated elements
bitwise or'd.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_crt_verify_self</h4>

<p><a name="gnutls_005fopenpgp_005fcrt_005fverify_005fself"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_crt_verify_self</b> (<var>gnutls_openpgp_crt_t key, unsigned int flags, unsigned int * verify</var>)<var><a name="index-gnutls_005fopenpgp_005fcrt_005fverify_005fself-550"></a></var><br>
<blockquote><p><var>key</var>: the structure that holds the key.

     <p><var>flags</var>: unused (should be 0)

     <p><var>verify</var>: will hold the key verification output.

     <p><strong> Description:</strong> Verifies the self signature in the key.  The key verification
output will be put in  <code>verify</code>and will be one or more of the
gnutls_certificate_status_t enumerated elements bitwise or'd.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_keyring_check_id</h4>

<p><a name="gnutls_005fopenpgp_005fkeyring_005fcheck_005fid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_keyring_check_id</b> (<var>gnutls_openpgp_keyring_t ring, const gnutls_openpgp_keyid_t keyid, unsigned int flags</var>)<var><a name="index-gnutls_005fopenpgp_005fkeyring_005fcheck_005fid-551"></a></var><br>
<blockquote><p><var>ring</var>: holds the keyring to check against

     <p><var>keyid</var>: will hold the keyid to check for.

     <p><var>flags</var>: unused (should be 0)

     <p><strong> Description:</strong> Check if a given key ID exists in the keyring.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success (if keyid exists) and a
negative error code on failure. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_keyring_deinit</h4>

<p><a name="gnutls_005fopenpgp_005fkeyring_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_openpgp_keyring_deinit</b> (<var>gnutls_openpgp_keyring_t keyring</var>)<var><a name="index-gnutls_005fopenpgp_005fkeyring_005fdeinit-552"></a></var><br>
<blockquote><p><var>keyring</var>: The structure to be initialized

     <p><strong> Description:</strong> This function will deinitialize a keyring structure. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_keyring_get_crt</h4>

<p><a name="gnutls_005fopenpgp_005fkeyring_005fget_005fcrt"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_keyring_get_crt</b> (<var>gnutls_openpgp_keyring_t ring, unsigned int idx, gnutls_openpgp_crt_t * cert</var>)<var><a name="index-gnutls_005fopenpgp_005fkeyring_005fget_005fcrt-553"></a></var><br>
<blockquote><p><var>ring</var>: Holds the keyring.

     <p><var>idx</var>: the index of the certificate to export

     <p><var>cert</var>: An uninitialized <code>gnutls_openpgp_crt_t</code> structure

     <p><strong> Description:</strong> This function will extract an OpenPGP certificate from the given
keyring.  If the index given is out of range
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> will be returned. The
returned structure needs to be deinited.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_keyring_get_crt_count</h4>

<p><a name="gnutls_005fopenpgp_005fkeyring_005fget_005fcrt_005fcount"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_keyring_get_crt_count</b> (<var>gnutls_openpgp_keyring_t ring</var>)<var><a name="index-gnutls_005fopenpgp_005fkeyring_005fget_005fcrt_005fcount-554"></a></var><br>
<blockquote><p><var>ring</var>: is an OpenPGP key ring

     <p><strong> Description:</strong> This function will return the number of OpenPGP certificates
present in the given keyring.

     <p><strong> Returns:</strong> the number of subkeys, or a negative error code on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_keyring_import</h4>

<p><a name="gnutls_005fopenpgp_005fkeyring_005fimport"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_keyring_import</b> (<var>gnutls_openpgp_keyring_t keyring, const gnutls_datum_t * data, gnutls_openpgp_crt_fmt_t format</var>)<var><a name="index-gnutls_005fopenpgp_005fkeyring_005fimport-555"></a></var><br>
<blockquote><p><var>keyring</var>: The structure to store the parsed key.

     <p><var>data</var>: The RAW or BASE64 encoded keyring.

     <p><var>format</var>: One of <code>gnutls_openpgp_keyring_fmt</code> elements.

     <p><strong> Description:</strong> This function will convert the given RAW or Base64 encoded keyring
to the native <code>gnutls_openpgp_keyring_t</code> format.  The output will be
stored in 'keyring'.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_keyring_init</h4>

<p><a name="gnutls_005fopenpgp_005fkeyring_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_keyring_init</b> (<var>gnutls_openpgp_keyring_t * keyring</var>)<var><a name="index-gnutls_005fopenpgp_005fkeyring_005finit-556"></a></var><br>
<blockquote><p><var>keyring</var>: The structure to be initialized

     <p><strong> Description:</strong> This function will initialize an keyring structure.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_privkey_deinit</h4>

<p><a name="gnutls_005fopenpgp_005fprivkey_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_openpgp_privkey_deinit</b> (<var>gnutls_openpgp_privkey_t key</var>)<var><a name="index-gnutls_005fopenpgp_005fprivkey_005fdeinit-557"></a></var><br>
<blockquote><p><var>key</var>: The structure to be initialized

     <p><strong> Description:</strong> This function will deinitialize a key structure. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_privkey_export</h4>

<p><a name="gnutls_005fopenpgp_005fprivkey_005fexport"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_privkey_export</b> (<var>gnutls_openpgp_privkey_t key, gnutls_openpgp_crt_fmt_t format, const char * password, unsigned int flags, void * output_data, size_t * output_data_size</var>)<var><a name="index-gnutls_005fopenpgp_005fprivkey_005fexport-558"></a></var><br>
<blockquote><p><var>key</var>: Holds the key.

     <p><var>format</var>: One of gnutls_openpgp_crt_fmt_t elements.

     <p><var>password</var>: the password that will be used to encrypt the key. (unused for now)

     <p><var>flags</var>: (0) for future compatibility

     <p><var>output_data</var>: will contain the key base64 encoded or raw

     <p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)

     <p><strong> Description:</strong> This function will convert the given key to RAW or Base64 format. 
If the buffer provided is not long enough to hold the output, then
GNUTLS_E_SHORT_MEMORY_BUFFER will be returned.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_privkey_export_dsa_raw</h4>

<p><a name="gnutls_005fopenpgp_005fprivkey_005fexport_005fdsa_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_privkey_export_dsa_raw</b> (<var>gnutls_openpgp_privkey_t pkey, gnutls_datum_t * p, gnutls_datum_t * q, gnutls_datum_t * g, gnutls_datum_t * y, gnutls_datum_t * x</var>)<var><a name="index-gnutls_005fopenpgp_005fprivkey_005fexport_005fdsa_005fraw-559"></a></var><br>
<blockquote><p><var>pkey</var>: Holds the certificate

     <p><var>p</var>: will hold the p

     <p><var>q</var>: will hold the q

     <p><var>g</var>: will hold the g

     <p><var>y</var>: will hold the y

     <p><var>x</var>: will hold the x

     <p><strong> Description:</strong> This function will export the DSA private key's parameters found in
the given certificate.  The new parameters will be allocated using
<code>gnutls_malloc()</code> and will be stored in the appropriate datum.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, otherwise a negative error code.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_privkey_export_rsa_raw</h4>

<p><a name="gnutls_005fopenpgp_005fprivkey_005fexport_005frsa_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_privkey_export_rsa_raw</b> (<var>gnutls_openpgp_privkey_t pkey, gnutls_datum_t * m, gnutls_datum_t * e, gnutls_datum_t * d, gnutls_datum_t * p, gnutls_datum_t * q, gnutls_datum_t * u</var>)<var><a name="index-gnutls_005fopenpgp_005fprivkey_005fexport_005frsa_005fraw-560"></a></var><br>
<blockquote><p><var>pkey</var>: Holds the certificate

     <p><var>m</var>: will hold the modulus

     <p><var>e</var>: will hold the public exponent

     <p><var>d</var>: will hold the private exponent

     <p><var>p</var>: will hold the first prime (p)

     <p><var>q</var>: will hold the second prime (q)

     <p><var>u</var>: will hold the coefficient

     <p><strong> Description:</strong> This function will export the RSA private key's parameters found in
the given structure.  The new parameters will be allocated using
<code>gnutls_malloc()</code> and will be stored in the appropriate datum.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, otherwise a negative error code.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_privkey_export_subkey_dsa_raw</h4>

<p><a name="gnutls_005fopenpgp_005fprivkey_005fexport_005fsubkey_005fdsa_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_privkey_export_subkey_dsa_raw</b> (<var>gnutls_openpgp_privkey_t pkey, unsigned int idx, gnutls_datum_t * p, gnutls_datum_t * q, gnutls_datum_t * g, gnutls_datum_t * y, gnutls_datum_t * x</var>)<var><a name="index-gnutls_005fopenpgp_005fprivkey_005fexport_005fsubkey_005fdsa_005fraw-561"></a></var><br>
<blockquote><p><var>pkey</var>: Holds the certificate

     <p><var>idx</var>: Is the subkey index

     <p><var>p</var>: will hold the p

     <p><var>q</var>: will hold the q

     <p><var>g</var>: will hold the g

     <p><var>y</var>: will hold the y

     <p><var>x</var>: will hold the x

     <p><strong> Description:</strong> This function will export the DSA private key's parameters found
in the given certificate.  The new parameters will be allocated
using <code>gnutls_malloc()</code> and will be stored in the appropriate datum.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, otherwise a negative error code.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_privkey_export_subkey_rsa_raw</h4>

<p><a name="gnutls_005fopenpgp_005fprivkey_005fexport_005fsubkey_005frsa_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_privkey_export_subkey_rsa_raw</b> (<var>gnutls_openpgp_privkey_t pkey, unsigned int idx, gnutls_datum_t * m, gnutls_datum_t * e, gnutls_datum_t * d, gnutls_datum_t * p, gnutls_datum_t * q, gnutls_datum_t * u</var>)<var><a name="index-gnutls_005fopenpgp_005fprivkey_005fexport_005fsubkey_005frsa_005fraw-562"></a></var><br>
<blockquote><p><var>pkey</var>: Holds the certificate

     <p><var>idx</var>: Is the subkey index

     <p><var>m</var>: will hold the modulus

     <p><var>e</var>: will hold the public exponent

     <p><var>d</var>: will hold the private exponent

     <p><var>p</var>: will hold the first prime (p)

     <p><var>q</var>: will hold the second prime (q)

     <p><var>u</var>: will hold the coefficient

     <p><strong> Description:</strong> This function will export the RSA private key's parameters found in
the given structure.  The new parameters will be allocated using
<code>gnutls_malloc()</code> and will be stored in the appropriate datum.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, otherwise a negative error code.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_privkey_get_fingerprint</h4>

<p><a name="gnutls_005fopenpgp_005fprivkey_005fget_005ffingerprint"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_privkey_get_fingerprint</b> (<var>gnutls_openpgp_privkey_t key, void * fpr, size_t * fprlen</var>)<var><a name="index-gnutls_005fopenpgp_005fprivkey_005fget_005ffingerprint-563"></a></var><br>
<blockquote><p><var>key</var>: the raw data that contains the OpenPGP secret key.

     <p><var>fpr</var>: the buffer to save the fingerprint, must hold at least 20 bytes.

     <p><var>fprlen</var>: the integer to save the length of the fingerprint.

     <p><strong> Description:</strong> Get the fingerprint of the OpenPGP key. Depends on the
algorithm, the fingerprint can be 16 or 20 bytes.

     <p><strong> Returns:</strong> On success, 0 is returned, or an error code.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_privkey_get_key_id</h4>

<p><a name="gnutls_005fopenpgp_005fprivkey_005fget_005fkey_005fid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_privkey_get_key_id</b> (<var>gnutls_openpgp_privkey_t key, gnutls_openpgp_keyid_t keyid</var>)<var><a name="index-gnutls_005fopenpgp_005fprivkey_005fget_005fkey_005fid-564"></a></var><br>
<blockquote><p><var>key</var>: the structure that contains the OpenPGP secret key.

     <p><var>keyid</var>: the buffer to save the keyid.

     <p><strong> Description:</strong> Get key-id.

     <p><strong> Returns:</strong> the 64-bit keyID of the OpenPGP key.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_privkey_get_pk_algorithm</h4>

<p><a name="gnutls_005fopenpgp_005fprivkey_005fget_005fpk_005falgorithm"></a>

<div class="defun">
&mdash; Function: gnutls_pk_algorithm_t <b>gnutls_openpgp_privkey_get_pk_algorithm</b> (<var>gnutls_openpgp_privkey_t key, unsigned int * bits</var>)<var><a name="index-gnutls_005fopenpgp_005fprivkey_005fget_005fpk_005falgorithm-565"></a></var><br>
<blockquote><p><var>key</var>: is an OpenPGP key

     <p><var>bits</var>: if bits is non null it will hold the size of the parameters' in bits

     <p><strong> Description:</strong> This function will return the public key algorithm of an OpenPGP
certificate.

     <p>If bits is non null, it should have enough size to hold the parameters
size in bits. For RSA the bits returned is the modulus. 
For DSA the bits returned are of the public exponent.

     <p><strong> Returns:</strong> a member of the <code>gnutls_pk_algorithm_t</code> enumeration on
success, or a negative error code on error.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_privkey_get_preferred_key_id</h4>

<p><a name="gnutls_005fopenpgp_005fprivkey_005fget_005fpreferred_005fkey_005fid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_privkey_get_preferred_key_id</b> (<var>gnutls_openpgp_privkey_t key, gnutls_openpgp_keyid_t keyid</var>)<var><a name="index-gnutls_005fopenpgp_005fprivkey_005fget_005fpreferred_005fkey_005fid-566"></a></var><br>
<blockquote><p><var>key</var>: the structure that contains the OpenPGP public key.

     <p><var>keyid</var>: the struct to save the keyid.

     <p><strong> Description:</strong> Get the preferred key-id for the key.

     <p><strong> Returns:</strong> the 64-bit preferred keyID of the OpenPGP key, or if it
hasn't been set it returns <code>GNUTLS_E_INVALID_REQUEST</code>. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_privkey_get_revoked_status</h4>

<p><a name="gnutls_005fopenpgp_005fprivkey_005fget_005frevoked_005fstatus"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_privkey_get_revoked_status</b> (<var>gnutls_openpgp_privkey_t key</var>)<var><a name="index-gnutls_005fopenpgp_005fprivkey_005fget_005frevoked_005fstatus-567"></a></var><br>
<blockquote><p><var>key</var>: the structure that contains the OpenPGP private key.

     <p><strong> Description:</strong> Get revocation status of key.

     <p><strong> Returns:</strong> true (1) if the key has been revoked, or false (0) if it
has not, or a negative error code indicates an error.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_privkey_get_subkey_count</h4>

<p><a name="gnutls_005fopenpgp_005fprivkey_005fget_005fsubkey_005fcount"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_privkey_get_subkey_count</b> (<var>gnutls_openpgp_privkey_t key</var>)<var><a name="index-gnutls_005fopenpgp_005fprivkey_005fget_005fsubkey_005fcount-568"></a></var><br>
<blockquote><p><var>key</var>: is an OpenPGP key

     <p><strong> Description:</strong> This function will return the number of subkeys present in the
given OpenPGP certificate.

     <p><strong> Returns:</strong> the number of subkeys, or a negative error code on error.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_privkey_get_subkey_creation_time</h4>

<p><a name="gnutls_005fopenpgp_005fprivkey_005fget_005fsubkey_005fcreation_005ftime"></a>

<div class="defun">
&mdash; Function: time_t <b>gnutls_openpgp_privkey_get_subkey_creation_time</b> (<var>gnutls_openpgp_privkey_t key, unsigned int idx</var>)<var><a name="index-gnutls_005fopenpgp_005fprivkey_005fget_005fsubkey_005fcreation_005ftime-569"></a></var><br>
<blockquote><p><var>key</var>: the structure that contains the OpenPGP private key.

     <p><var>idx</var>: the subkey index

     <p><strong> Description:</strong> Get subkey creation time.

     <p><strong> Returns:</strong> the timestamp when the OpenPGP key was created.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_privkey_get_subkey_fingerprint</h4>

<p><a name="gnutls_005fopenpgp_005fprivkey_005fget_005fsubkey_005ffingerprint"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_privkey_get_subkey_fingerprint</b> (<var>gnutls_openpgp_privkey_t key, unsigned int idx, void * fpr, size_t * fprlen</var>)<var><a name="index-gnutls_005fopenpgp_005fprivkey_005fget_005fsubkey_005ffingerprint-570"></a></var><br>
<blockquote><p><var>key</var>: the raw data that contains the OpenPGP secret key.

     <p><var>idx</var>: the subkey index

     <p><var>fpr</var>: the buffer to save the fingerprint, must hold at least 20 bytes.

     <p><var>fprlen</var>: the integer to save the length of the fingerprint.

     <p><strong> Description:</strong> Get the fingerprint of an OpenPGP subkey.  Depends on the
algorithm, the fingerprint can be 16 or 20 bytes.

     <p><strong> Returns:</strong> On success, 0 is returned, or an error code.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_privkey_get_subkey_id</h4>

<p><a name="gnutls_005fopenpgp_005fprivkey_005fget_005fsubkey_005fid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_privkey_get_subkey_id</b> (<var>gnutls_openpgp_privkey_t key, unsigned int idx, gnutls_openpgp_keyid_t keyid</var>)<var><a name="index-gnutls_005fopenpgp_005fprivkey_005fget_005fsubkey_005fid-571"></a></var><br>
<blockquote><p><var>key</var>: the structure that contains the OpenPGP secret key.

     <p><var>idx</var>: the subkey index

     <p><var>keyid</var>: the buffer to save the keyid.

     <p><strong> Description:</strong> Get the key-id for the subkey.

     <p><strong> Returns:</strong> the 64-bit keyID of the OpenPGP key.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_privkey_get_subkey_idx</h4>

<p><a name="gnutls_005fopenpgp_005fprivkey_005fget_005fsubkey_005fidx"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_privkey_get_subkey_idx</b> (<var>gnutls_openpgp_privkey_t key, const gnutls_openpgp_keyid_t keyid</var>)<var><a name="index-gnutls_005fopenpgp_005fprivkey_005fget_005fsubkey_005fidx-572"></a></var><br>
<blockquote><p><var>key</var>: the structure that contains the OpenPGP private key.

     <p><var>keyid</var>: the keyid.

     <p><strong> Description:</strong> Get index of subkey.

     <p><strong> Returns:</strong> the index of the subkey or a negative error value.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_privkey_get_subkey_pk_algorithm</h4>

<p><a name="gnutls_005fopenpgp_005fprivkey_005fget_005fsubkey_005fpk_005falgorithm"></a>

<div class="defun">
&mdash; Function: gnutls_pk_algorithm_t <b>gnutls_openpgp_privkey_get_subkey_pk_algorithm</b> (<var>gnutls_openpgp_privkey_t key, unsigned int idx, unsigned int * bits</var>)<var><a name="index-gnutls_005fopenpgp_005fprivkey_005fget_005fsubkey_005fpk_005falgorithm-573"></a></var><br>
<blockquote><p><var>key</var>: is an OpenPGP key

     <p><var>idx</var>: is the subkey index

     <p><var>bits</var>: if bits is non null it will hold the size of the parameters' in bits

     <p><strong> Description:</strong> This function will return the public key algorithm of a subkey of an OpenPGP
certificate.

     <p>If bits is non null, it should have enough size to hold the parameters
size in bits. For RSA the bits returned is the modulus. 
For DSA the bits returned are of the public exponent.

     <p><strong> Returns:</strong> a member of the <code>gnutls_pk_algorithm_t</code> enumeration on
success, or a negative error code on error.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_privkey_get_subkey_revoked_status</h4>

<p><a name="gnutls_005fopenpgp_005fprivkey_005fget_005fsubkey_005frevoked_005fstatus"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_privkey_get_subkey_revoked_status</b> (<var>gnutls_openpgp_privkey_t key, unsigned int idx</var>)<var><a name="index-gnutls_005fopenpgp_005fprivkey_005fget_005fsubkey_005frevoked_005fstatus-574"></a></var><br>
<blockquote><p><var>key</var>: the structure that contains the OpenPGP private key.

     <p><var>idx</var>: is the subkey index

     <p><strong> Description:</strong> Get revocation status of key.

     <p><strong> Returns:</strong> true (1) if the key has been revoked, or false (0) if it
has not, or a negative error code indicates an error.

     <p><strong> Since:</strong> 2.4.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_privkey_import</h4>

<p><a name="gnutls_005fopenpgp_005fprivkey_005fimport"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_privkey_import</b> (<var>gnutls_openpgp_privkey_t key, const gnutls_datum_t * data, gnutls_openpgp_crt_fmt_t format, const char * password, unsigned int flags</var>)<var><a name="index-gnutls_005fopenpgp_005fprivkey_005fimport-575"></a></var><br>
<blockquote><p><var>key</var>: The structure to store the parsed key.

     <p><var>data</var>: The RAW or BASE64 encoded key.

     <p><var>format</var>: One of <code>gnutls_openpgp_crt_fmt_t</code> elements.

     <p><var>password</var>: not used for now

     <p><var>flags</var>: should be (0)

     <p><strong> Description:</strong> This function will convert the given RAW or Base64 encoded key to
the native gnutls_openpgp_privkey_t format.  The output will be
stored in 'key'.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_privkey_init</h4>

<p><a name="gnutls_005fopenpgp_005fprivkey_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_privkey_init</b> (<var>gnutls_openpgp_privkey_t * key</var>)<var><a name="index-gnutls_005fopenpgp_005fprivkey_005finit-576"></a></var><br>
<blockquote><p><var>key</var>: The structure to be initialized

     <p><strong> Description:</strong> This function will initialize an OpenPGP key structure.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_privkey_sec_param</h4>

<p><a name="gnutls_005fopenpgp_005fprivkey_005fsec_005fparam"></a>

<div class="defun">
&mdash; Function: gnutls_sec_param_t <b>gnutls_openpgp_privkey_sec_param</b> (<var>gnutls_openpgp_privkey_t key</var>)<var><a name="index-gnutls_005fopenpgp_005fprivkey_005fsec_005fparam-577"></a></var><br>
<blockquote><p><var>key</var>: a key structure

     <p><strong> Description:</strong> This function will return the security parameter appropriate with
this private key.

     <p><strong> Returns:</strong> On success, a valid security parameter is returned otherwise
<code>GNUTLS_SEC_PARAM_UNKNOWN</code> is returned.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_privkey_set_preferred_key_id</h4>

<p><a name="gnutls_005fopenpgp_005fprivkey_005fset_005fpreferred_005fkey_005fid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_privkey_set_preferred_key_id</b> (<var>gnutls_openpgp_privkey_t key, const gnutls_openpgp_keyid_t keyid</var>)<var><a name="index-gnutls_005fopenpgp_005fprivkey_005fset_005fpreferred_005fkey_005fid-578"></a></var><br>
<blockquote><p><var>key</var>: the structure that contains the OpenPGP public key.

     <p><var>keyid</var>: the selected keyid

     <p><strong> Description:</strong> This allows setting a preferred key id for the given certificate. 
This key will be used by functions that involve key handling.

     <p><strong> Returns:</strong> On success, 0 is returned, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_set_recv_key_function</h4>

<p><a name="gnutls_005fopenpgp_005fset_005frecv_005fkey_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_openpgp_set_recv_key_function</b> (<var>gnutls_session_t session, gnutls_openpgp_recv_key_func func</var>)<var><a name="index-gnutls_005fopenpgp_005fset_005frecv_005fkey_005ffunction-579"></a></var><br>
<blockquote><p><var>session</var>: a TLS session

     <p><var>func</var>: the callback

     <p><strong> Description:</strong> This funtion will set a key retrieval function for OpenPGP keys. This
callback is only useful in server side, and will be used if the peer
sent a key fingerprint instead of a full key. 
</p></blockquote></div>

<div class="node">
<a name="PKCS-12-API"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#PKCS-11-API">PKCS 11 API</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#OpenPGP-API">OpenPGP API</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#API-reference">API reference</a>

</div>

<h3 class="section">C.5 PKCS 12 API</h3>

<p>The following functions are to be used for PKCS 12 handling. 
Their prototypes lie in <samp><span class="file">gnutls/pkcs12.h</span></samp>.

<h4 class="subheading">gnutls_pkcs12_bag_decrypt</h4>

<p><a name="gnutls_005fpkcs12_005fbag_005fdecrypt"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs12_bag_decrypt</b> (<var>gnutls_pkcs12_bag_t bag, const char * pass</var>)<var><a name="index-gnutls_005fpkcs12_005fbag_005fdecrypt-580"></a></var><br>
<blockquote><p><var>bag</var>: The bag

     <p><var>pass</var>: The password used for encryption, must be ASCII.

     <p><strong> Description:</strong> This function will decrypt the given encrypted bag and return 0 on
success.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned,
otherwise a negative error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs12_bag_deinit</h4>

<p><a name="gnutls_005fpkcs12_005fbag_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_pkcs12_bag_deinit</b> (<var>gnutls_pkcs12_bag_t bag</var>)<var><a name="index-gnutls_005fpkcs12_005fbag_005fdeinit-581"></a></var><br>
<blockquote><p><var>bag</var>: The structure to be initialized

     <p><strong> Description:</strong> This function will deinitialize a PKCS12 Bag structure. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs12_bag_encrypt</h4>

<p><a name="gnutls_005fpkcs12_005fbag_005fencrypt"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs12_bag_encrypt</b> (<var>gnutls_pkcs12_bag_t bag, const char * pass, unsigned int flags</var>)<var><a name="index-gnutls_005fpkcs12_005fbag_005fencrypt-582"></a></var><br>
<blockquote><p><var>bag</var>: The bag

     <p><var>pass</var>: The password used for encryption, must be ASCII

     <p><var>flags</var>: should be one of <code>gnutls_pkcs_encrypt_flags_t</code> elements bitwise or'd

     <p><strong> Description:</strong> This function will encrypt the given bag.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned,
otherwise a negative error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs12_bag_get_count</h4>

<p><a name="gnutls_005fpkcs12_005fbag_005fget_005fcount"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs12_bag_get_count</b> (<var>gnutls_pkcs12_bag_t bag</var>)<var><a name="index-gnutls_005fpkcs12_005fbag_005fget_005fcount-583"></a></var><br>
<blockquote><p><var>bag</var>: The bag

     <p><strong> Description:</strong> This function will return the number of the elements withing the bag.

     <p><strong> Returns:</strong> Number of elements in bag, or an negative error code on
error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs12_bag_get_data</h4>

<p><a name="gnutls_005fpkcs12_005fbag_005fget_005fdata"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs12_bag_get_data</b> (<var>gnutls_pkcs12_bag_t bag, int indx, gnutls_datum_t * data</var>)<var><a name="index-gnutls_005fpkcs12_005fbag_005fget_005fdata-584"></a></var><br>
<blockquote><p><var>bag</var>: The bag

     <p><var>indx</var>: The element of the bag to get the data from

     <p><var>data</var>: where the bag's data will be. Should be treated as constant.

     <p><strong> Description:</strong> This function will return the bag's data. The data is a constant
that is stored into the bag.  Should not be accessed after the bag
is deleted.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs12_bag_get_friendly_name</h4>

<p><a name="gnutls_005fpkcs12_005fbag_005fget_005ffriendly_005fname"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs12_bag_get_friendly_name</b> (<var>gnutls_pkcs12_bag_t bag, int indx, char ** name</var>)<var><a name="index-gnutls_005fpkcs12_005fbag_005fget_005ffriendly_005fname-585"></a></var><br>
<blockquote><p><var>bag</var>: The bag

     <p><var>indx</var>: The bag's element to add the id

     <p><var>name</var>: will hold a pointer to the name (to be treated as const)

     <p><strong> Description:</strong> This function will return the friendly name, of the specified bag
element.  The key ID is usually used to distinguish the local
private key and the certificate pair.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. or a negative error code on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs12_bag_get_key_id</h4>

<p><a name="gnutls_005fpkcs12_005fbag_005fget_005fkey_005fid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs12_bag_get_key_id</b> (<var>gnutls_pkcs12_bag_t bag, int indx, gnutls_datum_t * id</var>)<var><a name="index-gnutls_005fpkcs12_005fbag_005fget_005fkey_005fid-586"></a></var><br>
<blockquote><p><var>bag</var>: The bag

     <p><var>indx</var>: The bag's element to add the id

     <p><var>id</var>: where the ID will be copied (to be treated as const)

     <p><strong> Description:</strong> This function will return the key ID, of the specified bag element. 
The key ID is usually used to distinguish the local private key and
the certificate pair.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. or a negative error code on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs12_bag_get_type</h4>

<p><a name="gnutls_005fpkcs12_005fbag_005fget_005ftype"></a>

<div class="defun">
&mdash; Function: gnutls_pkcs12_bag_type_t <b>gnutls_pkcs12_bag_get_type</b> (<var>gnutls_pkcs12_bag_t bag, int indx</var>)<var><a name="index-gnutls_005fpkcs12_005fbag_005fget_005ftype-587"></a></var><br>
<blockquote><p><var>bag</var>: The bag

     <p><var>indx</var>: The element of the bag to get the type

     <p><strong> Description:</strong> This function will return the bag's type.

     <p><strong> Returns:</strong> One of the <code>gnutls_pkcs12_bag_type_t</code> enumerations. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs12_bag_init</h4>

<p><a name="gnutls_005fpkcs12_005fbag_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs12_bag_init</b> (<var>gnutls_pkcs12_bag_t * bag</var>)<var><a name="index-gnutls_005fpkcs12_005fbag_005finit-588"></a></var><br>
<blockquote><p><var>bag</var>: The structure to be initialized

     <p><strong> Description:</strong> This function will initialize a PKCS12 bag structure. PKCS12 Bags
usually contain private keys, lists of X.509 Certificates and X.509
Certificate revocation lists.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs12_bag_set_crl</h4>

<p><a name="gnutls_005fpkcs12_005fbag_005fset_005fcrl"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs12_bag_set_crl</b> (<var>gnutls_pkcs12_bag_t bag, gnutls_x509_crl_t crl</var>)<var><a name="index-gnutls_005fpkcs12_005fbag_005fset_005fcrl-589"></a></var><br>
<blockquote><p><var>bag</var>: The bag

     <p><var>crl</var>: the CRL to be copied.

     <p><strong> Description:</strong> This function will insert the given CRL into the
bag. This is just a wrapper over <code>gnutls_pkcs12_bag_set_data()</code>.

     <p><strong> Returns:</strong> the index of the added bag on success, or a negative error code
on failure. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs12_bag_set_crt</h4>

<p><a name="gnutls_005fpkcs12_005fbag_005fset_005fcrt"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs12_bag_set_crt</b> (<var>gnutls_pkcs12_bag_t bag, gnutls_x509_crt_t crt</var>)<var><a name="index-gnutls_005fpkcs12_005fbag_005fset_005fcrt-590"></a></var><br>
<blockquote><p><var>bag</var>: The bag

     <p><var>crt</var>: the certificate to be copied.

     <p><strong> Description:</strong> This function will insert the given certificate into the
bag. This is just a wrapper over <code>gnutls_pkcs12_bag_set_data()</code>.

     <p><strong> Returns:</strong> the index of the added bag on success, or a negative
value on failure. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs12_bag_set_data</h4>

<p><a name="gnutls_005fpkcs12_005fbag_005fset_005fdata"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs12_bag_set_data</b> (<var>gnutls_pkcs12_bag_t bag, gnutls_pkcs12_bag_type_t type, const gnutls_datum_t * data</var>)<var><a name="index-gnutls_005fpkcs12_005fbag_005fset_005fdata-591"></a></var><br>
<blockquote><p><var>bag</var>: The bag

     <p><var>type</var>: The data's type

     <p><var>data</var>: the data to be copied.

     <p><strong> Description:</strong> This function will insert the given data of the given type into
the bag.

     <p><strong> Returns:</strong> the index of the added bag on success, or a negative
value on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs12_bag_set_friendly_name</h4>

<p><a name="gnutls_005fpkcs12_005fbag_005fset_005ffriendly_005fname"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs12_bag_set_friendly_name</b> (<var>gnutls_pkcs12_bag_t bag, int indx, const char * name</var>)<var><a name="index-gnutls_005fpkcs12_005fbag_005fset_005ffriendly_005fname-592"></a></var><br>
<blockquote><p><var>bag</var>: The bag

     <p><var>indx</var>: The bag's element to add the id

     <p><var>name</var>: the name

     <p><strong> Description:</strong> This function will add the given key friendly name, to the
specified, by the index, bag element. The name will be encoded as
a 'Friendly name' bag attribute, which is usually used to set a
user name to the local private key and the certificate pair.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. or a negative error code on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs12_bag_set_key_id</h4>

<p><a name="gnutls_005fpkcs12_005fbag_005fset_005fkey_005fid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs12_bag_set_key_id</b> (<var>gnutls_pkcs12_bag_t bag, int indx, const gnutls_datum_t * id</var>)<var><a name="index-gnutls_005fpkcs12_005fbag_005fset_005fkey_005fid-593"></a></var><br>
<blockquote><p><var>bag</var>: The bag

     <p><var>indx</var>: The bag's element to add the id

     <p><var>id</var>: the ID

     <p><strong> Description:</strong> This function will add the given key ID, to the specified, by the
index, bag element. The key ID will be encoded as a 'Local key
identifier' bag attribute, which is usually used to distinguish
the local private key and the certificate pair.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. or a negative error code on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs12_deinit</h4>

<p><a name="gnutls_005fpkcs12_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_pkcs12_deinit</b> (<var>gnutls_pkcs12_t pkcs12</var>)<var><a name="index-gnutls_005fpkcs12_005fdeinit-594"></a></var><br>
<blockquote><p><var>pkcs12</var>: The structure to be initialized

     <p><strong> Description:</strong> This function will deinitialize a PKCS12 structure. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs12_export</h4>

<p><a name="gnutls_005fpkcs12_005fexport"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs12_export</b> (<var>gnutls_pkcs12_t pkcs12, gnutls_x509_crt_fmt_t format, void * output_data, size_t * output_data_size</var>)<var><a name="index-gnutls_005fpkcs12_005fexport-595"></a></var><br>
<blockquote><p><var>pkcs12</var>: Holds the pkcs12 structure

     <p><var>format</var>: the format of output params. One of PEM or DER.

     <p><var>output_data</var>: will contain a structure PEM or DER encoded

     <p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)

     <p><strong> Description:</strong> This function will export the pkcs12 structure to DER or PEM format.

     <p>If the buffer provided is not long enough to hold the output, then
*output_data_size will be updated and GNUTLS_E_SHORT_MEMORY_BUFFER
will be returned.

     <p>If the structure is PEM encoded, it will have a header
of "BEGIN PKCS12".

     <p><strong> Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs12_generate_mac</h4>

<p><a name="gnutls_005fpkcs12_005fgenerate_005fmac"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs12_generate_mac</b> (<var>gnutls_pkcs12_t pkcs12, const char * pass</var>)<var><a name="index-gnutls_005fpkcs12_005fgenerate_005fmac-596"></a></var><br>
<blockquote><p><var>pkcs12</var>: should contain a gnutls_pkcs12_t structure

     <p><var>pass</var>: The password for the MAC

     <p><strong> Description:</strong> This function will generate a MAC for the PKCS12 structure.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs12_get_bag</h4>

<p><a name="gnutls_005fpkcs12_005fget_005fbag"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs12_get_bag</b> (<var>gnutls_pkcs12_t pkcs12, int indx, gnutls_pkcs12_bag_t bag</var>)<var><a name="index-gnutls_005fpkcs12_005fget_005fbag-597"></a></var><br>
<blockquote><p><var>pkcs12</var>: should contain a gnutls_pkcs12_t structure

     <p><var>indx</var>: contains the index of the bag to extract

     <p><var>bag</var>: An initialized bag, where the contents of the bag will be copied

     <p><strong> Description:</strong> This function will return a Bag from the PKCS12 structure.

     <p>After the last Bag has been read
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> will be returned.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs12_import</h4>

<p><a name="gnutls_005fpkcs12_005fimport"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs12_import</b> (<var>gnutls_pkcs12_t pkcs12, const gnutls_datum_t * data, gnutls_x509_crt_fmt_t format, unsigned int flags</var>)<var><a name="index-gnutls_005fpkcs12_005fimport-598"></a></var><br>
<blockquote><p><var>pkcs12</var>: The structure to store the parsed PKCS12.

     <p><var>data</var>: The DER or PEM encoded PKCS12.

     <p><var>format</var>: One of DER or PEM

     <p><var>flags</var>: an ORed sequence of gnutls_privkey_pkcs8_flags

     <p><strong> Description:</strong> This function will convert the given DER or PEM encoded PKCS12
to the native gnutls_pkcs12_t format. The output will be stored in 'pkcs12'.

     <p>If the PKCS12 is PEM encoded it should have a header of "PKCS12".

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs12_init</h4>

<p><a name="gnutls_005fpkcs12_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs12_init</b> (<var>gnutls_pkcs12_t * pkcs12</var>)<var><a name="index-gnutls_005fpkcs12_005finit-599"></a></var><br>
<blockquote><p><var>pkcs12</var>: The structure to be initialized

     <p><strong> Description:</strong> This function will initialize a PKCS12 structure. PKCS12 structures
usually contain lists of X.509 Certificates and X.509 Certificate
revocation lists.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs12_set_bag</h4>

<p><a name="gnutls_005fpkcs12_005fset_005fbag"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs12_set_bag</b> (<var>gnutls_pkcs12_t pkcs12, gnutls_pkcs12_bag_t bag</var>)<var><a name="index-gnutls_005fpkcs12_005fset_005fbag-600"></a></var><br>
<blockquote><p><var>pkcs12</var>: should contain a gnutls_pkcs12_t structure

     <p><var>bag</var>: An initialized bag

     <p><strong> Description:</strong> This function will insert a Bag into the PKCS12 structure.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs12_verify_mac</h4>

<p><a name="gnutls_005fpkcs12_005fverify_005fmac"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs12_verify_mac</b> (<var>gnutls_pkcs12_t pkcs12, const char * pass</var>)<var><a name="index-gnutls_005fpkcs12_005fverify_005fmac-601"></a></var><br>
<blockquote><p><var>pkcs12</var>: should contain a gnutls_pkcs12_t structure

     <p><var>pass</var>: The password for the MAC

     <p><strong> Description:</strong> This function will verify the MAC for the PKCS12 structure.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<div class="node">
<a name="PKCS-11-API"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Abstract-key-API">Abstract key API</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#PKCS-12-API">PKCS 12 API</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#API-reference">API reference</a>

</div>

<h3 class="section">C.6 Hardware token via PKCS 11 API</h3>

<p>The following functions are to be used for PKCS 11 handling. 
Their prototypes lie in <samp><span class="file">gnutls/pkcs11.h</span></samp>.

<h4 class="subheading">gnutls_pkcs11_add_provider</h4>

<p><a name="gnutls_005fpkcs11_005fadd_005fprovider"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs11_add_provider</b> (<var>const char * name, const char * params</var>)<var><a name="index-gnutls_005fpkcs11_005fadd_005fprovider-602"></a></var><br>
<blockquote><p><var>name</var>: The filename of the module

     <p><var>params</var>: should be NULL

     <p><strong> Description:</strong> This function will load and add a PKCS 11 module to the module
list used in gnutls. After this function is called the module will
be used for PKCS 11 operations.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_copy_secret_key</h4>

<p><a name="gnutls_005fpkcs11_005fcopy_005fsecret_005fkey"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs11_copy_secret_key</b> (<var>const char * token_url, gnutls_datum_t * key, const char * label, unsigned int key_usage, unsigned int flags</var>)<var><a name="index-gnutls_005fpkcs11_005fcopy_005fsecret_005fkey-603"></a></var><br>
<blockquote><p><var>token_url</var>: A PKCS <code>11</code> URL specifying a token

     <p><var>key</var>: The raw key

     <p><var>label</var>: A name to be used for the stored data

     <p><var>key_usage</var>: One of GNUTLS_KEY_*

     <p><var>flags</var>: One of GNUTLS_PKCS11_OBJ_FLAG_*

     <p><strong> Description:</strong> This function will copy a raw secret (symmetric) key into a PKCS <code>11</code>
token specified by a URL. The key can be marked as sensitive or not.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_copy_x509_crt</h4>

<p><a name="gnutls_005fpkcs11_005fcopy_005fx509_005fcrt"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs11_copy_x509_crt</b> (<var>const char * token_url, gnutls_x509_crt_t crt, const char * label, unsigned int flags</var>)<var><a name="index-gnutls_005fpkcs11_005fcopy_005fx509_005fcrt-604"></a></var><br>
<blockquote><p><var>token_url</var>: A PKCS <code>11</code> URL specifying a token

     <p><var>crt</var>: A certificate

     <p><var>label</var>: A name to be used for the stored data

     <p><var>flags</var>: One of GNUTLS_PKCS11_OBJ_FLAG_*

     <p><strong> Description:</strong> This function will copy a certificate into a PKCS <code>11</code> token specified by
a URL. The certificate can be marked as trusted or not.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_copy_x509_privkey</h4>

<p><a name="gnutls_005fpkcs11_005fcopy_005fx509_005fprivkey"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs11_copy_x509_privkey</b> (<var>const char * token_url, gnutls_x509_privkey_t key, const char * label, unsigned int key_usage, unsigned int flags</var>)<var><a name="index-gnutls_005fpkcs11_005fcopy_005fx509_005fprivkey-605"></a></var><br>
<blockquote><p><var>token_url</var>: A PKCS <code>11</code> URL specifying a token

     <p><var>key</var>: A private key

     <p><var>label</var>: A name to be used for the stored data

     <p><var>key_usage</var>: One of GNUTLS_KEY_*

     <p><var>flags</var>: One of GNUTLS_PKCS11_OBJ_* flags

     <p><strong> Description:</strong> This function will copy a private key into a PKCS <code>11</code> token specified by
a URL. It is highly recommended flags to contain <code>GNUTLS_PKCS11_OBJ_FLAG_MARK_SENSITIVE</code>
unless there is a strong reason not to.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_deinit</h4>

<p><a name="gnutls_005fpkcs11_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_pkcs11_deinit</b> (<var> void</var>)<var><a name="index-gnutls_005fpkcs11_005fdeinit-606"></a></var><br>
<blockquote>
     <p><strong> Description:</strong>
This function will deinitialize the PKCS 11 subsystem in gnutls.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_delete_url</h4>

<p><a name="gnutls_005fpkcs11_005fdelete_005furl"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs11_delete_url</b> (<var>const char * object_url, unsigned int flags</var>)<var><a name="index-gnutls_005fpkcs11_005fdelete_005furl-607"></a></var><br>
<blockquote><p><var>object_url</var>: The URL of the object to delete.

     <p><var>flags</var>: One of GNUTLS_PKCS11_OBJ_* flags

     <p><strong> Description:</strong> This function will delete objects matching the given URL. 
Note that not all tokens support the delete operation.

     <p><strong> Returns:</strong> On success, the number of objects deleted is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_init</h4>

<p><a name="gnutls_005fpkcs11_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs11_init</b> (<var>unsigned int flags, const char * deprecated_config_file</var>)<var><a name="index-gnutls_005fpkcs11_005finit-608"></a></var><br>
<blockquote><p><var>flags</var>: <code>GNUTLS_PKCS11_FLAG_MANUAL</code> or <code>GNUTLS_PKCS11_FLAG_AUTO</code>

     <p><var>deprecated_config_file</var>: either NULL or the location of a deprecated
configuration file

     <p><strong> Description:</strong> This function will initialize the PKCS 11 subsystem in gnutls. It will
read configuration files if <code>GNUTLS_PKCS11_FLAG_AUTO</code> is used or allow
you to independently load PKCS 11 modules using <code>gnutls_pkcs11_add_provider()</code>
if <code>GNUTLS_PKCS11_FLAG_MANUAL</code> is specified.

     <p>Normally you don't need to call this function since it is being called
by <code>gnutls_global_init()</code> using the <code>GNUTLS_PKCS11_FLAG_AUTO</code>. If other option
is required then it must be called before it.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_obj_deinit</h4>

<p><a name="gnutls_005fpkcs11_005fobj_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_pkcs11_obj_deinit</b> (<var>gnutls_pkcs11_obj_t obj</var>)<var><a name="index-gnutls_005fpkcs11_005fobj_005fdeinit-609"></a></var><br>
<blockquote><p><var>obj</var>: The structure to be initialized

     <p><strong> Description:</strong> This function will deinitialize a certificate structure.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_obj_export</h4>

<p><a name="gnutls_005fpkcs11_005fobj_005fexport"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs11_obj_export</b> (<var>gnutls_pkcs11_obj_t obj, void * output_data, size_t * output_data_size</var>)<var><a name="index-gnutls_005fpkcs11_005fobj_005fexport-610"></a></var><br>
<blockquote><p><var>obj</var>: Holds the object

     <p><var>output_data</var>: will contain a certificate PEM or DER encoded

     <p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)

     <p><strong> Description:</strong> This function will export the PKCS11 object data.  It is normal for
data to be inaccesible and in that case <code>GNUTLS_E_INVALID_REQUEST</code>
will be returned.

     <p>If the buffer provided is not long enough to hold the output, then
*output_data_size is updated and GNUTLS_E_SHORT_MEMORY_BUFFER will
be returned.

     <p>If the structure is PEM encoded, it will have a header
of "BEGIN CERTIFICATE".

     <p><strong> Returns:</strong> In case of failure a negative error code will be
returned, and <code>GNUTLS_E_SUCCESS</code> (0) on success.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_obj_export_url</h4>

<p><a name="gnutls_005fpkcs11_005fobj_005fexport_005furl"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs11_obj_export_url</b> (<var>gnutls_pkcs11_obj_t obj, gnutls_pkcs11_url_type_t detailed, char ** url</var>)<var><a name="index-gnutls_005fpkcs11_005fobj_005fexport_005furl-611"></a></var><br>
<blockquote><p><var>obj</var>: Holds the PKCS 11 certificate

     <p><var>detailed</var>: non zero if a detailed URL is required

     <p><var>url</var>: will contain an allocated url

     <p><strong> Description:</strong> This function will export a URL identifying the given certificate.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_obj_get_info</h4>

<p><a name="gnutls_005fpkcs11_005fobj_005fget_005finfo"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs11_obj_get_info</b> (<var>gnutls_pkcs11_obj_t crt, gnutls_pkcs11_obj_info_t itype, void * output, size_t * output_size</var>)<var><a name="index-gnutls_005fpkcs11_005fobj_005fget_005finfo-612"></a></var><br>
<blockquote><p><var>crt</var>: should contain a <code>gnutls_pkcs11_obj_t</code> structure

     <p><var>itype</var>: Denotes the type of information requested

     <p><var>output</var>: where output will be stored

     <p><var>output_size</var>: contains the maximum size of the output and will be overwritten with actual

     <p><strong> Description:</strong> This function will return information about the PKCS11 certificate
such as the label, id as well as token information where the key is
stored. When output is text it returns null terminated string
although  <code>output_size</code>contains the size of the actual data only.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> (0) on success or a negative error code on error.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_obj_get_type</h4>

<p><a name="gnutls_005fpkcs11_005fobj_005fget_005ftype"></a>

<div class="defun">
&mdash; Function: gnutls_pkcs11_obj_type_t <b>gnutls_pkcs11_obj_get_type</b> (<var>gnutls_pkcs11_obj_t obj</var>)<var><a name="index-gnutls_005fpkcs11_005fobj_005fget_005ftype-613"></a></var><br>
<blockquote><p><var>obj</var>: Holds the PKCS 11 object

     <p><strong> Description:</strong> This function will return the type of the certificate being
stored in the structure.

     <p><strong> Returns:</strong> The type of the certificate.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_obj_import_url</h4>

<p><a name="gnutls_005fpkcs11_005fobj_005fimport_005furl"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs11_obj_import_url</b> (<var>gnutls_pkcs11_obj_t cert, const char * url, unsigned int flags</var>)<var><a name="index-gnutls_005fpkcs11_005fobj_005fimport_005furl-614"></a></var><br>
<blockquote><p><var>cert</var>: The structure to store the parsed certificate

     <p><var>url</var>: a PKCS 11 url identifying the key

     <p><var>flags</var>: One of GNUTLS_PKCS11_OBJ_* flags

     <p><strong> Description:</strong> This function will "import" a PKCS 11 URL identifying a certificate
key to the <code>gnutls_pkcs11_obj_t</code> structure. This does not involve any
parsing (such as X.509 or OpenPGP) since the <code>gnutls_pkcs11_obj_t</code> is
format agnostic. Only data are transferred.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_obj_init</h4>

<p><a name="gnutls_005fpkcs11_005fobj_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs11_obj_init</b> (<var>gnutls_pkcs11_obj_t * obj</var>)<var><a name="index-gnutls_005fpkcs11_005fobj_005finit-615"></a></var><br>
<blockquote><p><var>obj</var>: The structure to be initialized

     <p><strong> Description:</strong> This function will initialize a pkcs11 certificate structure.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_obj_list_import_url</h4>

<p><a name="gnutls_005fpkcs11_005fobj_005flist_005fimport_005furl"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs11_obj_list_import_url</b> (<var>gnutls_pkcs11_obj_t * p_list, unsigned int * n_list, const char * url, gnutls_pkcs11_obj_attr_t attrs, unsigned int flags</var>)<var><a name="index-gnutls_005fpkcs11_005fobj_005flist_005fimport_005furl-616"></a></var><br>
<blockquote><p><var>p_list</var>: An uninitialized object list (may be NULL)

     <p><var>n_list</var>: initially should hold the maximum size of the list. Will contain the actual size.

     <p><var>url</var>: A PKCS 11 url identifying a set of objects

     <p><var>attrs</var>: Attributes of type <code>gnutls_pkcs11_obj_attr_t</code> that can be used to limit output

     <p><var>flags</var>: One of GNUTLS_PKCS11_OBJ_* flags

     <p><strong> Description:</strong> This function will initialize and set values to an object list
by using all objects identified by a PKCS 11 URL.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_privkey_deinit</h4>

<p><a name="gnutls_005fpkcs11_005fprivkey_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_pkcs11_privkey_deinit</b> (<var>gnutls_pkcs11_privkey_t key</var>)<var><a name="index-gnutls_005fpkcs11_005fprivkey_005fdeinit-617"></a></var><br>
<blockquote><p><var>key</var>: The structure to be initialized

     <p><strong> Description:</strong> This function will deinitialize a private key structure. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_privkey_export_url</h4>

<p><a name="gnutls_005fpkcs11_005fprivkey_005fexport_005furl"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs11_privkey_export_url</b> (<var>gnutls_pkcs11_privkey_t key, gnutls_pkcs11_url_type_t detailed, char ** url</var>)<var><a name="index-gnutls_005fpkcs11_005fprivkey_005fexport_005furl-618"></a></var><br>
<blockquote><p><var>key</var>: Holds the PKCS 11 key

     <p><var>detailed</var>: non zero if a detailed URL is required

     <p><var>url</var>: will contain an allocated url

     <p><strong> Description:</strong> This function will export a URL identifying the given key.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_privkey_generate</h4>

<p><a name="gnutls_005fpkcs11_005fprivkey_005fgenerate"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs11_privkey_generate</b> (<var>const char* url, gnutls_pk_algorithm_t pk, unsigned int bits, const char* label, unsigned int flags</var>)<var><a name="index-gnutls_005fpkcs11_005fprivkey_005fgenerate-619"></a></var><br>
<blockquote><p><var>url</var>: a token URL

     <p><var>pk</var>: the public key algorithm

     <p><var>bits</var>: the security bits

     <p><var>label</var>: a label

     <p><var>flags</var>: should be zero

     <p><strong> Description:</strong> This function will generate a private key in the specified
by the  <code>url</code>token. The pivate key will be generate within
the token and will not be exportable.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_privkey_get_info</h4>

<p><a name="gnutls_005fpkcs11_005fprivkey_005fget_005finfo"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs11_privkey_get_info</b> (<var>gnutls_pkcs11_privkey_t pkey, gnutls_pkcs11_obj_info_t itype, void * output, size_t * output_size</var>)<var><a name="index-gnutls_005fpkcs11_005fprivkey_005fget_005finfo-620"></a></var><br>
<blockquote><p><var>pkey</var>: should contain a <code>gnutls_pkcs11_privkey_t</code> structure

     <p><var>itype</var>: Denotes the type of information requested

     <p><var>output</var>: where output will be stored

     <p><var>output_size</var>: contains the maximum size of the output and will be overwritten with actual

     <p><strong> Description:</strong> This function will return information about the PKCS 11 private key such
as the label, id as well as token information where the key is stored. When
output is text it returns null terminated string although <code>output_size</code> contains
the size of the actual data only.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> (0) on success or a negative error code on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_privkey_get_pk_algorithm</h4>

<p><a name="gnutls_005fpkcs11_005fprivkey_005fget_005fpk_005falgorithm"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs11_privkey_get_pk_algorithm</b> (<var>gnutls_pkcs11_privkey_t key, unsigned int * bits</var>)<var><a name="index-gnutls_005fpkcs11_005fprivkey_005fget_005fpk_005falgorithm-621"></a></var><br>
<blockquote><p><var>key</var>: should contain a <code>gnutls_pkcs11_privkey_t</code> structure

     <p><var>bits</var>: if bits is non null it will hold the size of the parameters' in bits

     <p><strong> Description:</strong> This function will return the public key algorithm of a private
key.

     <p><strong> Returns:</strong> a member of the <code>gnutls_pk_algorithm_t</code> enumeration on
success, or a negative error code on error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_privkey_import_url</h4>

<p><a name="gnutls_005fpkcs11_005fprivkey_005fimport_005furl"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs11_privkey_import_url</b> (<var>gnutls_pkcs11_privkey_t pkey, const char * url, unsigned int flags</var>)<var><a name="index-gnutls_005fpkcs11_005fprivkey_005fimport_005furl-622"></a></var><br>
<blockquote><p><var>pkey</var>: The structure to store the parsed key

     <p><var>url</var>: a PKCS 11 url identifying the key

     <p><var>flags</var>: sequence of GNUTLS_PKCS_PRIVKEY_*

     <p><strong> Description:</strong> This function will "import" a PKCS 11 URL identifying a private
key to the <code>gnutls_pkcs11_privkey_t</code> structure. In reality since
in most cases keys cannot be exported, the private key structure
is being associated with the available operations on the token.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_privkey_init</h4>

<p><a name="gnutls_005fpkcs11_005fprivkey_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs11_privkey_init</b> (<var>gnutls_pkcs11_privkey_t * key</var>)<var><a name="index-gnutls_005fpkcs11_005fprivkey_005finit-623"></a></var><br>
<blockquote><p><var>key</var>: The structure to be initialized

     <p><strong> Description:</strong> This function will initialize an private key structure.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_set_pin_function</h4>

<p><a name="gnutls_005fpkcs11_005fset_005fpin_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_pkcs11_set_pin_function</b> (<var>gnutls_pkcs11_pin_callback_t fn, void * userdata</var>)<var><a name="index-gnutls_005fpkcs11_005fset_005fpin_005ffunction-624"></a></var><br>
<blockquote><p><var>fn</var>: The PIN callback, a <code>gnutls_pkcs11_pin_callback_t()</code> function.

     <p><var>userdata</var>: data to be supplied to callback

     <p><strong> Description:</strong> This function will set a callback function to be used when a PIN is
required for PKCS 11 operations.  See
<code>gnutls_pkcs11_pin_callback_t()</code> on how the callback should behave.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_set_token_function</h4>

<p><a name="gnutls_005fpkcs11_005fset_005ftoken_005ffunction"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_pkcs11_set_token_function</b> (<var>gnutls_pkcs11_token_callback_t fn, void * userdata</var>)<var><a name="index-gnutls_005fpkcs11_005fset_005ftoken_005ffunction-625"></a></var><br>
<blockquote><p><var>fn</var>: The token callback

     <p><var>userdata</var>: data to be supplied to callback

     <p><strong> Description:</strong> This function will set a callback function to be used when a token
needs to be inserted to continue PKCS 11 operations.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_token_get_flags</h4>

<p><a name="gnutls_005fpkcs11_005ftoken_005fget_005fflags"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs11_token_get_flags</b> (<var>const char * url, unsigned int * flags</var>)<var><a name="index-gnutls_005fpkcs11_005ftoken_005fget_005fflags-626"></a></var><br>
<blockquote><p><var>url</var>: should contain a PKCS 11 URL

     <p><var>flags</var>: The output flags (GNUTLS_PKCS11_TOKEN_*)

     <p><strong> Description:</strong> This function will return information about the PKCS 11 token flags. 
The flags from the <code>gnutls_pkcs11_token_info_t</code> enumeration.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> (0) on success or a negative error code on error.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_token_get_info</h4>

<p><a name="gnutls_005fpkcs11_005ftoken_005fget_005finfo"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs11_token_get_info</b> (<var>const char * url, gnutls_pkcs11_token_info_t ttype, void * output, size_t * output_size</var>)<var><a name="index-gnutls_005fpkcs11_005ftoken_005fget_005finfo-627"></a></var><br>
<blockquote><p><var>url</var>: should contain a PKCS 11 URL

     <p><var>ttype</var>: Denotes the type of information requested

     <p><var>output</var>: where output will be stored

     <p><var>output_size</var>: contains the maximum size of the output and will be overwritten with actual

     <p><strong> Description:</strong> This function will return information about the PKCS 11 token such
as the label, id, etc.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> (0) on success or a negative error code
on error.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_token_get_mechanism</h4>

<p><a name="gnutls_005fpkcs11_005ftoken_005fget_005fmechanism"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs11_token_get_mechanism</b> (<var>const char * url, int idx, unsigned long * mechanism</var>)<var><a name="index-gnutls_005fpkcs11_005ftoken_005fget_005fmechanism-628"></a></var><br>
<blockquote><p><var>url</var>: should contain a PKCS 11 URL

     <p><var>idx</var>: The index of the mechanism

     <p><var>mechanism</var>: The PKCS <code>11</code> mechanism ID

     <p><strong> Description:</strong> This function will return the names of the supported mechanisms
by the token. It should be called with an increasing index until
it return GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> (0) on success or a negative error code on error.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_token_get_url</h4>

<p><a name="gnutls_005fpkcs11_005ftoken_005fget_005furl"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs11_token_get_url</b> (<var>unsigned int seq, gnutls_pkcs11_url_type_t detailed, char ** url</var>)<var><a name="index-gnutls_005fpkcs11_005ftoken_005fget_005furl-629"></a></var><br>
<blockquote><p><var>seq</var>: sequence number starting from 0

     <p><var>detailed</var>: non zero if a detailed URL is required

     <p><var>url</var>: will contain an allocated url

     <p><strong> Description:</strong> This function will return the URL for each token available
in system. The url has to be released using <code>gnutls_free()</code>

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned,
<code>GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE</code> if the sequence number
exceeds the available tokens, otherwise a negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_token_init</h4>

<p><a name="gnutls_005fpkcs11_005ftoken_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs11_token_init</b> (<var>const char * token_url, const char * so_pin, const char * label</var>)<var><a name="index-gnutls_005fpkcs11_005ftoken_005finit-630"></a></var><br>
<blockquote><p><var>token_url</var>: A PKCS <code>11</code> URL specifying a token

     <p><var>so_pin</var>: Security Officer's PIN

     <p><var>label</var>: A name to be used for the token

     <p><strong> Description:</strong> This function will initialize (format) a token. If the token is
at a factory defaults state the security officer's PIN given will be
set to be the default. Otherwise it should match the officer's PIN.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_token_set_pin</h4>

<p><a name="gnutls_005fpkcs11_005ftoken_005fset_005fpin"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pkcs11_token_set_pin</b> (<var>const char * token_url, const char * oldpin, const char * newpin, unsigned int flags</var>)<var><a name="index-gnutls_005fpkcs11_005ftoken_005fset_005fpin-631"></a></var><br>
<blockquote><p><var>token_url</var>: A PKCS <code>11</code> URL specifying a token

     <p><var>oldpin</var>: old user's PIN

     <p><var>newpin</var>: new user's PIN

     <p><var>flags</var>: one of <code>gnutls_pkcs11_pin_flag_t</code>.

     <p><strong> Description:</strong> This function will modify or set a user's PIN for the given token. 
If it is called to set a user pin for first time the oldpin must
be NULL.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_pkcs11_type_get_name</h4>

<p><a name="gnutls_005fpkcs11_005ftype_005fget_005fname"></a>

<div class="defun">
&mdash; Function: const char * <b>gnutls_pkcs11_type_get_name</b> (<var>gnutls_pkcs11_obj_type_t type</var>)<var><a name="index-gnutls_005fpkcs11_005ftype_005fget_005fname-632"></a></var><br>
<blockquote><p><var>type</var>: Holds the PKCS 11 object type, a <code>gnutls_pkcs11_obj_type_t</code>.

     <p><strong> Description:</strong> This function will return a human readable description of the
PKCS11 object type  <code>obj</code>.  It will return "Unknown" for unknown
types.

     <p><strong> Returns:</strong> human readable string labeling the PKCS11 object type
 <code>type</code>.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_import_pkcs11</h4>

<p><a name="gnutls_005fx509_005fcrt_005fimport_005fpkcs11"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_import_pkcs11</b> (<var>gnutls_x509_crt_t crt, gnutls_pkcs11_obj_t pkcs11_crt</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fimport_005fpkcs11-633"></a></var><br>
<blockquote><p><var>crt</var>: A certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>pkcs11_crt</var>: A PKCS 11 object that contains a certificate

     <p><strong> Description:</strong> This function will import a PKCS 11 certificate to a <code>gnutls_x509_crt_t</code>
structure.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_import_pkcs11_url</h4>

<p><a name="gnutls_005fx509_005fcrt_005fimport_005fpkcs11_005furl"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_import_pkcs11_url</b> (<var>gnutls_x509_crt_t crt, const char * url, unsigned int flags</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fimport_005fpkcs11_005furl-634"></a></var><br>
<blockquote><p><var>crt</var>: A certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>url</var>: A PKCS 11 url

     <p><var>flags</var>: One of GNUTLS_PKCS11_OBJ_* flags

     <p><strong> Description:</strong> This function will import a PKCS 11 certificate directly from a token
without involving the <code>gnutls_pkcs11_obj_t</code> structure. This function will
fail if the certificate stored is not of X.509 type.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_list_import_pkcs11</h4>

<p><a name="gnutls_005fx509_005fcrt_005flist_005fimport_005fpkcs11"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_list_import_pkcs11</b> (<var>gnutls_x509_crt_t * certs, unsigned int cert_max, gnutls_pkcs11_obj_t * const objs, unsigned int flags</var>)<var><a name="index-gnutls_005fx509_005fcrt_005flist_005fimport_005fpkcs11-635"></a></var><br>
<blockquote><p><var>certs</var>: A list of certificates of type <code>gnutls_x509_crt_t</code>

     <p><var>cert_max</var>: The maximum size of the list

     <p><var>objs</var>: A list of PKCS 11 objects

     <p><var>flags</var>: 0 for now

     <p><strong> Description:</strong> This function will import a PKCS 11 certificate list to a list of
<code>gnutls_x509_crt_t</code> structure. These must not be initialized.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<div class="node">
<a name="Abstract-key-API"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Cryptographic-API">Cryptographic API</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#PKCS-11-API">PKCS 11 API</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#API-reference">API reference</a>

</div>

<h3 class="section">C.7 Abstract key API</h3>

<p>The following functions are to be used for abstract key handling. 
Their prototypes lie in <samp><span class="file">gnutls/abstract.h</span></samp>.

<h4 class="subheading">gnutls_certificate_set_key</h4>

<p><a name="gnutls_005fcertificate_005fset_005fkey"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_certificate_set_key</b> (<var>gnutls_certificate_credentials_t res, const char** names, int names_size, gnutls_pcert_st * pcert_list, int pcert_list_size, gnutls_privkey_t key</var>)<var><a name="index-gnutls_005fcertificate_005fset_005fkey-636"></a></var><br>
<blockquote><p><var>res</var>: is a <code>gnutls_certificate_credentials_t</code> structure.

     <p><var>names</var>: is an array of DNS name of the certificate (NULL if none)

     <p><var>names_size</var>: holds the size of the names list

     <p><var>pcert_list</var>: contains a certificate list (path) for the specified private key

     <p><var>pcert_list_size</var>: holds the size of the certificate list

     <p><var>key</var>: is a gnutls_x509_privkey_t key

     <p><strong> Description:</strong> This function sets a certificate/private key pair in the
gnutls_certificate_credentials_t structure.  This function may be
called more than once, in case multiple keys/certificates exist for
the server.  For clients that wants to send more than its own end
entity certificate (e.g., also an intermediate CA cert) then put
the certificate chain in  <code>pcert_list</code>. The  <code>pcert_list</code>and  <code>key</code>will
become part of the credentials structure and must not
be deallocated. They will be automatically deallocated when
 <code>res</code>is deinitialized.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> (0) on success, or a negative error code.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pcert_deinit</h4>

<p><a name="gnutls_005fpcert_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_pcert_deinit</b> (<var>gnutls_pcert_st * pcert</var>)<var><a name="index-gnutls_005fpcert_005fdeinit-637"></a></var><br>
<blockquote><p><var>pcert</var>: The structure to be deinitialized

     <p><strong> Description:</strong> This function will deinitialize a pcert structure.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pcert_import_openpgp</h4>

<p><a name="gnutls_005fpcert_005fimport_005fopenpgp"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pcert_import_openpgp</b> (<var>gnutls_pcert_st* pcert, gnutls_openpgp_crt_t crt, unsigned int flags</var>)<var><a name="index-gnutls_005fpcert_005fimport_005fopenpgp-638"></a></var><br>
<blockquote><p><var>pcert</var>: The pcert structure

     <p><var>crt</var>: The raw certificate to be imported

     <p><var>flags</var>: zero for now

     <p><strong> Description:</strong> This convenience function will import the given certificate to a
<code>gnutls_pcert_st</code> structure. The structure must be deinitialized
afterwards using <code>gnutls_pcert_deinit()</code>;

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pcert_import_openpgp_raw</h4>

<p><a name="gnutls_005fpcert_005fimport_005fopenpgp_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pcert_import_openpgp_raw</b> (<var>gnutls_pcert_st * pcert, const gnutls_datum_t* cert, gnutls_openpgp_crt_fmt_t format, gnutls_openpgp_keyid_t keyid, unsigned int flags</var>)<var><a name="index-gnutls_005fpcert_005fimport_005fopenpgp_005fraw-639"></a></var><br>
<blockquote><p><var>pcert</var>: The pcert structure

     <p><var>cert</var>: The raw certificate to be imported

     <p><var>format</var>: The format of the certificate

     <p><var>keyid</var>: The key ID to use (NULL for the master key)

     <p><var>flags</var>: zero for now

     <p><strong> Description:</strong> This convenience function will import the given certificate to a
<code>gnutls_pcert_st</code> structure. The structure must be deinitialized
afterwards using <code>gnutls_pcert_deinit()</code>;

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pcert_import_x509</h4>

<p><a name="gnutls_005fpcert_005fimport_005fx509"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pcert_import_x509</b> (<var>gnutls_pcert_st* pcert, gnutls_x509_crt_t crt, unsigned int flags</var>)<var><a name="index-gnutls_005fpcert_005fimport_005fx509-640"></a></var><br>
<blockquote><p><var>pcert</var>: The pcert structure

     <p><var>crt</var>: The raw certificate to be imported

     <p><var>flags</var>: zero for now

     <p><strong> Description:</strong> This convenience function will import the given certificate to a
<code>gnutls_pcert_st</code> structure. The structure must be deinitialized
afterwards using <code>gnutls_pcert_deinit()</code>;

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pcert_import_x509_raw</h4>

<p><a name="gnutls_005fpcert_005fimport_005fx509_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pcert_import_x509_raw</b> (<var>gnutls_pcert_st * pcert, const gnutls_datum_t* cert, gnutls_x509_crt_fmt_t format, unsigned int flags</var>)<var><a name="index-gnutls_005fpcert_005fimport_005fx509_005fraw-641"></a></var><br>
<blockquote><p><var>pcert</var>: The pcert structure

     <p><var>cert</var>: The raw certificate to be imported

     <p><var>format</var>: The format of the certificate

     <p><var>flags</var>: zero for now

     <p><strong> Description:</strong> This convenience function will import the given certificate to a
<code>gnutls_pcert_st</code> structure. The structure must be deinitialized
afterwards using <code>gnutls_pcert_deinit()</code>;

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pcert_list_import_x509_raw</h4>

<p><a name="gnutls_005fpcert_005flist_005fimport_005fx509_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pcert_list_import_x509_raw</b> (<var>gnutls_pcert_st * pcerts, unsigned int * pcert_max, const gnutls_datum_t * data, gnutls_x509_crt_fmt_t format, unsigned int flags</var>)<var><a name="index-gnutls_005fpcert_005flist_005fimport_005fx509_005fraw-642"></a></var><br>
<blockquote><p><var>pcerts</var>: The structures to store the parsed certificate. Must not be initialized.

     <p><var>pcert_max</var>: Initially must hold the maximum number of certs. It will be updated with the number of certs available.

     <p><var>data</var>: The certificates.

     <p><var>format</var>: One of DER or PEM.

     <p><var>flags</var>: must be (0) or an OR'd sequence of gnutls_certificate_import_flags.

     <p><strong> Description:</strong> This function will convert the given PEM encoded certificate list
to the native gnutls_x509_crt_t format. The output will be stored
in  <code>certs</code>.  They will be automatically initialized.

     <p>If the Certificate is PEM encoded it should have a header of "X509
CERTIFICATE", or "CERTIFICATE".

     <p><strong> Returns:</strong> the number of certificates read or a negative error value.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_privkey_decrypt_data</h4>

<p><a name="gnutls_005fprivkey_005fdecrypt_005fdata"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_privkey_decrypt_data</b> (<var>gnutls_privkey_t key, unsigned int flags, const gnutls_datum_t * ciphertext, gnutls_datum_t * plaintext</var>)<var><a name="index-gnutls_005fprivkey_005fdecrypt_005fdata-643"></a></var><br>
<blockquote><p><var>key</var>: Holds the key

     <p><var>flags</var>: zero for now

     <p><var>ciphertext</var>: holds the data to be decrypted

     <p><var>plaintext</var>: will contain the decrypted data, allocated with <code>gnutls_malloc()</code>

     <p><strong> Description:</strong> This function will decrypt the given data using the algorithm
supported by the private key.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_privkey_deinit</h4>

<p><a name="gnutls_005fprivkey_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_privkey_deinit</b> (<var>gnutls_privkey_t key</var>)<var><a name="index-gnutls_005fprivkey_005fdeinit-644"></a></var><br>
<blockquote><p><var>key</var>: The structure to be deinitialized

     <p><strong> Description:</strong> This function will deinitialize a private key structure.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_privkey_get_pk_algorithm</h4>

<p><a name="gnutls_005fprivkey_005fget_005fpk_005falgorithm"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_privkey_get_pk_algorithm</b> (<var>gnutls_privkey_t key, unsigned int * bits</var>)<var><a name="index-gnutls_005fprivkey_005fget_005fpk_005falgorithm-645"></a></var><br>
<blockquote><p><var>key</var>: should contain a <code>gnutls_privkey_t</code> structure

     <p><var>bits</var>: If set will return the number of bits of the parameters (may be NULL)

     <p><strong> Description:</strong> This function will return the public key algorithm of a private
key and if possible will return a number of bits that indicates
the security parameter of the key.

     <p><strong> Returns:</strong> a member of the <code>gnutls_pk_algorithm_t</code> enumeration on
success, or a negative error code on error.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_privkey_get_type</h4>

<p><a name="gnutls_005fprivkey_005fget_005ftype"></a>

<div class="defun">
&mdash; Function: gnutls_privkey_type_t <b>gnutls_privkey_get_type</b> (<var>gnutls_privkey_t key</var>)<var><a name="index-gnutls_005fprivkey_005fget_005ftype-646"></a></var><br>
<blockquote><p><var>key</var>: should contain a <code>gnutls_privkey_t</code> structure

     <p><strong> Description:</strong> This function will return the type of the private key. This is
actually the type of the subsystem used to set this private key.

     <p><strong> Returns:</strong> a member of the <code>gnutls_privkey_type_t</code> enumeration on
success, or a negative error code on error.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_privkey_import_ext</h4>

<p><a name="gnutls_005fprivkey_005fimport_005fext"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_privkey_import_ext</b> (<var>gnutls_privkey_t pkey, gnutls_pk_algorithm_t pk, void* userdata, gnutls_privkey_sign_func sign_func, gnutls_privkey_decrypt_func decrypt_func, unsigned int flags</var>)<var><a name="index-gnutls_005fprivkey_005fimport_005fext-647"></a></var><br>
<blockquote><p><var>pkey</var>: The private key

     <p><var>pk</var>: The public key algorithm

     <p><var>userdata</var>: private data to be provided to the callbacks

     <p><var>sign_func</var>: callback for signature operations

     <p><var>decrypt_func</var>: callback for decryption operations

     <p><var>flags</var>: Flags for the import

     <p><strong> Description:</strong> This function will associate the given callbacks with the
<code>gnutls_privkey_t</code> structure. At least one of the two callbacks
must be non-null.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_privkey_import_openpgp</h4>

<p><a name="gnutls_005fprivkey_005fimport_005fopenpgp"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_privkey_import_openpgp</b> (<var>gnutls_privkey_t pkey, gnutls_openpgp_privkey_t key, unsigned int flags</var>)<var><a name="index-gnutls_005fprivkey_005fimport_005fopenpgp-648"></a></var><br>
<blockquote><p><var>pkey</var>: The private key

     <p><var>key</var>: The private key to be imported

     <p><var>flags</var>: Flags for the import

     <p><strong> Description:</strong> This function will import the given private key to the abstract
<code>gnutls_privkey_t</code> structure.

     <p>The <code>gnutls_openpgp_privkey_t</code> object must not be deallocated
during the lifetime of this structure. The subkey set as
preferred will be used, or the master key otherwise.

     <p><code>flags</code>might be zero or one of <code>GNUTLS_PRIVKEY_IMPORT_AUTO_RELEASE</code>
and <code>GNUTLS_PRIVKEY_IMPORT_COPY</code>.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_privkey_import_pkcs11</h4>

<p><a name="gnutls_005fprivkey_005fimport_005fpkcs11"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_privkey_import_pkcs11</b> (<var>gnutls_privkey_t pkey, gnutls_pkcs11_privkey_t key, unsigned int flags</var>)<var><a name="index-gnutls_005fprivkey_005fimport_005fpkcs11-649"></a></var><br>
<blockquote><p><var>pkey</var>: The private key

     <p><var>key</var>: The private key to be imported

     <p><var>flags</var>: Flags for the import

     <p><strong> Description:</strong> This function will import the given private key to the abstract
<code>gnutls_privkey_t</code> structure.

     <p>The <code>gnutls_pkcs11_privkey_t</code> object must not be deallocated
during the lifetime of this structure.

     <p><code>flags</code>might be zero or one of <code>GNUTLS_PRIVKEY_IMPORT_AUTO_RELEASE</code>
and <code>GNUTLS_PRIVKEY_IMPORT_COPY</code>.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_privkey_import_x509</h4>

<p><a name="gnutls_005fprivkey_005fimport_005fx509"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_privkey_import_x509</b> (<var>gnutls_privkey_t pkey, gnutls_x509_privkey_t key, unsigned int flags</var>)<var><a name="index-gnutls_005fprivkey_005fimport_005fx509-650"></a></var><br>
<blockquote><p><var>pkey</var>: The private key

     <p><var>key</var>: The private key to be imported

     <p><var>flags</var>: Flags for the import

     <p><strong> Description:</strong> This function will import the given private key to the abstract
<code>gnutls_privkey_t</code> structure.

     <p>The <code>gnutls_x509_privkey_t</code> object must not be deallocated
during the lifetime of this structure.

     <p><code>flags</code>might be zero or one of <code>GNUTLS_PRIVKEY_IMPORT_AUTO_RELEASE</code>
and <code>GNUTLS_PRIVKEY_IMPORT_COPY</code>.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_privkey_init</h4>

<p><a name="gnutls_005fprivkey_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_privkey_init</b> (<var>gnutls_privkey_t * key</var>)<var><a name="index-gnutls_005fprivkey_005finit-651"></a></var><br>
<blockquote><p><var>key</var>: The structure to be initialized

     <p><strong> Description:</strong> This function will initialize an private key structure.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_privkey_sign_data</h4>

<p><a name="gnutls_005fprivkey_005fsign_005fdata"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_privkey_sign_data</b> (<var>gnutls_privkey_t signer, gnutls_digest_algorithm_t hash, unsigned int flags, const gnutls_datum_t * data, gnutls_datum_t * signature</var>)<var><a name="index-gnutls_005fprivkey_005fsign_005fdata-652"></a></var><br>
<blockquote><p><var>signer</var>: Holds the key

     <p><var>hash</var>: should be a digest algorithm

     <p><var>flags</var>: should be 0 for now

     <p><var>data</var>: holds the data to be signed

     <p><var>signature</var>: will contain the signature allocate with <code>gnutls_malloc()</code>

     <p><strong> Description:</strong> This function will sign the given data using a signature algorithm
supported by the private key. Signature algorithms are always used
together with a hash functions.  Different hash functions may be
used for the RSA algorithm, but only the SHA family for the DSA keys.

     <p>Use <code>gnutls_pubkey_get_preferred_hash_algorithm()</code> to determine
the hash algorithm.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_privkey_sign_hash</h4>

<p><a name="gnutls_005fprivkey_005fsign_005fhash"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_privkey_sign_hash</b> (<var>gnutls_privkey_t signer, gnutls_digest_algorithm_t hash_algo, unsigned int flags, const gnutls_datum_t * hash_data, gnutls_datum_t * signature</var>)<var><a name="index-gnutls_005fprivkey_005fsign_005fhash-653"></a></var><br>
<blockquote><p><var>signer</var>: Holds the signer's key

     <p><var>hash_algo</var>: The hash algorithm used

     <p><var>flags</var>: zero for now

     <p><var>hash_data</var>: holds the data to be signed

     <p><var>signature</var>: will contain newly allocated signature

     <p><strong> Description:</strong> This function will sign the given hashed data using a signature algorithm
supported by the private key. Signature algorithms are always used
together with a hash functions.  Different hash functions may be
used for the RSA algorithm, but only SHA-XXX for the DSA keys.

     <p>Use <code>gnutls_pubkey_get_preferred_hash_algorithm()</code> to determine
the hash algorithm.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_deinit</h4>

<p><a name="gnutls_005fpubkey_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_pubkey_deinit</b> (<var>gnutls_pubkey_t key</var>)<var><a name="index-gnutls_005fpubkey_005fdeinit-654"></a></var><br>
<blockquote><p><var>key</var>: The structure to be deinitialized

     <p><strong> Description:</strong> This function will deinitialize a public key structure.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_export</h4>

<p><a name="gnutls_005fpubkey_005fexport"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_export</b> (<var>gnutls_pubkey_t key, gnutls_x509_crt_fmt_t format, void * output_data, size_t * output_data_size</var>)<var><a name="index-gnutls_005fpubkey_005fexport-655"></a></var><br>
<blockquote><p><var>key</var>: Holds the certificate

     <p><var>format</var>: the format of output params. One of PEM or DER.

     <p><var>output_data</var>: will contain a certificate PEM or DER encoded

     <p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)

     <p><strong> Description:</strong> This function will export the certificate to DER or PEM format.

     <p>If the buffer provided is not long enough to hold the output, then
*output_data_size is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> will
be returned.

     <p>If the structure is PEM encoded, it will have a header
of "BEGIN CERTIFICATE".

     <p><strong> Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_get_key_id</h4>

<p><a name="gnutls_005fpubkey_005fget_005fkey_005fid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_get_key_id</b> (<var>gnutls_pubkey_t key, unsigned int flags, unsigned char * output_data, size_t * output_data_size</var>)<var><a name="index-gnutls_005fpubkey_005fget_005fkey_005fid-656"></a></var><br>
<blockquote><p><var>key</var>: Holds the public key

     <p><var>flags</var>: should be 0 for now

     <p><var>output_data</var>: will contain the key ID

     <p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)

     <p><strong> Description:</strong> This function will return a unique ID the depends on the public
key parameters. This ID can be used in checking whether a
certificate corresponds to the given public key.

     <p>If the buffer provided is not long enough to hold the output, then
*output_data_size is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> will
be returned.  The output will normally be a SHA-1 hash output,
which is 20 bytes.

     <p><strong> Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_get_key_usage</h4>

<p><a name="gnutls_005fpubkey_005fget_005fkey_005fusage"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_get_key_usage</b> (<var>gnutls_pubkey_t key, unsigned int * usage</var>)<var><a name="index-gnutls_005fpubkey_005fget_005fkey_005fusage-657"></a></var><br>
<blockquote><p><var>key</var>: should contain a <code>gnutls_pubkey_t</code> structure

     <p><var>usage</var>: If set will return the number of bits of the parameters (may be NULL)

     <p><strong> Description:</strong> This function will return the key usage of the public key.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_get_openpgp_key_id</h4>

<p><a name="gnutls_005fpubkey_005fget_005fopenpgp_005fkey_005fid"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_get_openpgp_key_id</b> (<var>gnutls_pubkey_t key, unsigned int flags, unsigned char * output_data, size_t * output_data_size, unsigned int * subkey</var>)<var><a name="index-gnutls_005fpubkey_005fget_005fopenpgp_005fkey_005fid-658"></a></var><br>
<blockquote><p><var>key</var>: Holds the public key

     <p><var>flags</var>: should be 0 for now

     <p><var>output_data</var>: will contain the key ID

     <p><var>output_data_size</var>: holds the size of output_data (and will be
replaced by the actual size of parameters)

     <p><var>subkey</var>: Will be non zero if the key ID corresponds to a subkey

     <p><strong> Description:</strong> This function will return a unique ID the depends on the public
key parameters. This ID can be used in checking whether a
certificate corresponds to the given public key.

     <p>If the buffer provided is not long enough to hold the output, then
*output_data_size is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> will
be returned.  The output will normally be a SHA-1 hash output,
which is 20 bytes.

     <p><strong> Returns:</strong> In case of failure a negative error code will be
returned, and 0 on success.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_get_pk_algorithm</h4>

<p><a name="gnutls_005fpubkey_005fget_005fpk_005falgorithm"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_get_pk_algorithm</b> (<var>gnutls_pubkey_t key, unsigned int * bits</var>)<var><a name="index-gnutls_005fpubkey_005fget_005fpk_005falgorithm-659"></a></var><br>
<blockquote><p><var>key</var>: should contain a <code>gnutls_pubkey_t</code> structure

     <p><var>bits</var>: If set will return the number of bits of the parameters (may be NULL)

     <p><strong> Description:</strong> This function will return the public key algorithm of a public
key and if possible will return a number of bits that indicates
the security parameter of the key.

     <p><strong> Returns:</strong> a member of the <code>gnutls_pk_algorithm_t</code> enumeration on
success, or a negative error code on error.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_get_pk_dsa_raw</h4>

<p><a name="gnutls_005fpubkey_005fget_005fpk_005fdsa_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_get_pk_dsa_raw</b> (<var>gnutls_pubkey_t key, gnutls_datum_t * p, gnutls_datum_t * q, gnutls_datum_t * g, gnutls_datum_t * y</var>)<var><a name="index-gnutls_005fpubkey_005fget_005fpk_005fdsa_005fraw-660"></a></var><br>
<blockquote><p><var>key</var>: Holds the public key

     <p><var>p</var>: will hold the p

     <p><var>q</var>: will hold the q

     <p><var>g</var>: will hold the g

     <p><var>y</var>: will hold the y

     <p><strong> Description:</strong> This function will export the DSA public key's parameters found in
the given certificate.  The new parameters will be allocated using
<code>gnutls_malloc()</code> and will be stored in the appropriate datum.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, otherwise a negative error code.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_get_pk_ecc_raw</h4>

<p><a name="gnutls_005fpubkey_005fget_005fpk_005fecc_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_get_pk_ecc_raw</b> (<var>gnutls_pubkey_t key, gnutls_ecc_curve_t * curve, gnutls_datum_t * x, gnutls_datum_t * y</var>)<var><a name="index-gnutls_005fpubkey_005fget_005fpk_005fecc_005fraw-661"></a></var><br>
<blockquote><p><var>key</var>: Holds the public key

     <p><var>curve</var>: will hold the curve

     <p><var>x</var>: will hold x

     <p><var>y</var>: will hold y

     <p><strong> Description:</strong> This function will export the ECC public key's parameters found in
the given certificate.  The new parameters will be allocated using
<code>gnutls_malloc()</code> and will be stored in the appropriate datum.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, otherwise a negative error code.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_get_pk_ecc_x962</h4>

<p><a name="gnutls_005fpubkey_005fget_005fpk_005fecc_005fx962"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_get_pk_ecc_x962</b> (<var>gnutls_pubkey_t key, gnutls_datum_t* parameters, gnutls_datum_t * ecpoint</var>)<var><a name="index-gnutls_005fpubkey_005fget_005fpk_005fecc_005fx962-662"></a></var><br>
<blockquote><p><var>key</var>: Holds the public key

     <p><var>parameters</var>: DER encoding of an ANSI X9.62 parameters

     <p><var>ecpoint</var>: DER encoding of ANSI X9.62 ECPoint

     <p><strong> Description:</strong> This function will export the ECC public key's parameters found in
the given certificate.  The new parameters will be allocated using
<code>gnutls_malloc()</code> and will be stored in the appropriate datum.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, otherwise a negative error code.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_get_pk_rsa_raw</h4>

<p><a name="gnutls_005fpubkey_005fget_005fpk_005frsa_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_get_pk_rsa_raw</b> (<var>gnutls_pubkey_t key, gnutls_datum_t * m, gnutls_datum_t * e</var>)<var><a name="index-gnutls_005fpubkey_005fget_005fpk_005frsa_005fraw-663"></a></var><br>
<blockquote><p><var>key</var>: Holds the certificate

     <p><var>m</var>: will hold the modulus

     <p><var>e</var>: will hold the public exponent

     <p><strong> Description:</strong> This function will export the RSA public key's parameters found in
the given structure.  The new parameters will be allocated using
<code>gnutls_malloc()</code> and will be stored in the appropriate datum.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, otherwise a negative error code.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_get_preferred_hash_algorithm</h4>

<p><a name="gnutls_005fpubkey_005fget_005fpreferred_005fhash_005falgorithm"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_get_preferred_hash_algorithm</b> (<var>gnutls_pubkey_t key, gnutls_digest_algorithm_t * hash, unsigned int * mand</var>)<var><a name="index-gnutls_005fpubkey_005fget_005fpreferred_005fhash_005falgorithm-664"></a></var><br>
<blockquote><p><var>key</var>: Holds the certificate

     <p><var>hash</var>: The result of the call with the hash algorithm used for signature

     <p><var>mand</var>: If non zero it means that the algorithm MUST use this hash. May be NULL.

     <p><strong> Description:</strong> This function will read the certifcate and return the appropriate digest
algorithm to use for signing with this certificate. Some certificates (i.e. 
DSA might not be able to sign without the preferred algorithm).

     <p><strong> Returns:</strong> the 0 if the hash algorithm is found. A negative error code is
returned on error.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_get_verify_algorithm</h4>

<p><a name="gnutls_005fpubkey_005fget_005fverify_005falgorithm"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_get_verify_algorithm</b> (<var>gnutls_pubkey_t key, const gnutls_datum_t * signature, gnutls_digest_algorithm_t * hash</var>)<var><a name="index-gnutls_005fpubkey_005fget_005fverify_005falgorithm-665"></a></var><br>
<blockquote><p><var>key</var>: Holds the certificate

     <p><var>signature</var>: contains the signature

     <p><var>hash</var>: The result of the call with the hash algorithm used for signature

     <p><strong> Description:</strong> This function will read the certifcate and the signed data to
determine the hash algorithm used to generate the signature.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_import</h4>

<p><a name="gnutls_005fpubkey_005fimport"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_import</b> (<var>gnutls_pubkey_t key, const gnutls_datum_t * data, gnutls_x509_crt_fmt_t format</var>)<var><a name="index-gnutls_005fpubkey_005fimport-666"></a></var><br>
<blockquote><p><var>key</var>: The structure to store the parsed public key.

     <p><var>data</var>: The DER or PEM encoded certificate.

     <p><var>format</var>: One of DER or PEM

     <p><strong> Description:</strong> This function will convert the given DER or PEM encoded Public key
to the native gnutls_pubkey_t format.The output will be stored
in  <code>key</code>. 
If the Certificate is PEM encoded it should have a header of "PUBLIC KEY".

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_import_dsa_raw</h4>

<p><a name="gnutls_005fpubkey_005fimport_005fdsa_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_import_dsa_raw</b> (<var>gnutls_pubkey_t key, const gnutls_datum_t * p, const gnutls_datum_t * q, const gnutls_datum_t * g, const gnutls_datum_t * y</var>)<var><a name="index-gnutls_005fpubkey_005fimport_005fdsa_005fraw-667"></a></var><br>
<blockquote><p><var>key</var>: The structure to store the parsed key

     <p><var>p</var>: holds the p

     <p><var>q</var>: holds the q

     <p><var>g</var>: holds the g

     <p><var>y</var>: holds the y

     <p><strong> Description:</strong> This function will convert the given DSA raw parameters to the
native <code>gnutls_pubkey_t</code> format.  The output will be stored
in  <code>key</code>.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_import_ecc_raw</h4>

<p><a name="gnutls_005fpubkey_005fimport_005fecc_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_import_ecc_raw</b> (<var>gnutls_pubkey_t key, gnutls_ecc_curve_t curve, const gnutls_datum_t * x, const gnutls_datum_t * y</var>)<var><a name="index-gnutls_005fpubkey_005fimport_005fecc_005fraw-668"></a></var><br>
<blockquote><p><var>key</var>: The structure to store the parsed key

     <p><var>curve</var>: holds the curve

     <p><var>x</var>: holds the x

     <p><var>y</var>: holds the y

     <p><strong> Description:</strong> This function will convert the given elliptic curve parameters to a
<code>gnutls_pubkey_t</code>.  The output will be stored in  <code>key</code>.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_import_ecc_x962</h4>

<p><a name="gnutls_005fpubkey_005fimport_005fecc_005fx962"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_import_ecc_x962</b> (<var>gnutls_pubkey_t key, const gnutls_datum_t * parameters, const gnutls_datum_t * ecpoint</var>)<var><a name="index-gnutls_005fpubkey_005fimport_005fecc_005fx962-669"></a></var><br>
<blockquote><p><var>key</var>: The structure to store the parsed key

     <p><var>parameters</var>: DER encoding of an ANSI X9.62 parameters

     <p><var>ecpoint</var>: DER encoding of ANSI X9.62 ECPoint

     <p><strong> Description:</strong> This function will convert the given elliptic curve parameters to a
<code>gnutls_pubkey_t</code>.  The output will be stored in  <code>key</code>.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_import_openpgp</h4>

<p><a name="gnutls_005fpubkey_005fimport_005fopenpgp"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_import_openpgp</b> (<var>gnutls_pubkey_t key, gnutls_openpgp_crt_t crt, unsigned int flags</var>)<var><a name="index-gnutls_005fpubkey_005fimport_005fopenpgp-670"></a></var><br>
<blockquote><p><var>key</var>: The public key

     <p><var>crt</var>: The certificate to be imported

     <p><var>flags</var>: should be zero

     <p><strong> Description:</strong> Imports a public key from an openpgp key. This function will import
the given public key to the abstract <code>gnutls_pubkey_t</code>
structure. The subkey set as preferred will be imported or the
master key otherwise.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_import_pkcs11</h4>

<p><a name="gnutls_005fpubkey_005fimport_005fpkcs11"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_import_pkcs11</b> (<var>gnutls_pubkey_t key, gnutls_pkcs11_obj_t obj, unsigned int flags</var>)<var><a name="index-gnutls_005fpubkey_005fimport_005fpkcs11-671"></a></var><br>
<blockquote><p><var>key</var>: The public key

     <p><var>obj</var>: The parameters to be imported

     <p><var>flags</var>: should be zero

     <p><strong> Description:</strong> Imports a public key from a pkcs11 key. This function will import
the given public key to the abstract <code>gnutls_pubkey_t</code> structure.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_import_pkcs11_url</h4>

<p><a name="gnutls_005fpubkey_005fimport_005fpkcs11_005furl"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_import_pkcs11_url</b> (<var>gnutls_pubkey_t key, const char * url, unsigned int flags</var>)<var><a name="index-gnutls_005fpubkey_005fimport_005fpkcs11_005furl-672"></a></var><br>
<blockquote><p><var>key</var>: A key of type <code>gnutls_pubkey_t</code>

     <p><var>url</var>: A PKCS 11 url

     <p><var>flags</var>: One of GNUTLS_PKCS11_OBJ_* flags

     <p><strong> Description:</strong> This function will import a PKCS 11 certificate to a <code>gnutls_pubkey_t</code>
structure.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_import_privkey</h4>

<p><a name="gnutls_005fpubkey_005fimport_005fprivkey"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_import_privkey</b> (<var>gnutls_pubkey_t key, gnutls_privkey_t pkey, unsigned int usage, unsigned int flags</var>)<var><a name="index-gnutls_005fpubkey_005fimport_005fprivkey-673"></a></var><br>
<blockquote><p><var>key</var>: The public key

     <p><var>pkey</var>: The private key

     <p><var>usage</var>: GNUTLS_KEY_* key usage flags.

     <p><var>flags</var>: should be zero

     <p><strong> Description:</strong> Imports the public key from a private.  This function will import
the given public key to the abstract <code>gnutls_pubkey_t</code> structure.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_import_rsa_raw</h4>

<p><a name="gnutls_005fpubkey_005fimport_005frsa_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_import_rsa_raw</b> (<var>gnutls_pubkey_t key, const gnutls_datum_t * m, const gnutls_datum_t * e</var>)<var><a name="index-gnutls_005fpubkey_005fimport_005frsa_005fraw-674"></a></var><br>
<blockquote><p><var>key</var>: Is a structure will hold the parameters

     <p><var>m</var>: holds the modulus

     <p><var>e</var>: holds the public exponent

     <p><strong> Description:</strong> This function will replace the parameters in the given structure. 
The new parameters should be stored in the appropriate
gnutls_datum.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an negative error code.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_import_x509</h4>

<p><a name="gnutls_005fpubkey_005fimport_005fx509"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_import_x509</b> (<var>gnutls_pubkey_t key, gnutls_x509_crt_t crt, unsigned int flags</var>)<var><a name="index-gnutls_005fpubkey_005fimport_005fx509-675"></a></var><br>
<blockquote><p><var>key</var>: The public key

     <p><var>crt</var>: The certificate to be imported

     <p><var>flags</var>: should be zero

     <p><strong> Description:</strong> This function will import the given public key to the abstract
<code>gnutls_pubkey_t</code> structure.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_init</h4>

<p><a name="gnutls_005fpubkey_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_init</b> (<var>gnutls_pubkey_t * key</var>)<var><a name="index-gnutls_005fpubkey_005finit-676"></a></var><br>
<blockquote><p><var>key</var>: The structure to be initialized

     <p><strong> Description:</strong> This function will initialize an public key structure.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_set_key_usage</h4>

<p><a name="gnutls_005fpubkey_005fset_005fkey_005fusage"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_set_key_usage</b> (<var>gnutls_pubkey_t key, unsigned int usage</var>)<var><a name="index-gnutls_005fpubkey_005fset_005fkey_005fusage-677"></a></var><br>
<blockquote><p><var>key</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>usage</var>: an ORed sequence of the GNUTLS_KEY_* elements.

     <p><strong> Description:</strong> This function will set the key usage flags of the public key. This
is only useful if the key is to be exported to a certificate or
certificate request.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_verify_data</h4>

<p><a name="gnutls_005fpubkey_005fverify_005fdata"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_verify_data</b> (<var>gnutls_pubkey_t pubkey, unsigned int flags, const gnutls_datum_t * data, const gnutls_datum_t * signature</var>)<var><a name="index-gnutls_005fpubkey_005fverify_005fdata-678"></a></var><br>
<blockquote><p><var>pubkey</var>: Holds the public key

     <p><var>flags</var>: should be 0 for now

     <p><var>data</var>: holds the signed data

     <p><var>signature</var>: contains the signature

     <p><strong> Description:</strong> This function will verify the given signed data, using the
parameters from the certificate.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value (<code>GNUTLS_E_PK_SIG_VERIFY_FAILED</code> in verification failure).

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_verify_data2</h4>

<p><a name="gnutls_005fpubkey_005fverify_005fdata2"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_verify_data2</b> (<var>gnutls_pubkey_t pubkey, gnutls_sign_algorithm_t algo, unsigned int flags, const gnutls_datum_t * data, const gnutls_datum_t * signature</var>)<var><a name="index-gnutls_005fpubkey_005fverify_005fdata2-679"></a></var><br>
<blockquote><p><var>pubkey</var>: Holds the public key

     <p><var>algo</var>: The signature algorithm used

     <p><var>flags</var>: should be 0 for now

     <p><var>data</var>: holds the signed data

     <p><var>signature</var>: contains the signature

     <p><strong> Description:</strong> This function will verify the given signed data, using the
parameters from the certificate.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value (<code>GNUTLS_E_PK_SIG_VERIFY_FAILED</code> in verification failure).

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_pubkey_verify_hash</h4>

<p><a name="gnutls_005fpubkey_005fverify_005fhash"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_pubkey_verify_hash</b> (<var>gnutls_pubkey_t key, unsigned int flags, const gnutls_datum_t * hash, const gnutls_datum_t * signature</var>)<var><a name="index-gnutls_005fpubkey_005fverify_005fhash-680"></a></var><br>
<blockquote><p><var>key</var>: Holds the certificate

     <p><var>flags</var>: should be 0 for now

     <p><var>hash</var>: holds the hash digest to be verified

     <p><var>signature</var>: contains the signature

     <p><strong> Description:</strong> This function will verify the given signed digest, using the
parameters from the certificate.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value (<code>GNUTLS_E_PK_SIG_VERIFY_FAILED</code> in verification failure).

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_privkey_sign</h4>

<p><a name="gnutls_005fx509_005fcrl_005fprivkey_005fsign"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_privkey_sign</b> (<var>gnutls_x509_crl_t crl, gnutls_x509_crt_t issuer, gnutls_privkey_t issuer_key, gnutls_digest_algorithm_t dig, unsigned int flags</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fprivkey_005fsign-681"></a></var><br>
<blockquote><p><var>crl</var>: should contain a gnutls_x509_crl_t structure

     <p><var>issuer</var>: is the certificate of the certificate issuer

     <p><var>issuer_key</var>: holds the issuer's private key

     <p><var>dig</var>: The message digest to use. GNUTLS_DIG_SHA1 is the safe choice unless you know what you're doing.

     <p><var>flags</var>: must be 0

     <p><strong> Description:</strong> This function will sign the CRL with the issuer's private key, and
will copy the issuer's information into the CRL.

     <p>This must be the last step in a certificate CRL since all
the previously set parameters are now signed.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p>Since 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_privkey_sign</h4>

<p><a name="gnutls_005fx509_005fcrq_005fprivkey_005fsign"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_privkey_sign</b> (<var>gnutls_x509_crq_t crq, gnutls_privkey_t key, gnutls_digest_algorithm_t dig, unsigned int flags</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fprivkey_005fsign-682"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><var>key</var>: holds a private key

     <p><var>dig</var>: The message digest to use, i.e., <code>GNUTLS_DIG_SHA1</code>

     <p><var>flags</var>: must be 0

     <p><strong> Description:</strong> This function will sign the certificate request with a private key. 
This must be the same key as the one used in
<code>gnutls_x509_crt_set_key()</code> since a certificate request is self
signed.

     <p>This must be the last step in a certificate request generation
since all the previously set parameters are now signed.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, otherwise a negative error code. 
<code>GNUTLS_E_ASN1_VALUE_NOT_FOUND</code> is returned if you didn't set all
information in the certificate request (e.g., the version using
<code>gnutls_x509_crq_set_version()</code>).

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_set_pubkey</h4>

<p><a name="gnutls_005fx509_005fcrq_005fset_005fpubkey"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_set_pubkey</b> (<var>gnutls_x509_crq_t crq, gnutls_pubkey_t key</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fset_005fpubkey-683"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><var>key</var>: holds a public key

     <p><strong> Description:</strong> This function will set the public parameters from the given public
key to the request.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_privkey_sign</h4>

<p><a name="gnutls_005fx509_005fcrt_005fprivkey_005fsign"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_privkey_sign</b> (<var>gnutls_x509_crt_t crt, gnutls_x509_crt_t issuer, gnutls_privkey_t issuer_key, gnutls_digest_algorithm_t dig, unsigned int flags</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fprivkey_005fsign-684"></a></var><br>
<blockquote><p><var>crt</var>: a certificate of type <code>gnutls_x509_crt_t</code>

     <p><var>issuer</var>: is the certificate of the certificate issuer

     <p><var>issuer_key</var>: holds the issuer's private key

     <p><var>dig</var>: The message digest to use, <code>GNUTLS_DIG_SHA1</code> is a safe choice

     <p><var>flags</var>: must be 0

     <p><strong> Description:</strong> This function will sign the certificate with the issuer's private key, and
will copy the issuer's information into the certificate.

     <p>This must be the last step in a certificate generation since all
the previously set parameters are now signed.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_set_pubkey</h4>

<p><a name="gnutls_005fx509_005fcrt_005fset_005fpubkey"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_set_pubkey</b> (<var>gnutls_x509_crt_t crt, gnutls_pubkey_t key</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fset_005fpubkey-685"></a></var><br>
<blockquote><p><var>crt</var>: should contain a <code>gnutls_x509_crt_t</code> structure

     <p><var>key</var>: holds a public key

     <p><strong> Description:</strong> This function will set the public parameters from the given public
key to the request.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<div class="node">
<a name="Cryptographic-API"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Compatibility-API">Compatibility API</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Abstract-key-API">Abstract key API</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#API-reference">API reference</a>

</div>

<h3 class="section">C.8 Cryptographic API</h3>

<p>The following functions are to be used for low-level cryptographic operations. 
Their prototypes lie in <samp><span class="file">gnutls/crypto.h</span></samp>.

<h4 class="subheading">gnutls_cipher_add_auth</h4>

<p><a name="gnutls_005fcipher_005fadd_005fauth"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_cipher_add_auth</b> (<var>gnutls_cipher_hd_t handle, const void * text, size_t text_size</var>)<var><a name="index-gnutls_005fcipher_005fadd_005fauth-686"></a></var><br>
<blockquote><p><var>handle</var>: is a <code>gnutls_cipher_hd_t</code> structure.

     <p><var>text</var>: the data to be authenticated

     <p><var>text_size</var>: The length of the data

     <p><strong> Description:</strong> This function operates on authenticated encryption with
associated data (AEAD) ciphers and authenticate the
input data. This function can only be called once
and before any encryption operations.

     <p><strong> Returns:</strong> Zero or a negative error code on error.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_cipher_decrypt</h4>

<p><a name="gnutls_005fcipher_005fdecrypt"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_cipher_decrypt</b> (<var>gnutls_cipher_hd_t handle, void * ciphertext, size_t ciphertextlen</var>)<var><a name="index-gnutls_005fcipher_005fdecrypt-687"></a></var><br>
<blockquote><p><var>handle</var>: is a <code>gnutls_cipher_hd_t</code> structure.

     <p><var>ciphertext</var>: the data to encrypt

     <p><var>ciphertextlen</var>: The length of data to encrypt

     <p><strong> Description:</strong> This function will decrypt the given data using the algorithm
specified by the context.

     <p><strong> Returns:</strong> Zero or a negative error code on error.

     <p><strong> Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_cipher_decrypt2</h4>

<p><a name="gnutls_005fcipher_005fdecrypt2"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_cipher_decrypt2</b> (<var>gnutls_cipher_hd_t handle, const void * ciphertext, size_t ciphertextlen, void * text, size_t textlen</var>)<var><a name="index-gnutls_005fcipher_005fdecrypt2-688"></a></var><br>
<blockquote><p><var>handle</var>: is a <code>gnutls_cipher_hd_t</code> structure.

     <p><var>ciphertext</var>: the data to encrypt

     <p><var>ciphertextlen</var>: The length of data to encrypt

     <p><var>text</var>: the decrypted data

     <p><var>textlen</var>: The available length for decrypted data

     <p><strong> Description:</strong> This function will decrypt the given data using the algorithm
specified by the context.

     <p><strong> Returns:</strong> Zero or a negative error code on error.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_cipher_deinit</h4>

<p><a name="gnutls_005fcipher_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_cipher_deinit</b> (<var>gnutls_cipher_hd_t handle</var>)<var><a name="index-gnutls_005fcipher_005fdeinit-689"></a></var><br>
<blockquote><p><var>handle</var>: is a <code>gnutls_cipher_hd_t</code> structure.

     <p><strong> Description:</strong> This function will deinitialize all resources occupied by the given
encryption context.

     <p><strong> Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_cipher_encrypt</h4>

<p><a name="gnutls_005fcipher_005fencrypt"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_cipher_encrypt</b> (<var>gnutls_cipher_hd_t handle, void * text, size_t textlen</var>)<var><a name="index-gnutls_005fcipher_005fencrypt-690"></a></var><br>
<blockquote><p><var>handle</var>: is a <code>gnutls_cipher_hd_t</code> structure.

     <p><var>text</var>: the data to encrypt

     <p><var>textlen</var>: The length of data to encrypt

     <p><strong> Description:</strong> This function will encrypt the given data using the algorithm
specified by the context.

     <p><strong> Returns:</strong> Zero or a negative error code on error.

     <p><strong> Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_cipher_encrypt2</h4>

<p><a name="gnutls_005fcipher_005fencrypt2"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_cipher_encrypt2</b> (<var>gnutls_cipher_hd_t handle, const void * text, size_t textlen, void * ciphertext, size_t ciphertextlen</var>)<var><a name="index-gnutls_005fcipher_005fencrypt2-691"></a></var><br>
<blockquote><p><var>handle</var>: is a <code>gnutls_cipher_hd_t</code> structure.

     <p><var>text</var>: the data to encrypt

     <p><var>textlen</var>: The length of data to encrypt

     <p><var>ciphertext</var>: the encrypted data

     <p><var>ciphertextlen</var>: The available length for encrypted data

     <p><strong> Description:</strong> This function will encrypt the given data using the algorithm
specified by the context.

     <p><strong> Returns:</strong> Zero or a negative error code on error.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_cipher_get_block_size</h4>

<p><a name="gnutls_005fcipher_005fget_005fblock_005fsize"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_cipher_get_block_size</b> (<var>gnutls_cipher_algorithm_t algorithm</var>)<var><a name="index-gnutls_005fcipher_005fget_005fblock_005fsize-692"></a></var><br>
<blockquote><p><var>algorithm</var>: is an encryption algorithm

     <p><strong> Description:</strong> Get block size for encryption algorithm.

     <p><strong> Returns:</strong> block size for encryption algorithm.

     <p><strong> Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_cipher_init</h4>

<p><a name="gnutls_005fcipher_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_cipher_init</b> (<var>gnutls_cipher_hd_t * handle, gnutls_cipher_algorithm_t cipher, const gnutls_datum_t * key, const gnutls_datum_t * iv</var>)<var><a name="index-gnutls_005fcipher_005finit-693"></a></var><br>
<blockquote><p><var>handle</var>: is a <code>gnutls_cipher_hd_t</code> structure.

     <p><var>cipher</var>: the encryption algorithm to use

     <p><var>key</var>: The key to be used for encryption

     <p><var>iv</var>: The IV to use (if not applicable set NULL)

     <p><strong> Description:</strong> This function will initialize an context that can be used for
encryption/decryption of data. This will effectively use the
current crypto backend in use by gnutls or the cryptographic
accelerator in use.

     <p><strong> Returns:</strong> Zero or a negative error code on error.

     <p><strong> Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_cipher_set_iv</h4>

<p><a name="gnutls_005fcipher_005fset_005fiv"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_cipher_set_iv</b> (<var>gnutls_cipher_hd_t handle, void * iv, size_t ivlen</var>)<var><a name="index-gnutls_005fcipher_005fset_005fiv-694"></a></var><br>
<blockquote><p><var>handle</var>: is a <code>gnutls_cipher_hd_t</code> structure.

     <p><var>iv</var>: the IV to set

     <p><var>ivlen</var>: The length of the IV

     <p><strong> Description:</strong> This function will set the IV to be used for the next
encryption block.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_cipher_tag</h4>

<p><a name="gnutls_005fcipher_005ftag"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_cipher_tag</b> (<var>gnutls_cipher_hd_t handle, void * tag, size_t tag_size</var>)<var><a name="index-gnutls_005fcipher_005ftag-695"></a></var><br>
<blockquote><p><var>handle</var>: is a <code>gnutls_cipher_hd_t</code> structure.

     <p><var>tag</var>: will hold the tag

     <p><var>tag_size</var>: The length of the tag to return

     <p><strong> Description:</strong> This function operates on authenticated encryption with
associated data (AEAD) ciphers and will return the
output tag.

     <p><strong> Returns:</strong> Zero or a negative error code on error.

     <p><strong> Since:</strong> 3.0.0
</p></blockquote></div>

<h4 class="subheading">gnutls_hash</h4>

<p><a name="gnutls_005fhash"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_hash</b> (<var>gnutls_hash_hd_t handle, const void * text, size_t textlen</var>)<var><a name="index-gnutls_005fhash-696"></a></var><br>
<blockquote><p><var>handle</var>: is a <code>gnutls_cipher_hd_t</code> structure.

     <p><var>text</var>: the data to hash

     <p><var>textlen</var>: The length of data to hash

     <p><strong> Description:</strong> This function will hash the given data using the algorithm
specified by the context.

     <p><strong> Returns:</strong> Zero or a negative error code on error.

     <p><strong> Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_hash_deinit</h4>

<p><a name="gnutls_005fhash_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_hash_deinit</b> (<var>gnutls_hash_hd_t handle, void * digest</var>)<var><a name="index-gnutls_005fhash_005fdeinit-697"></a></var><br>
<blockquote><p><var>handle</var>: is a <code>gnutls_hash_hd_t</code> structure.

     <p><var>digest</var>: is the output value of the hash

     <p><strong> Description:</strong> This function will deinitialize all resources occupied by
the given hash context.

     <p><strong> Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_hash_fast</h4>

<p><a name="gnutls_005fhash_005ffast"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_hash_fast</b> (<var>gnutls_digest_algorithm_t algorithm, const void * text, size_t textlen, void * digest</var>)<var><a name="index-gnutls_005fhash_005ffast-698"></a></var><br>
<blockquote><p><var>algorithm</var>: the hash algorithm to use

     <p><var>text</var>: the data to hash

     <p><var>textlen</var>: The length of data to hash

     <p><var>digest</var>: is the output value of the hash

     <p><strong> Description:</strong> This convenience function will hash the given data and return output
on a single call.

     <p><strong> Returns:</strong> Zero or a negative error code on error.

     <p><strong> Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_hash_get_len</h4>

<p><a name="gnutls_005fhash_005fget_005flen"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_hash_get_len</b> (<var>gnutls_digest_algorithm_t algorithm</var>)<var><a name="index-gnutls_005fhash_005fget_005flen-699"></a></var><br>
<blockquote><p><var>algorithm</var>: the hash algorithm to use

     <p><strong> Description:</strong> This function will return the length of the output data
of the given hash algorithm.

     <p><strong> Returns:</strong> The length or zero on error.

     <p><strong> Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_hash_init</h4>

<p><a name="gnutls_005fhash_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_hash_init</b> (<var>gnutls_hash_hd_t * dig, gnutls_digest_algorithm_t algorithm</var>)<var><a name="index-gnutls_005fhash_005finit-700"></a></var><br>
<blockquote><p><var>dig</var>: is a <code>gnutls_hash_hd_t</code> structure.

     <p><var>algorithm</var>: the hash algorithm to use

     <p><strong> Description:</strong> This function will initialize an context that can be used to
produce a Message Digest of data.  This will effectively use the
current crypto backend in use by gnutls or the cryptographic
accelerator in use.

     <p><strong> Returns:</strong> Zero or a negative error code on error.

     <p><strong> Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_hash_output</h4>

<p><a name="gnutls_005fhash_005foutput"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_hash_output</b> (<var>gnutls_hash_hd_t handle, void * digest</var>)<var><a name="index-gnutls_005fhash_005foutput-701"></a></var><br>
<blockquote><p><var>handle</var>: is a <code>gnutls_hash_hd_t</code> structure.

     <p><var>digest</var>: is the output value of the hash

     <p><strong> Description:</strong> This function will output the current hash value.

     <p><strong> Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_hmac</h4>

<p><a name="gnutls_005fhmac"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_hmac</b> (<var>gnutls_hmac_hd_t handle, const void * text, size_t textlen</var>)<var><a name="index-gnutls_005fhmac-702"></a></var><br>
<blockquote><p><var>handle</var>: is a <code>gnutls_cipher_hd_t</code> structure.

     <p><var>text</var>: the data to hash

     <p><var>textlen</var>: The length of data to hash

     <p><strong> Description:</strong> This function will hash the given data using the algorithm
specified by the context.

     <p><strong> Returns:</strong> Zero or a negative error code on error.

     <p><strong> Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_hmac_deinit</h4>

<p><a name="gnutls_005fhmac_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_hmac_deinit</b> (<var>gnutls_hmac_hd_t handle, void * digest</var>)<var><a name="index-gnutls_005fhmac_005fdeinit-703"></a></var><br>
<blockquote><p><var>handle</var>: is a <code>gnutls_hmac_hd_t</code> structure.

     <p><var>digest</var>: is the output value of the MAC

     <p><strong> Description:</strong> This function will deinitialize all resources occupied by
the given hmac context.

     <p><strong> Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_hmac_fast</h4>

<p><a name="gnutls_005fhmac_005ffast"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_hmac_fast</b> (<var>gnutls_mac_algorithm_t algorithm, const void * key, size_t keylen, const void * text, size_t textlen, void * digest</var>)<var><a name="index-gnutls_005fhmac_005ffast-704"></a></var><br>
<blockquote><p><var>algorithm</var>: the hash algorithm to use

     <p><var>key</var>: the key to use

     <p><var>keylen</var>: The length of the key

     <p><var>text</var>: the data to hash

     <p><var>textlen</var>: The length of data to hash

     <p><var>digest</var>: is the output value of the hash

     <p><strong> Description:</strong> This convenience function will hash the given data and return output
on a single call.

     <p><strong> Returns:</strong> Zero or a negative error code on error.

     <p><strong> Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_hmac_get_len</h4>

<p><a name="gnutls_005fhmac_005fget_005flen"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_hmac_get_len</b> (<var>gnutls_mac_algorithm_t algorithm</var>)<var><a name="index-gnutls_005fhmac_005fget_005flen-705"></a></var><br>
<blockquote><p><var>algorithm</var>: the hmac algorithm to use

     <p><strong> Description:</strong> This function will return the length of the output data
of the given hmac algorithm.

     <p><strong> Returns:</strong> The length or zero on error.

     <p><strong> Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_hmac_init</h4>

<p><a name="gnutls_005fhmac_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_hmac_init</b> (<var>gnutls_hmac_hd_t * dig, gnutls_digest_algorithm_t algorithm, const void * key, size_t keylen</var>)<var><a name="index-gnutls_005fhmac_005finit-706"></a></var><br>
<blockquote><p><var>dig</var>: is a <code>gnutls_hmac_hd_t</code> structure.

     <p><var>algorithm</var>: the HMAC algorithm to use

     <p><var>key</var>: The key to be used for encryption

     <p><var>keylen</var>: The length of the key

     <p><strong> Description:</strong> This function will initialize an context that can be used to
produce a Message Authentication Code (MAC) of data.  This will
effectively use the current crypto backend in use by gnutls or the
cryptographic accelerator in use.

     <p><strong> Returns:</strong> Zero or a negative error code on error.

     <p><strong> Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_hmac_output</h4>

<p><a name="gnutls_005fhmac_005foutput"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_hmac_output</b> (<var>gnutls_hmac_hd_t handle, void * digest</var>)<var><a name="index-gnutls_005fhmac_005foutput-707"></a></var><br>
<blockquote><p><var>handle</var>: is a <code>gnutls_hmac_hd_t</code> structure.

     <p><var>digest</var>: is the output value of the MAC

     <p><strong> Description:</strong> This function will output the current MAC value.

     <p><strong> Since:</strong> 2.10.0
</p></blockquote></div>

<h4 class="subheading">gnutls_rnd</h4>

<p><a name="gnutls_005frnd"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_rnd</b> (<var>gnutls_rnd_level_t level, void * data, size_t len</var>)<var><a name="index-gnutls_005frnd-708"></a></var><br>
<blockquote><p><var>level</var>: a security level

     <p><var>data</var>: place to store random bytes

     <p><var>len</var>: The requested size

     <p><strong> Description:</strong> This function will generate random data and store it to output
buffer.

     <p><strong> Returns:</strong> Zero or a negative error code on error.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<div class="node">
<a name="Compatibility-API"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Cryptographic-API">Cryptographic API</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#API-reference">API reference</a>

</div>

<h3 class="section">C.9 Compatibility API</h3>

<p>The following functions are carried over from old GnuTLS released. They might be removed at a later version. 
Their prototypes lie in <samp><span class="file">gnutls/compat.h</span></samp>.

<h4 class="subheading">gnutls_certificate_set_rsa_export_params</h4>

<p><a name="gnutls_005fcertificate_005fset_005frsa_005fexport_005fparams"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_certificate_set_rsa_export_params</b> (<var>gnutls_certificate_credentials_t res, gnutls_rsa_params_t rsa_params</var>)<var><a name="index-gnutls_005fcertificate_005fset_005frsa_005fexport_005fparams-709"></a></var><br>
<blockquote><p><var>res</var>: is a gnutls_certificate_credentials_t structure

     <p><var>rsa_params</var>: is a structure that holds temporary RSA parameters.

     <p><strong> Description:</strong> This function will set the temporary RSA parameters for a
certificate server to use.  These parameters will be used in
RSA-EXPORT cipher suites. 
</p></blockquote></div>

<h4 class="subheading">gnutls_certificate_type_set_priority</h4>

<p><a name="gnutls_005fcertificate_005ftype_005fset_005fpriority"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_certificate_type_set_priority</b> (<var>gnutls_session_t session, const int * list</var>)<var><a name="index-gnutls_005fcertificate_005ftype_005fset_005fpriority-710"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>list</var>: is a 0 terminated list of gnutls_certificate_type_t elements.

     <p><strong> Description:</strong> Sets the priority on the certificate types supported by gnutls. 
Priority is higher for elements specified before others. 
After specifying the types you want, you must append a 0. 
Note that the certificate type priority is set on the client. 
The server does not use the cert type priority except for disabling
types that were not specified.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_cipher_set_priority</h4>

<p><a name="gnutls_005fcipher_005fset_005fpriority"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_cipher_set_priority</b> (<var>gnutls_session_t session, const int * list</var>)<var><a name="index-gnutls_005fcipher_005fset_005fpriority-711"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>list</var>: is a 0 terminated list of gnutls_cipher_algorithm_t elements.

     <p><strong> Description:</strong> Sets the priority on the ciphers supported by gnutls.  Priority is
higher for elements specified before others.  After specifying the
ciphers you want, you must append a 0.  Note that the priority is
set on the client. The server does not use the algorithm's
priority except for disabling algorithms that were not specified.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> (0) on success, or a negative error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_compression_set_priority</h4>

<p><a name="gnutls_005fcompression_005fset_005fpriority"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_compression_set_priority</b> (<var>gnutls_session_t session, const int * list</var>)<var><a name="index-gnutls_005fcompression_005fset_005fpriority-712"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>list</var>: is a 0 terminated list of gnutls_compression_method_t elements.

     <p><strong> Description:</strong> Sets the priority on the compression algorithms supported by
gnutls.  Priority is higher for elements specified before others. 
After specifying the algorithms you want, you must append a 0. 
Note that the priority is set on the client. The server does not
use the algorithm's priority except for disabling algorithms that
were not specified.

     <p>TLS 1.0 does not define any compression algorithms except
NULL. Other compression algorithms are to be considered as gnutls
extensions.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_kx_set_priority</h4>

<p><a name="gnutls_005fkx_005fset_005fpriority"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_kx_set_priority</b> (<var>gnutls_session_t session, const int * list</var>)<var><a name="index-gnutls_005fkx_005fset_005fpriority-713"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>list</var>: is a 0 terminated list of gnutls_kx_algorithm_t elements.

     <p><strong> Description:</strong> Sets the priority on the key exchange algorithms supported by
gnutls.  Priority is higher for elements specified before others. 
After specifying the algorithms you want, you must append a 0. 
Note that the priority is set on the client. The server does not
use the algorithm's priority except for disabling algorithms that
were not specified.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_mac_set_priority</h4>

<p><a name="gnutls_005fmac_005fset_005fpriority"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_mac_set_priority</b> (<var>gnutls_session_t session, const int * list</var>)<var><a name="index-gnutls_005fmac_005fset_005fpriority-714"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>list</var>: is a 0 terminated list of gnutls_mac_algorithm_t elements.

     <p><strong> Description:</strong> Sets the priority on the mac algorithms supported by gnutls. 
Priority is higher for elements specified before others.  After
specifying the algorithms you want, you must append a 0.  Note
that the priority is set on the client. The server does not use
the algorithm's priority except for disabling algorithms that were
not specified.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_openpgp_privkey_sign_hash</h4>

<p><a name="gnutls_005fopenpgp_005fprivkey_005fsign_005fhash"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_openpgp_privkey_sign_hash</b> (<var>gnutls_openpgp_privkey_t key, const gnutls_datum_t * hash, gnutls_datum_t * signature</var>)<var><a name="index-gnutls_005fopenpgp_005fprivkey_005fsign_005fhash-715"></a></var><br>
<blockquote><p><var>key</var>: Holds the key

     <p><var>hash</var>: holds the data to be signed

     <p><var>signature</var>: will contain newly allocated signature

     <p><strong> Description:</strong> This function will sign the given hash using the private key.  You
should use <code>gnutls_openpgp_privkey_set_preferred_key_id()</code> before
calling this function to set the subkey to use.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Deprecated:</strong> Use <code>gnutls_privkey_sign_hash()</code> instead. 
</p></blockquote></div>

<h4 class="subheading">gnutls_protocol_set_priority</h4>

<p><a name="gnutls_005fprotocol_005fset_005fpriority"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_protocol_set_priority</b> (<var>gnutls_session_t session, const int * list</var>)<var><a name="index-gnutls_005fprotocol_005fset_005fpriority-716"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><var>list</var>: is a 0 terminated list of gnutls_protocol_t elements.

     <p><strong> Description:</strong> Sets the priority on the protocol versions supported by gnutls. 
This function actually enables or disables protocols. Newer protocol
versions always have highest priority.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_rsa_export_get_modulus_bits</h4>

<p><a name="gnutls_005frsa_005fexport_005fget_005fmodulus_005fbits"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_rsa_export_get_modulus_bits</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005frsa_005fexport_005fget_005fmodulus_005fbits-717"></a></var><br>
<blockquote><p><var>session</var>: is a gnutls session

     <p><strong> Description:</strong> Get the export RSA parameter's modulus size.

     <p><strong> Returns:</strong> The bits used in the last RSA-EXPORT key exchange with the
peer, or a negative error code in case of error. 
</p></blockquote></div>

<h4 class="subheading">gnutls_rsa_export_get_pubkey</h4>

<p><a name="gnutls_005frsa_005fexport_005fget_005fpubkey"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_rsa_export_get_pubkey</b> (<var>gnutls_session_t session, gnutls_datum_t * exponent, gnutls_datum_t * modulus</var>)<var><a name="index-gnutls_005frsa_005fexport_005fget_005fpubkey-718"></a></var><br>
<blockquote><p><var>session</var>: is a gnutls session

     <p><var>exponent</var>: will hold the exponent.

     <p><var>modulus</var>: will hold the modulus.

     <p><strong> Description:</strong> This function will return the peer's public key exponent and
modulus used in the last RSA-EXPORT authentication.  The output
parameters must be freed with <code>gnutls_free()</code>.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise
an error code is returned. 
</p></blockquote></div>

<h4 class="subheading">gnutls_rsa_params_cpy</h4>

<p><a name="gnutls_005frsa_005fparams_005fcpy"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_rsa_params_cpy</b> (<var>gnutls_rsa_params_t dst, gnutls_rsa_params_t src</var>)<var><a name="index-gnutls_005frsa_005fparams_005fcpy-719"></a></var><br>
<blockquote><p><var>dst</var>: Is the destination structure, which should be initialized.

     <p><var>src</var>: Is the source structure

     <p><strong> Description:</strong> This function will copy the RSA parameters structure from source
to destination.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an negative error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_rsa_params_deinit</h4>

<p><a name="gnutls_005frsa_005fparams_005fdeinit"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_rsa_params_deinit</b> (<var>gnutls_rsa_params_t rsa_params</var>)<var><a name="index-gnutls_005frsa_005fparams_005fdeinit-720"></a></var><br>
<blockquote><p><var>rsa_params</var>: Is a structure that holds the parameters

     <p><strong> Description:</strong> This function will deinitialize the RSA parameters structure. 
</p></blockquote></div>

<h4 class="subheading">gnutls_rsa_params_export_pkcs1</h4>

<p><a name="gnutls_005frsa_005fparams_005fexport_005fpkcs1"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_rsa_params_export_pkcs1</b> (<var>gnutls_rsa_params_t params, gnutls_x509_crt_fmt_t format, unsigned char * params_data, size_t * params_data_size</var>)<var><a name="index-gnutls_005frsa_005fparams_005fexport_005fpkcs1-721"></a></var><br>
<blockquote><p><var>params</var>: Holds the RSA parameters

     <p><var>format</var>: the format of output params. One of PEM or DER.

     <p><var>params_data</var>: will contain a PKCS1 RSAPublicKey structure PEM or DER encoded

     <p><var>params_data_size</var>: holds the size of params_data (and will be replaced by the actual size of parameters)

     <p><strong> Description:</strong> This function will export the given RSA parameters to a PKCS1
RSAPublicKey structure. If the buffer provided is not long enough to
hold the output, then GNUTLS_E_SHORT_MEMORY_BUFFER will be returned.

     <p>If the structure is PEM encoded, it will have a header
of "BEGIN RSA PRIVATE KEY".

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an negative error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_rsa_params_export_raw</h4>

<p><a name="gnutls_005frsa_005fparams_005fexport_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_rsa_params_export_raw</b> (<var>gnutls_rsa_params_t rsa, gnutls_datum_t * m, gnutls_datum_t * e, gnutls_datum_t * d, gnutls_datum_t * p, gnutls_datum_t * q, gnutls_datum_t * u, unsigned int * bits</var>)<var><a name="index-gnutls_005frsa_005fparams_005fexport_005fraw-722"></a></var><br>
<blockquote><p><var>rsa</var>: a structure that holds the rsa parameters

     <p><var>m</var>: will hold the modulus

     <p><var>e</var>: will hold the public exponent

     <p><var>d</var>: will hold the private exponent

     <p><var>p</var>: will hold the first prime (p)

     <p><var>q</var>: will hold the second prime (q)

     <p><var>u</var>: will hold the coefficient

     <p><var>bits</var>: if non null will hold the prime's number of bits

     <p><strong> Description:</strong> This function will export the RSA parameters found in the given
structure. The new parameters will be allocated using
<code>gnutls_malloc()</code> and will be stored in the appropriate datum.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an negative error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_rsa_params_generate2</h4>

<p><a name="gnutls_005frsa_005fparams_005fgenerate2"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_rsa_params_generate2</b> (<var>gnutls_rsa_params_t params, unsigned int bits</var>)<var><a name="index-gnutls_005frsa_005fparams_005fgenerate2-723"></a></var><br>
<blockquote><p><var>params</var>: The structure where the parameters will be stored

     <p><var>bits</var>: is the prime's number of bits

     <p><strong> Description:</strong> This function will generate new temporary RSA parameters for use in
RSA-EXPORT ciphersuites.  This function is normally slow.

     <p>Note that if the parameters are to be used in export cipher suites the
bits value should be 512 or less. 
Also note that the generation of new RSA parameters is only useful
to servers. Clients use the parameters sent by the server, thus it's
no use calling this in client side.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an negative error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_rsa_params_import_pkcs1</h4>

<p><a name="gnutls_005frsa_005fparams_005fimport_005fpkcs1"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_rsa_params_import_pkcs1</b> (<var>gnutls_rsa_params_t params, const gnutls_datum_t * pkcs1_params, gnutls_x509_crt_fmt_t format</var>)<var><a name="index-gnutls_005frsa_005fparams_005fimport_005fpkcs1-724"></a></var><br>
<blockquote><p><var>params</var>: A structure where the parameters will be copied to

     <p><var>pkcs1_params</var>: should contain a PKCS1 RSAPublicKey structure PEM or DER encoded

     <p><var>format</var>: the format of params. PEM or DER.

     <p><strong> Description:</strong> This function will extract the RSAPublicKey found in a PKCS1 formatted
structure.

     <p>If the structure is PEM encoded, it should have a header
of "BEGIN RSA PRIVATE KEY".

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an negative error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_rsa_params_import_raw</h4>

<p><a name="gnutls_005frsa_005fparams_005fimport_005fraw"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_rsa_params_import_raw</b> (<var>gnutls_rsa_params_t rsa_params, const gnutls_datum_t * m, const gnutls_datum_t * e, const gnutls_datum_t * d, const gnutls_datum_t * p, const gnutls_datum_t * q, const gnutls_datum_t * u</var>)<var><a name="index-gnutls_005frsa_005fparams_005fimport_005fraw-725"></a></var><br>
<blockquote><p><var>rsa_params</var>: Is a structure will hold the parameters

     <p><var>m</var>: holds the modulus

     <p><var>e</var>: holds the public exponent

     <p><var>d</var>: holds the private exponent

     <p><var>p</var>: holds the first prime (p)

     <p><var>q</var>: holds the second prime (q)

     <p><var>u</var>: holds the coefficient

     <p><strong> Description:</strong> This function will replace the parameters in the given structure. 
The new parameters should be stored in the appropriate
gnutls_datum.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an negative error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_rsa_params_init</h4>

<p><a name="gnutls_005frsa_005fparams_005finit"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_rsa_params_init</b> (<var>gnutls_rsa_params_t * rsa_params</var>)<var><a name="index-gnutls_005frsa_005fparams_005finit-726"></a></var><br>
<blockquote><p><var>rsa_params</var>: Is a structure that will hold the parameters

     <p><strong> Description:</strong> This function will initialize the temporary RSA parameters structure.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an negative error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_set_default_export_priority</h4>

<p><a name="gnutls_005fset_005fdefault_005fexport_005fpriority"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_set_default_export_priority</b> (<var>gnutls_session_t session</var>)<var><a name="index-gnutls_005fset_005fdefault_005fexport_005fpriority-727"></a></var><br>
<blockquote><p><var>session</var>: is a <code>gnutls_session_t</code> structure.

     <p><strong> Description:</strong> Sets some default priority on the ciphers, key exchange methods, macs
and compression methods.  This function also includes weak algorithms.

     <p><strong> This is the same as calling:</strong>
gnutls_priority_set_direct (session, "EXPORT", NULL);

     <p>This function is kept around for backwards compatibility, but
because of its wide use it is still fully supported.  If you wish
to allow users to provide a string that specify which ciphers to
use (which is recommended), you should use
<code>gnutls_priority_set_direct()</code> or <code>gnutls_priority_set()</code> instead.

     <p><strong> Returns:</strong> <code>GNUTLS_E_SUCCESS</code> on success, or an error code. 
</p></blockquote></div>

<h4 class="subheading">gnutls_sign_callback_get</h4>

<p><a name="gnutls_005fsign_005fcallback_005fget"></a>

<div class="defun">
&mdash; Function: gnutls_sign_func <b>gnutls_sign_callback_get</b> (<var>gnutls_session_t session, void ** userdata</var>)<var><a name="index-gnutls_005fsign_005fcallback_005fget-728"></a></var><br>
<blockquote><p><var>session</var>: is a gnutls session

     <p><var>userdata</var>: if non-<code>NULL</code>, will be set to abstract callback pointer.

     <p><strong> Description:</strong> Retrieve the callback function, and its userdata pointer.

     <p><strong> Returns:</strong> The function pointer set by <code>gnutls_sign_callback_set()</code>, or
if not set, <code>NULL</code>.

     <p><strong> Deprecated:</strong> Use the PKCS 11 interfaces instead. 
</p></blockquote></div>

<h4 class="subheading">gnutls_sign_callback_set</h4>

<p><a name="gnutls_005fsign_005fcallback_005fset"></a>

<div class="defun">
&mdash; Function: void <b>gnutls_sign_callback_set</b> (<var>gnutls_session_t session, gnutls_sign_func sign_func, void * userdata</var>)<var><a name="index-gnutls_005fsign_005fcallback_005fset-729"></a></var><br>
<blockquote><p><var>session</var>: is a gnutls session

     <p><var>sign_func</var>: function pointer to application's sign callback.

     <p><var>userdata</var>: void pointer that will be passed to sign callback.

     <p><strong> Description:</strong> Set the callback function.  The function must have this prototype:

     <p>typedef int (*gnutls_sign_func) (gnutls_session_t session,
void *userdata,
gnutls_certificate_type_t cert_type,
const gnutls_datum_t * cert,
const gnutls_datum_t * hash,
gnutls_datum_t * signature);

     <p>The  <code>userdata</code>parameter is passed to the  <code>sign_func</code>verbatim, and
can be used to store application-specific data needed in the
callback function.  See also <code>gnutls_sign_callback_get()</code>.

     <p><strong> Deprecated:</strong> Use the PKCS 11 or <code>gnutls_privkey_t</code> interfacess like <code>gnutls_privkey_import_ext()</code> instead. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crl_sign</h4>

<p><a name="gnutls_005fx509_005fcrl_005fsign"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crl_sign</b> (<var>gnutls_x509_crl_t crl, gnutls_x509_crt_t issuer, gnutls_x509_privkey_t issuer_key</var>)<var><a name="index-gnutls_005fx509_005fcrl_005fsign-730"></a></var><br>
<blockquote><p><var>crl</var>: should contain a gnutls_x509_crl_t structure

     <p><var>issuer</var>: is the certificate of the certificate issuer

     <p><var>issuer_key</var>: holds the issuer's private key

     <p><strong> Description:</strong> This function is the same a <code>gnutls_x509_crl_sign2()</code> with no flags, and
SHA1 as the hash algorithm.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Deprecated:</strong> Use <code>gnutls_x509_crl_privkey_sign()</code>. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crq_sign</h4>

<p><a name="gnutls_005fx509_005fcrq_005fsign"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crq_sign</b> (<var>gnutls_x509_crq_t crq, gnutls_x509_privkey_t key</var>)<var><a name="index-gnutls_005fx509_005fcrq_005fsign-731"></a></var><br>
<blockquote><p><var>crq</var>: should contain a <code>gnutls_x509_crq_t</code> structure

     <p><var>key</var>: holds a private key

     <p><strong> Description:</strong> This function is the same a <code>gnutls_x509_crq_sign2()</code> with no flags,
and SHA1 as the hash algorithm.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Deprecated:</strong> Use <code>gnutls_x509_crq_privkey_sign()</code> instead. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_preferred_hash_algorithm</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fpreferred_005fhash_005falgorithm"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_preferred_hash_algorithm</b> (<var>gnutls_x509_crt_t crt, gnutls_digest_algorithm_t * hash, unsigned int * mand</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fpreferred_005fhash_005falgorithm-732"></a></var><br>
<blockquote><p><var>crt</var>: Holds the certificate

     <p><var>hash</var>: The result of the call with the hash algorithm used for signature

     <p><var>mand</var>: If non (0) it means that the algorithm MUST use this hash. May be NULL.

     <p><strong> Description:</strong> This function will read the certifcate and return the appropriate digest
algorithm to use for signing with this certificate. Some certificates (i.e. 
DSA might not be able to sign without the preferred algorithm).

     <p><strong> Deprecated:</strong> Please use <code>gnutls_pubkey_get_preferred_hash_algorithm()</code>.

     <p><strong> Returns:</strong> the 0 if the hash algorithm is found. A negative error code is
returned on error.

     <p><strong> Since:</strong> 2.12.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_get_verify_algorithm</h4>

<p><a name="gnutls_005fx509_005fcrt_005fget_005fverify_005falgorithm"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_get_verify_algorithm</b> (<var>gnutls_x509_crt_t crt, const gnutls_datum_t * signature, gnutls_digest_algorithm_t * hash</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fget_005fverify_005falgorithm-733"></a></var><br>
<blockquote><p><var>crt</var>: Holds the certificate

     <p><var>signature</var>: contains the signature

     <p><var>hash</var>: The result of the call with the hash algorithm used for signature

     <p><strong> Description:</strong> This function will read the certifcate and the signed data to
determine the hash algorithm used to generate the signature.

     <p><strong> Deprecated:</strong> Use <code>gnutls_pubkey_get_verify_algorithm()</code> instead.

     <p><strong> Returns:</strong> the 0 if the hash algorithm is found. A negative error code is
returned on error.

     <p><strong> Since:</strong> 2.8.0
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_verify_data</h4>

<p><a name="gnutls_005fx509_005fcrt_005fverify_005fdata"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_verify_data</b> (<var>gnutls_x509_crt_t crt, unsigned int flags, const gnutls_datum_t * data, const gnutls_datum_t * signature</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fverify_005fdata-734"></a></var><br>
<blockquote><p><var>crt</var>: Holds the certificate

     <p><var>flags</var>: should be 0 for now

     <p><var>data</var>: holds the data to be signed

     <p><var>signature</var>: contains the signature

     <p><strong> Description:</strong> This function will verify the given signed data, using the
parameters from the certificate.

     <p>Deprecated. Please use <code>gnutls_pubkey_verify_data()</code>.

     <p><strong> Returns:</strong> In case of a verification failure <code>GNUTLS_E_PK_SIG_VERIFY_FAILED</code>
is returned, and a positive code on success. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_crt_verify_hash</h4>

<p><a name="gnutls_005fx509_005fcrt_005fverify_005fhash"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_crt_verify_hash</b> (<var>gnutls_x509_crt_t crt, unsigned int flags, const gnutls_datum_t * hash, const gnutls_datum_t * signature</var>)<var><a name="index-gnutls_005fx509_005fcrt_005fverify_005fhash-735"></a></var><br>
<blockquote><p><var>crt</var>: Holds the certificate

     <p><var>flags</var>: should be 0 for now

     <p><var>hash</var>: holds the hash digest to be verified

     <p><var>signature</var>: contains the signature

     <p><strong> Description:</strong> This function will verify the given signed digest, using the
parameters from the certificate.

     <p>Deprecated. Please use <code>gnutls_pubkey_verify_data()</code>.

     <p><strong> Returns:</strong> In case of a verification failure <code>GNUTLS_E_PK_SIG_VERIFY_FAILED</code>
is returned, and a positive code on success. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_privkey_sign_data</h4>

<p><a name="gnutls_005fx509_005fprivkey_005fsign_005fdata"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_privkey_sign_data</b> (<var>gnutls_x509_privkey_t key, gnutls_digest_algorithm_t digest, unsigned int flags, const gnutls_datum_t * data, void * signature, size_t * signature_size</var>)<var><a name="index-gnutls_005fx509_005fprivkey_005fsign_005fdata-736"></a></var><br>
<blockquote><p><var>key</var>: Holds the key

     <p><var>digest</var>: should be MD5 or SHA1

     <p><var>flags</var>: should be 0 for now

     <p><var>data</var>: holds the data to be signed

     <p><var>signature</var>: will contain the signature

     <p><var>signature_size</var>: holds the size of signature (and will be replaced
by the new size)

     <p><strong> Description:</strong> This function will sign the given data using a signature algorithm
supported by the private key. Signature algorithms are always used
together with a hash functions.  Different hash functions may be
used for the RSA algorithm, but only SHA-1 for the DSA keys.

     <p>If the buffer provided is not long enough to hold the output, then
* <code>signature_size</code>is updated and <code>GNUTLS_E_SHORT_MEMORY_BUFFER</code> will
be returned.

     <p>Use <code>gnutls_x509_crt_get_preferred_hash_algorithm()</code> to determine
the hash algorithm.

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Deprecated:</strong> Use <code>gnutls_privkey_sign_data()</code>. 
</p></blockquote></div>

<h4 class="subheading">gnutls_x509_privkey_sign_hash</h4>

<p><a name="gnutls_005fx509_005fprivkey_005fsign_005fhash"></a>

<div class="defun">
&mdash; Function: int <b>gnutls_x509_privkey_sign_hash</b> (<var>gnutls_x509_privkey_t key, const gnutls_datum_t * hash, gnutls_datum_t * signature</var>)<var><a name="index-gnutls_005fx509_005fprivkey_005fsign_005fhash-737"></a></var><br>
<blockquote><p><var>key</var>: Holds the key

     <p><var>hash</var>: holds the data to be signed

     <p><var>signature</var>: will contain newly allocated signature

     <p><strong> Description:</strong> This function will sign the given hash using the private key. Do not
use this function directly unless you know what it is. Typical signing
requires the data to be hashed and stored in special formats
(e.g. BER Digest-Info for RSA).

     <p><strong> Returns:</strong> On success, <code>GNUTLS_E_SUCCESS</code> (0) is returned, otherwise a
negative error value.

     <p><strong> Deprecated in:</strong> 2.12.0
</p></blockquote></div>

<div class="node">
<a name="Supported-ciphersuites-in-GnuTLS"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Copying-Information">Copying Information</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#API-reference">API reference</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix D Supported Ciphersuites in <acronym>GnuTLS</acronym></h2>

<p><a name="ciphersuites"></a><a name="index-ciphersuites-738"></a>

<p>Available cipher suites:
<p><table summary=""><tr align="left"><td valign="top" width="60%">TLS_DH_ANON_ARCFOUR_MD5
</td><td valign="top" width="20%">0x00 0x18
</td><td valign="top" width="20%">SSL3.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DH_ANON_3DES_EDE_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x1B
</td><td valign="top" width="20%">SSL3.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DH_ANON_AES_128_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x34
</td><td valign="top" width="20%">SSL3.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DH_ANON_AES_256_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x3A
</td><td valign="top" width="20%">SSL3.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DH_ANON_CAMELLIA_128_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x46
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DH_ANON_CAMELLIA_256_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x89
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DH_ANON_AES_128_CBC_SHA256
</td><td valign="top" width="20%">0x00 0x6C
</td><td valign="top" width="20%">TLS1.2
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DH_ANON_AES_256_CBC_SHA256
</td><td valign="top" width="20%">0x00 0x6D
</td><td valign="top" width="20%">TLS1.2
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_PSK_SHA_ARCFOUR_SHA1
</td><td valign="top" width="20%">0x00 0x8A
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_PSK_SHA_3DES_EDE_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x8B
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_PSK_SHA_AES_128_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x8C
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_PSK_SHA_AES_256_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x8D
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_PSK_AES_128_CBC_SHA256
</td><td valign="top" width="20%">0x00 0xAE
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_PSK_AES_128_GCM_SHA256
</td><td valign="top" width="20%">0x00 0xA8
</td><td valign="top" width="20%">TLS1.2
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_PSK_NULL_SHA256
</td><td valign="top" width="20%">0x00 0xB0
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DHE_PSK_SHA_ARCFOUR_SHA1
</td><td valign="top" width="20%">0x00 0x8E
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DHE_PSK_SHA_3DES_EDE_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x8F
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DHE_PSK_SHA_AES_128_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x90
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DHE_PSK_SHA_AES_256_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x91
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DHE_PSK_AES_128_CBC_SHA256
</td><td valign="top" width="20%">0x00 0xB2
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DHE_PSK_AES_128_GCM_SHA256
</td><td valign="top" width="20%">0x00 0xAA
</td><td valign="top" width="20%">TLS1.2
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DHE_PSK_NULL_SHA256
</td><td valign="top" width="20%">0x00 0xB4
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_SRP_SHA_3DES_EDE_CBC_SHA1
</td><td valign="top" width="20%">0xC0 0x1A
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_SRP_SHA_AES_128_CBC_SHA1
</td><td valign="top" width="20%">0xC0 0x1D
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_SRP_SHA_AES_256_CBC_SHA1
</td><td valign="top" width="20%">0xC0 0x20
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_SRP_SHA_DSS_3DES_EDE_CBC_SHA1
</td><td valign="top" width="20%">0xC0 0x1C
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_SRP_SHA_RSA_3DES_EDE_CBC_SHA1
</td><td valign="top" width="20%">0xC0 0x1B
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_SRP_SHA_DSS_AES_128_CBC_SHA1
</td><td valign="top" width="20%">0xC0 0x1F
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_SRP_SHA_RSA_AES_128_CBC_SHA1
</td><td valign="top" width="20%">0xC0 0x1E
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_SRP_SHA_DSS_AES_256_CBC_SHA1
</td><td valign="top" width="20%">0xC0 0x22
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_SRP_SHA_RSA_AES_256_CBC_SHA1
</td><td valign="top" width="20%">0xC0 0x21
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DHE_DSS_ARCFOUR_SHA1
</td><td valign="top" width="20%">0x00 0x66
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DHE_DSS_3DES_EDE_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x13
</td><td valign="top" width="20%">SSL3.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DHE_DSS_AES_128_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x32
</td><td valign="top" width="20%">SSL3.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DHE_DSS_AES_256_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x38
</td><td valign="top" width="20%">SSL3.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DHE_DSS_CAMELLIA_128_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x44
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DHE_DSS_CAMELLIA_256_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x87
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DHE_DSS_AES_128_CBC_SHA256
</td><td valign="top" width="20%">0x00 0x40
</td><td valign="top" width="20%">TLS1.2
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DHE_DSS_AES_256_CBC_SHA256
</td><td valign="top" width="20%">0x00 0x6A
</td><td valign="top" width="20%">TLS1.2
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DHE_RSA_3DES_EDE_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x16
</td><td valign="top" width="20%">SSL3.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DHE_RSA_AES_128_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x33
</td><td valign="top" width="20%">SSL3.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DHE_RSA_AES_256_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x39
</td><td valign="top" width="20%">SSL3.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DHE_RSA_CAMELLIA_128_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x45
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DHE_RSA_CAMELLIA_256_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x88
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DHE_RSA_AES_128_CBC_SHA256
</td><td valign="top" width="20%">0x00 0x67
</td><td valign="top" width="20%">TLS1.2
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DHE_RSA_AES_256_CBC_SHA256
</td><td valign="top" width="20%">0x00 0x6B
</td><td valign="top" width="20%">TLS1.2
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_RSA_NULL_MD5
</td><td valign="top" width="20%">0x00 0x01
</td><td valign="top" width="20%">SSL3.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_RSA_NULL_SHA1
</td><td valign="top" width="20%">0x00 0x02
</td><td valign="top" width="20%">SSL3.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_RSA_NULL_SHA256
</td><td valign="top" width="20%">0x00 0x3B
</td><td valign="top" width="20%">TLS1.2
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_RSA_EXPORT_ARCFOUR_40_MD5
</td><td valign="top" width="20%">0x00 0x03
</td><td valign="top" width="20%">SSL3.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_RSA_ARCFOUR_SHA1
</td><td valign="top" width="20%">0x00 0x05
</td><td valign="top" width="20%">SSL3.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_RSA_ARCFOUR_MD5
</td><td valign="top" width="20%">0x00 0x04
</td><td valign="top" width="20%">SSL3.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_RSA_3DES_EDE_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x0A
</td><td valign="top" width="20%">SSL3.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_RSA_AES_128_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x2F
</td><td valign="top" width="20%">SSL3.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_RSA_AES_256_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x35
</td><td valign="top" width="20%">SSL3.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_RSA_CAMELLIA_128_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x41
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_RSA_CAMELLIA_256_CBC_SHA1
</td><td valign="top" width="20%">0x00 0x84
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_RSA_AES_128_CBC_SHA256
</td><td valign="top" width="20%">0x00 0x3C
</td><td valign="top" width="20%">TLS1.2
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_RSA_AES_256_CBC_SHA256
</td><td valign="top" width="20%">0x00 0x3D
</td><td valign="top" width="20%">TLS1.2
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_RSA_AES_128_GCM_SHA256
</td><td valign="top" width="20%">0x00 0x9C
</td><td valign="top" width="20%">TLS1.2
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DHE_RSA_AES_128_GCM_SHA256
</td><td valign="top" width="20%">0x00 0x9E
</td><td valign="top" width="20%">TLS1.2
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DHE_DSS_AES_128_GCM_SHA256
</td><td valign="top" width="20%">0x00 0xA2
</td><td valign="top" width="20%">TLS1.2
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_DH_ANON_AES_128_GCM_SHA256
</td><td valign="top" width="20%">0x00 0xA6
</td><td valign="top" width="20%">TLS1.2
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDH_ANON_NULL_SHA
</td><td valign="top" width="20%">0xC0 0x15
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDH_ANON_3DES_EDE_CBC_SHA
</td><td valign="top" width="20%">0xC0 0x17
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDH_ANON_AES_128_CBC_SHA
</td><td valign="top" width="20%">0xC0 0x18
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDH_ANON_AES_256_CBC_SHA
</td><td valign="top" width="20%">0xC0 0x19
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDHE_RSA_NULL_SHA
</td><td valign="top" width="20%">0xC0 0x10
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDHE_RSA_3DES_EDE_CBC_SHA
</td><td valign="top" width="20%">0xC0 0x12
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDHE_RSA_AES_128_CBC_SHA
</td><td valign="top" width="20%">0xC0 0x13
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDHE_RSA_AES_256_CBC_SHA
</td><td valign="top" width="20%">0xC0 0x14
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDHE_ECDSA_NULL_SHA
</td><td valign="top" width="20%">0xC0 0x06
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDHE_ECDSA_3DES_EDE_CBC_SHA
</td><td valign="top" width="20%">0xC0 0x08
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDHE_ECDSA_AES_128_CBC_SHA
</td><td valign="top" width="20%">0xC0 0x09
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDHE_ECDSA_AES_256_CBC_SHA
</td><td valign="top" width="20%">0xC0 0x0A
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDHE_ECDSA_AES_128_CBC_SHA256
</td><td valign="top" width="20%">0xC0 0x23
</td><td valign="top" width="20%">TLS1.2
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDHE_RSA_AES_128_CBC_SHA256
</td><td valign="top" width="20%">0xC0 0x27
</td><td valign="top" width="20%">TLS1.2
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDHE_ECDSA_AES_128_GCM_SHA256
</td><td valign="top" width="20%">0xC0 0x2B
</td><td valign="top" width="20%">TLS1.2
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDHE_RSA_AES_128_GCM_SHA256
</td><td valign="top" width="20%">0xC0 0x2F
</td><td valign="top" width="20%">TLS1.2
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDHE_PSK_3DES_EDE_CBC_SHA
</td><td valign="top" width="20%">0xC0 0x34
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDHE_PSK_AES_128_CBC_SHA
</td><td valign="top" width="20%">0xC0 0x35
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDHE_PSK_AES_256_CBC_SHA
</td><td valign="top" width="20%">0xC0 0x36
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDHE_PSK_AES_128_CBC_SHA256
</td><td valign="top" width="20%">0xC0 0x37
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDHE_PSK_AES_256_CBC_SHA384
</td><td valign="top" width="20%">0xC0 0x38
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDHE_PSK_NULL_SHA256
</td><td valign="top" width="20%">0xC0 0x3A
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDHE_PSK_NULL_SHA384
</td><td valign="top" width="20%">0xC0 0x3B
</td><td valign="top" width="20%">TLS1.0
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDHE_ECDSA_AES_256_GCM_SHA384
</td><td valign="top" width="20%">0xC0 0x2E
</td><td valign="top" width="20%">TLS1.2
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDHE_RSA_AES_256_GCM_SHA384
</td><td valign="top" width="20%">0xC0 0x30
</td><td valign="top" width="20%">TLS1.2
<br></td></tr><tr align="left"><td valign="top" width="60%">TLS_ECDHE_ECDSA_AES_256_CBC_SHA384
</td><td valign="top" width="20%">0xC0 0x24
</td><td valign="top" width="20%">TLS1.2
<br></td></tr></table>

<p>Available certificate types:
     <ul>
<li>X.509
<li>OPENPGP
</ul>

<p>Available protocols:
     <ul>
<li>SSL3.0
<li>TLS1.0
<li>TLS1.1
<li>TLS1.2
<li>DTLS1.0
</ul>

<p>Available ciphers:
     <ul>
<li>AES-256-CBC
<li>AES-192-CBC
<li>AES-128-CBC
<li>AES-128-GCM
<li>AES-256-GCM
<li>3DES-CBC
<li>DES-CBC
<li>ARCFOUR-128
<li>ARCFOUR-40
<li>RC2-40
<li>CAMELLIA-256-CBC
<li>CAMELLIA-128-CBC
<li>IDEA-PGP-CFB
<li>3DES-PGP-CFB
<li>CAST5-PGP-CFB
<li>BLOWFISH-PGP-CFB
<li>SAFER-SK128-PGP-CFB
<li>AES-128-PGP-CFB
<li>AES-192-PGP-CFB
<li>AES-256-PGP-CFB
<li>TWOFISH-PGP-CFB
<li>NULL
</ul>

<p>Available MAC algorithms:
     <ul>
<li>SHA1
<li>MD5
<li>SHA256
<li>SHA384
<li>SHA512
<li>SHA224
<li>AEAD
<li>MD2
<li>RIPEMD160
<li>MAC-NULL
</ul>

<p>Available key exchange methods:
     <ul>
<li>ANON-DH
<li>ANON-ECDH
<li>RSA
<li>RSA-EXPORT
<li>DHE-RSA
<li>ECDHE-RSA
<li>ECDHE-ECDSA
<li>DHE-DSS
<li>SRP-DSS
<li>SRP-RSA
<li>SRP
<li>PSK
<li>DHE-PSK
<li>ECDHE-PSK
</ul>

<p>Available public key algorithms:
     <ul>
<li>RSA
<li>DSA
<li>ECC
</ul>

<p>Available public key signature algorithms:
     <ul>
<li>RSA-SHA1
<li>RSA-SHA224
<li>RSA-SHA256
<li>RSA-SHA384
<li>RSA-SHA512
<li>RSA-RMD160
<li>DSA-SHA1
<li>DSA-SHA224
<li>DSA-SHA256
<li>RSA-MD5
<li>RSA-MD2
<li>ECDSA-SHA1
<li>ECDSA-SHA224
<li>ECDSA-SHA256
<li>ECDSA-SHA384
<li>ECDSA-SHA512
</ul>

<p>Available compression methods:
     <ul>
<li>DEFLATE
<li>NULL
</ul>

<div class="node">
<a name="Copying-Information"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Concept-Index">Concept Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Supported-ciphersuites-in-GnuTLS">Supported ciphersuites in GnuTLS</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix E Copying Information</h2>

<ul class="menu">
<li><a accesskey="1" href="#GNU-Free-Documentation-License">GNU Free Documentation License</a>:    License for copying this manual. 
</ul>

<div class="node">
<a name="GNU-Free-Documentation-License"></a>
<p><hr>
Up:&nbsp;<a rel="up" accesskey="u" href="#Copying-Information">Copying Information</a>

</div>

<h3 class="appendixsec">E.1 GNU Free Documentation License</h3>

<p><a name="index-FDL_002c-GNU-Free-Documentation-License-739"></a>

<!-- The GNU Free Documentation License. -->
<div align="center">Version 1.3, 3 November 2008</div>

<!-- This file is intended to be included within another document, -->
<!-- hence no sectioning command or @node. -->
<pre class="display">     Copyright &copy; 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
     <a href="http://fsf.org/">http://fsf.org/</a>
     
     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.
</pre>
     <ol type=1 start=0>
<li>PREAMBLE

     <p>The purpose of this License is to make a manual, textbook, or other
functional and useful document <dfn>free</dfn> in the sense of freedom: to
assure everyone the effective freedom to copy and redistribute it,
with or without modifying it, either commercially or noncommercially. 
Secondarily, this License preserves for the author and publisher a way
to get credit for their work, while not being considered responsible
for modifications made by others.

     <p>This License is a kind of &ldquo;copyleft&rdquo;, which means that derivative
works of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyleft
license designed for free software.

     <p>We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does.  But this License is not limited to software manuals;
it can be used for any textual work, regardless of subject matter or
whether it is published as a printed book.  We recommend this License
principally for works whose purpose is instruction or reference.

     <li>APPLICABILITY AND DEFINITIONS

     <p>This License applies to any manual or other work, in any medium, that
contains a notice placed by the copyright holder saying it can be
distributed under the terms of this License.  Such a notice grants a
world-wide, royalty-free license, unlimited in duration, to use that
work under the conditions stated herein.  The &ldquo;Document&rdquo;, below,
refers to any such manual or work.  Any member of the public is a
licensee, and is addressed as &ldquo;you&rdquo;.  You accept the license if you
copy, modify or distribute the work in a way requiring permission
under copyright law.

     <p>A &ldquo;Modified Version&rdquo; of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.

     <p>A &ldquo;Secondary Section&rdquo; is a named appendix or a front-matter section
of the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document's overall
subject (or to related matters) and contains nothing that could fall
directly within that overall subject.  (Thus, if the Document is in
part a textbook of mathematics, a Secondary Section may not explain
any mathematics.)  The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding
them.

     <p>The &ldquo;Invariant Sections&rdquo; are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice
that says that the Document is released under this License.  If a
section does not fit the above definition of Secondary then it is not
allowed to be designated as Invariant.  The Document may contain zero
Invariant Sections.  If the Document does not identify any Invariant
Sections then there are none.

     <p>The &ldquo;Cover Texts&rdquo; are certain short passages of text that are listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License.  A Front-Cover Text may
be at most 5 words, and a Back-Cover Text may be at most 25 words.

     <p>A &ldquo;Transparent&rdquo; copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the
general public, that is suitable for revising the document
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or
for automatic translation to a variety of formats suitable for input
to text formatters.  A copy made in an otherwise Transparent file
format whose markup, or absence of markup, has been arranged to thwart
or discourage subsequent modification by readers is not Transparent. 
An image format is not Transparent if used for any substantial amount
of text.  A copy that is not &ldquo;Transparent&rdquo; is called &ldquo;Opaque&rdquo;.

     <p>Examples of suitable formats for Transparent copies include plain
ASCII without markup, Texinfo input format, LaTeX input
format, SGML or XML using a publicly available
DTD, and standard-conforming simple HTML,
PostScript or PDF designed for human modification.  Examples
of transparent image formats include PNG, XCF and
JPG.  Opaque formats include proprietary formats that can be
read and edited only by proprietary word processors, SGML or
XML for which the DTD and/or processing tools are
not generally available, and the machine-generated HTML,
PostScript or PDF produced by some word processors for
output purposes only.

     <p>The &ldquo;Title Page&rdquo; means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page.  For works in
formats which do not have any title page as such, &ldquo;Title Page&rdquo; means
the text near the most prominent appearance of the work's title,
preceding the beginning of the body of the text.

     <p>The &ldquo;publisher&rdquo; means any person or entity that distributes copies
of the Document to the public.

     <p>A section &ldquo;Entitled XYZ&rdquo; means a named subunit of the Document whose
title either is precisely XYZ or contains XYZ in parentheses following
text that translates XYZ in another language.  (Here XYZ stands for a
specific section name mentioned below, such as &ldquo;Acknowledgements&rdquo;,
&ldquo;Dedications&rdquo;, &ldquo;Endorsements&rdquo;, or &ldquo;History&rdquo;.)  To &ldquo;Preserve the Title&rdquo;
of such a section when you modify the Document means that it remains a
section &ldquo;Entitled XYZ&rdquo; according to this definition.

     <p>The Document may include Warranty Disclaimers next to the notice which
states that this License applies to the Document.  These Warranty
Disclaimers are considered to be included by reference in this
License, but only as regards disclaiming warranties: any other
implication that these Warranty Disclaimers may have is void and has
no effect on the meaning of this License.

     <li>VERBATIM COPYING

     <p>You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies
to the Document are reproduced in all copies, and that you add no other
conditions whatsoever to those of this License.  You may not use
technical measures to obstruct or control the reading or further
copying of the copies you make or distribute.  However, you may accept
compensation in exchange for copies.  If you distribute a large enough
number of copies you must also follow the conditions in section 3.

     <p>You may also lend copies, under the same conditions stated above, and
you may publicly display copies.

     <li>COPYING IN QUANTITY

     <p>If you publish printed copies (or copies in media that commonly have
printed covers) of the Document, numbering more than 100, and the
Document's license notice requires Cover Texts, you must enclose the
copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover.  Both covers must also clearly and legibly identify
you as the publisher of these copies.  The front cover must present
the full title with all words of the title equally prominent and
visible.  You may add other material on the covers in addition. 
Copying with changes limited to the covers, as long as they preserve
the title of the Document and satisfy these conditions, can be treated
as verbatim copying in other respects.

     <p>If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.

     <p>If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy
a computer-network location from which the general network-using
public has access to download using public-standard network protocols
a complete Transparent copy of the Document, free of added material. 
If you use the latter option, you must take reasonably prudent steps,
when you begin distribution of Opaque copies in quantity, to ensure
that this Transparent copy will remain thus accessible at the stated
location until at least one year after the last time you distribute an
Opaque copy (directly or through your agents or retailers) of that
edition to the public.

     <p>It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to give
them a chance to provide you with an updated version of the Document.

     <li>MODIFICATIONS

     <p>You may copy and distribute a Modified Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it.  In addition, you must do these things in the Modified Version:

          <ol type=A start=1>
<li>Use in the Title Page (and on the covers, if any) a title distinct
from that of the Document, and from those of previous versions
(which should, if there were any, be listed in the History section
of the Document).  You may use the same title as a previous version
if the original publisher of that version gives permission.

          <li>List on the Title Page, as authors, one or more persons or entities
responsible for authorship of the modifications in the Modified
Version, together with at least five of the principal authors of the
Document (all of its principal authors, if it has fewer than five),
unless they release you from this requirement.

          <li>State on the Title page the name of the publisher of the
Modified Version, as the publisher.

          <li>Preserve all the copyright notices of the Document.

          <li>Add an appropriate copyright notice for your modifications
adjacent to the other copyright notices.

          <li>Include, immediately after the copyright notices, a license notice
giving the public permission to use the Modified Version under the
terms of this License, in the form shown in the Addendum below.

          <li>Preserve in that license notice the full lists of Invariant Sections
and required Cover Texts given in the Document's license notice.

          <li>Include an unaltered copy of this License.

          <li>Preserve the section Entitled &ldquo;History&rdquo;, Preserve its Title, and add
to it an item stating at least the title, year, new authors, and
publisher of the Modified Version as given on the Title Page.  If
there is no section Entitled &ldquo;History&rdquo; in the Document, create one
stating the title, year, authors, and publisher of the Document as
given on its Title Page, then add an item describing the Modified
Version as stated in the previous sentence.

          <li>Preserve the network location, if any, given in the Document for
public access to a Transparent copy of the Document, and likewise
the network locations given in the Document for previous versions
it was based on.  These may be placed in the &ldquo;History&rdquo; section. 
You may omit a network location for a work that was published at
least four years before the Document itself, or if the original
publisher of the version it refers to gives permission.

          <li>For any section Entitled &ldquo;Acknowledgements&rdquo; or &ldquo;Dedications&rdquo;, Preserve
the Title of the section, and preserve in the section all the
substance and tone of each of the contributor acknowledgements and/or
dedications given therein.

          <li>Preserve all the Invariant Sections of the Document,
unaltered in their text and in their titles.  Section numbers
or the equivalent are not considered part of the section titles.

          <li>Delete any section Entitled &ldquo;Endorsements&rdquo;.  Such a section
may not be included in the Modified Version.

          <li>Do not retitle any existing section to be Entitled &ldquo;Endorsements&rdquo; or
to conflict in title with any Invariant Section.

          <li>Preserve any Warranty Disclaimers.
          </ol>

     <p>If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant.  To do this, add their titles to the
list of Invariant Sections in the Modified Version's license notice. 
These titles must be distinct from any other section titles.

     <p>You may add a section Entitled &ldquo;Endorsements&rdquo;, provided it contains
nothing but endorsements of your Modified Version by various
parties&mdash;for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.

     <p>You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version.  Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity.  If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.

     <p>The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.

     <li>COMBINING DOCUMENTS

     <p>You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice, and that you preserve all their Warranty Disclaimers.

     <p>The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number. 
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.

     <p>In the combination, you must combine any sections Entitled &ldquo;History&rdquo;
in the various original documents, forming one section Entitled
&ldquo;History&rdquo;; likewise combine any sections Entitled &ldquo;Acknowledgements&rdquo;,
and any sections Entitled &ldquo;Dedications&rdquo;.  You must delete all
sections Entitled &ldquo;Endorsements.&rdquo;

     <li>COLLECTIONS OF DOCUMENTS

     <p>You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in
the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.

     <p>You may extract a single document from such a collection, and distribute
it individually under this License, provided you insert a copy of this
License into the extracted document, and follow this License in all
other respects regarding verbatim copying of that document.

     <li>AGGREGATION WITH INDEPENDENT WORKS

     <p>A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, is called an &ldquo;aggregate&rdquo; if the copyright
resulting from the compilation is not used to limit the legal rights
of the compilation's users beyond what the individual works permit. 
When the Document is included in an aggregate, this License does not
apply to the other works in the aggregate which are not themselves
derivative works of the Document.

     <p>If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one half of
the entire aggregate, the Document's Cover Texts may be placed on
covers that bracket the Document within the aggregate, or the
electronic equivalent of covers if the Document is in electronic form. 
Otherwise they must appear on printed covers that bracket the whole
aggregate.

     <li>TRANSLATION

     <p>Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4. 
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections.  You may include a
translation of this License, and all the license notices in the
Document, and any Warranty Disclaimers, provided that you also include
the original English version of this License and the original versions
of those notices and disclaimers.  In case of a disagreement between
the translation and the original version of this License or a notice
or disclaimer, the original version will prevail.

     <p>If a section in the Document is Entitled &ldquo;Acknowledgements&rdquo;,
&ldquo;Dedications&rdquo;, or &ldquo;History&rdquo;, the requirement (section 4) to Preserve
its Title (section 1) will typically require changing the actual
title.

     <li>TERMINATION

     <p>You may not copy, modify, sublicense, or distribute the Document
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense, or distribute it is void, and
will automatically terminate your rights under this License.

     <p>However, if you cease all violation of this License, then your license
from a particular copyright holder is reinstated (a) provisionally,
unless and until the copyright holder explicitly and finally
terminates your license, and (b) permanently, if the copyright holder
fails to notify you of the violation by some reasonable means prior to
60 days after the cessation.

     <p>Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

     <p>Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, receipt of a copy of some or all of the same material does
not give you any rights to use it.

     <li>FUTURE REVISIONS OF THIS LICENSE

     <p>The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.  See
<a href="http://www.gnu.org/copyleft/">http://www.gnu.org/copyleft/</a>.

     <p>Each version of the License is given a distinguishing version number. 
If the Document specifies that a particular numbered version of this
License &ldquo;or any later version&rdquo; applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.  If the Document
specifies that a proxy can decide which future versions of this
License can be used, that proxy's public statement of acceptance of a
version permanently authorizes you to choose that version for the
Document.

     <li>RELICENSING

     <p>&ldquo;Massive Multiauthor Collaboration Site&rdquo; (or &ldquo;MMC Site&rdquo;) means any
World Wide Web server that publishes copyrightable works and also
provides prominent facilities for anybody to edit those works.  A
public wiki that anybody can edit is an example of such a server.  A
&ldquo;Massive Multiauthor Collaboration&rdquo; (or &ldquo;MMC&rdquo;) contained in the
site means any set of copyrightable works thus published on the MMC
site.

     <p>&ldquo;CC-BY-SA&rdquo; means the Creative Commons Attribution-Share Alike 3.0
license published by Creative Commons Corporation, a not-for-profit
corporation with a principal place of business in San Francisco,
California, as well as future copyleft versions of that license
published by that same organization.

     <p>&ldquo;Incorporate&rdquo; means to publish or republish a Document, in whole or
in part, as part of another Document.

     <p>An MMC is &ldquo;eligible for relicensing&rdquo; if it is licensed under this
License, and if all works that were first published under this License
somewhere other than this MMC, and subsequently incorporated in whole
or in part into the MMC, (1) had no cover texts or invariant sections,
and (2) were thus incorporated prior to November 1, 2008.

     <p>The operator of an MMC Site may republish an MMC contained in the site
under CC-BY-SA on the same site at any time before August 1, 2009,
provided the MMC is eligible for relicensing.

     </ol>

<h3 class="heading">ADDENDUM: How to use this License for your documents</h3>

<p>To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and
license notices just after the title page:

<pre class="smallexample">       Copyright (C)  <var>year</var>  <var>your name</var>.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.3
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.
</pre>
<p>If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
replace the &ldquo;with<small class="dots">...</small>Texts.&rdquo; line with this:

<pre class="smallexample">         with the Invariant Sections being <var>list their titles</var>, with
         the Front-Cover Texts being <var>list</var>, and with the Back-Cover Texts
         being <var>list</var>.
</pre>
<p>If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

<p>If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License,
to permit their use in free software.

<!-- Local Variables: -->
<!-- ispell-local-pdict: "ispell-dict" -->
<!-- End: -->
<div class="node">
<a name="Bibliography"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Function-and-Data-Index">Function and Data Index</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="unnumbered">Bibliography</h2>

     <dl>
<dt><a name="CBCATT"></a>[CBCATT]<dd>Bodo Moeller, "Security of CBC Ciphersuites in SSL/TLS: Problems and
Countermeasures", 2002, available from
<a href="http://www.openssl.org/~bodo/tls-cbc.txt">http://www.openssl.org/~bodo/tls-cbc.txt</a>.

     <br><dt><a name="GPGH"></a>[GPGH]<dd>Mike Ashley, "The GNU Privacy Handbook", 2002, available from
<a href="http://www.gnupg.org/gph/en/manual.pdf">http://www.gnupg.org/gph/en/manual.pdf</a>.

     <br><dt><a name="GUTPKI"></a>[GUTPKI]<dd>Peter Gutmann, "Everything you never wanted to know about PKI but were
forced to find out", Available from
<a href="http://www.cs.auckland.ac.nz/~pgut001/">http://www.cs.auckland.ac.nz/~pgut001/</a>.

     <br><dt><a name="NISTSP80057"></a>[NISTSP80057]<dd>NIST Special Publication 800-57, "Recommendation for Key Management -
Part 1: General (Revised)", March 2007, available from
<a href="http://csrc.nist.gov/publications/nistpubs/800-57/sp800-57-Part1-revised2_Mar08-2007.pdf">http://csrc.nist.gov/publications/nistpubs/800-57/sp800-57-Part1-revised2_Mar08-2007.pdf</a>.

     <br><dt><a name="RFC2246"></a>[RFC2246]<dd>Tim Dierks and Christopher Allen, "The TLS Protocol Version 1.0",
January 1999, Available from
<a href="http://www.ietf.org/rfc/rfc2246.txt">http://www.ietf.org/rfc/rfc2246.txt</a>.

     <br><dt><a name="RFC4346"></a>[RFC4346]<dd>Tim Dierks and Eric Rescorla, "The TLS Protocol Version 1.1", Match
2006, Available from <a href="http://www.ietf.org/rfc/rfc4346.txt">http://www.ietf.org/rfc/rfc4346.txt</a>.

     <br><dt><a name="RFC4347"></a>[RFC4347]<dd>Eric Rescorla and Nagendra Modadugu, "Datagram Transport Layer Security", April
2006, Available from <a href="http://www.ietf.org/rfc/rfc4347.txt">http://www.ietf.org/rfc/rfc4347.txt</a>.

     <br><dt><a name="RFC5246"></a>[RFC5246]<dd>Tim Dierks and Eric Rescorla, "The TLS Protocol Version 1.2", August
2008, Available from <a href="http://www.ietf.org/rfc/rfc5246.txt">http://www.ietf.org/rfc/rfc5246.txt</a>.

     <br><dt><a name="RFC2440"></a>[RFC2440]<dd>Jon Callas, Lutz Donnerhacke, Hal Finney and Rodney Thayer, "OpenPGP
Message Format", November 1998, Available from
<a href="http://www.ietf.org/rfc/rfc2440.txt">http://www.ietf.org/rfc/rfc2440.txt</a>.

     <br><dt><a name="RFC4880"></a>[RFC4880]<dd>Jon Callas, Lutz Donnerhacke, Hal Finney, David Shaw and Rodney
Thayer, "OpenPGP Message Format", November 2007, Available from
<a href="http://www.ietf.org/rfc/rfc4880.txt">http://www.ietf.org/rfc/rfc4880.txt</a>.

     <br><dt><a name="RFC4211"></a>[RFC4211]<dd>J. Schaad, "Internet X.509 Public Key Infrastructure Certificate
Request Message Format (CRMF)", September 2005, Available from
<a href="http://www.ietf.org/rfc/rfc4211.txt">http://www.ietf.org/rfc/rfc4211.txt</a>.

     <br><dt><a name="RFC2817"></a>[RFC2817]<dd>Rohit Khare and Scott Lawrence, "Upgrading to TLS Within HTTP/1.1",
May 2000, Available from <a href="http://www.ietf.org/rfc/rfc2817.txt">http://www.ietf.org/rfc/rfc2817.txt</a>

     <br><dt><a name="RFC2818"></a>[RFC2818]<dd>Eric Rescorla, "HTTP Over TLS", May 2000, Available from
<a href="http://www.ietf/rfc/rfc2818.txt">http://www.ietf/rfc/rfc2818.txt</a>.

     <br><dt><a name="RFC2945"></a>[RFC2945]<dd>Tom Wu, "The SRP Authentication and Key Exchange System", September
2000, Available from <a href="http://www.ietf.org/rfc/rfc2945.txt">http://www.ietf.org/rfc/rfc2945.txt</a>.

     <br><dt><a name="RFC2986"></a>[RFC2986]<dd>Magnus Nystrom and Burt Kaliski, "PKCS 10 v1.7: Certification Request
Syntax Specification", November 2000, Available from
<a href="http://www.ietf.org/rfc/rfc2986.txt">http://www.ietf.org/rfc/rfc2986.txt</a>.

     <br><dt><a name="PKIX"></a>[PKIX]<dd>D. Cooper, S. Santesson, S. Farrel, S. Boeyen, R. Housley, W. Polk,
"Internet X.509 Public Key Infrastructure Certificate and Certificate
Revocation List (CRL) Profile", May 2008, available from
<a href="http://www.ietf.org/rfc/rfc5280.txt">http://www.ietf.org/rfc/rfc5280.txt</a>.

     <br><dt><a name="RFC3749"></a>[RFC3749]<dd>Scott Hollenbeck, "Transport Layer Security Protocol Compression
Methods", May 2004, available from
<a href="http://www.ietf.org/rfc/rfc3749.txt">http://www.ietf.org/rfc/rfc3749.txt</a>.

     <br><dt><a name="RFC3820"></a>[RFC3820]<dd>Steven Tuecke, Von Welch, Doug Engert, Laura Pearlman, and Mary
Thompson, "Internet X.509 Public Key Infrastructure (PKI) Proxy
Certificate Profile", June 2004, available from
<a href="http://www.ietf.org/rfc/rfc3820">http://www.ietf.org/rfc/rfc3820</a>.

     <br><dt><a name="RFC5746"></a>[RFC5746]<dd>E. Rescorla, M. Ray, S. Dispensa, and N. Oskov, "Transport Layer
Security (TLS) Renegotiation Indication Extension", February 2010,
available from <a href="http://www.ietf.org/rfc/rfc5746">http://www.ietf.org/rfc/rfc5746</a>.

     <br><dt><a name="TLSTKT"></a>[TLSTKT]<dd>Joseph Salowey, Hao Zhou, Pasi Eronen, Hannes Tschofenig, "Transport
Layer Security (TLS) Session Resumption without Server-Side State",
January 2008, available from <a href="http://www.ietf.org/rfc/rfc5077">http://www.ietf.org/rfc/rfc5077</a>.

     <br><dt><a name="PKCS12"></a>[PKCS12]<dd>RSA Laboratories, "PKCS 12 v1.0: Personal Information Exchange
Syntax", June 1999, Available from <a href="http://www.rsa.com">http://www.rsa.com</a>.

     <br><dt><a name="PKCS11"></a>[PKCS11]<dd>RSA Laboratories, "PKCS #11 Base Functionality v2.30: Cryptoki  Draft 4",
July 2009, Available from <a href="http://www.rsa.com">http://www.rsa.com</a>.

     <br><dt><a name="RESCORLA"></a>[RESCORLA]<dd>Eric Rescorla, "SSL and TLS: Designing and Building Secure Systems",
2001

     <br><dt><a name="SELKEY"></a>[SELKEY]<dd>Arjen Lenstra and Eric Verheul, "Selecting Cryptographic Key Sizes",
2003, available from <a href="http://www.win.tue.nl/~klenstra/key.pdf">http://www.win.tue.nl/~klenstra/key.pdf</a>.

     <br><dt><a name="SSL3"></a>[SSL3]<dd>Alan Freier, Philip Karlton and Paul Kocher, "The Secure Sockets Layer (SSL) Protocol Version 3.0",
August 2011, Available from <a href="http://www.ietf.org/rfc/rfc6101.txt">http://www.ietf.org/rfc/rfc6101.txt</a>.

     <br><dt><a name="STEVENS"></a>[STEVENS]<dd>Richard Stevens, "UNIX Network Programming, Volume 1", Prentice Hall
PTR, January 1998

     <br><dt><a name="TLSEXT"></a>[TLSEXT]<dd>Simon Blake-Wilson, Magnus Nystrom, David Hopwood, Jan Mikkelsen and
Tim Wright, "Transport Layer Security (TLS) Extensions", June 2003,
Available from <a href="http://www.ietf.org/rfc/rfc3546.txt">http://www.ietf.org/rfc/rfc3546.txt</a>.

     <br><dt><a name="TLSPGP"></a>[TLSPGP]<dd>Nikos Mavrogiannopoulos, "Using OpenPGP keys for TLS authentication",
January 2011. Available from
<a href="http://www.ietf.org/rfc/rfc6091.txt">http://www.ietf.org/rfc/rfc6091.txt</a>.

     <br><dt><a name="TLSSRP"></a>[TLSSRP]<dd>David Taylor, Trevor Perrin, Tom Wu and Nikos Mavrogiannopoulos,
"Using SRP for TLS Authentication", November 2007. Available from
<a href="http://www.ietf.org/rfc/rfc5054.txt">http://www.ietf.org/rfc/rfc5054.txt</a>.

     <br><dt><a name="TLSPSK"></a>[TLSPSK]<dd>Pasi Eronen and Hannes Tschofenig, "Pre-shared key Ciphersuites for
TLS", December 2005, Available from
<a href="http://www.ietf.org/rfc/rfc4279.txt">http://www.ietf.org/rfc/rfc4279.txt</a>.

     <br><dt><a name="TOMSRP"></a>[TOMSRP]<dd>Tom Wu, "The Stanford SRP Authentication Project", Available at
<a href="http://srp.stanford.edu/">http://srp.stanford.edu/</a>.

     <br><dt><a name="WEGER"></a>[WEGER]<dd>Arjen Lenstra and Xiaoyun Wang and Benne de Weger, "Colliding X.509
Certificates", Cryptology ePrint Archive, Report 2005/067, Available
at <a href="http://eprint.iacr.org/">http://eprint.iacr.org/</a>.

     <br><dt><a name="ECRYPT"></a>[ECRYPT]<dd>European Network of Excellence in Cryptology II, "ECRYPT II Yearly
Report on Algorithms and Keysizes (2009-2010)", Available
at <a href="http://www.ecrypt.eu.org/documents/D.SPA.13.pdf">http://www.ecrypt.eu.org/documents/D.SPA.13.pdf</a>.

     <br><dt><a name="RFC5056"></a>[RFC5056]<dd>N. Williams, "On the Use of Channel Bindings to Secure Channels",
November 2007, available from <a href="http://www.ietf.org/rfc/rfc5056">http://www.ietf.org/rfc/rfc5056</a>.

     <br><dt><a name="RFC5929"></a>[RFC5929]<dd>J. Altman, N. Williams, L. Zhu, "Channel Bindings for TLS", July 2010,
available from <a href="http://www.ietf.org/rfc/rfc5929">http://www.ietf.org/rfc/rfc5929</a>.

     <br><dt><a name="PKCS11URI"></a>[PKCS11URI]<dd>J. Pechanec, D. Moffat, "The PKCS#11 URI Scheme", August 2011,
Work in progress, available from <a href="http://tools.ietf.org/html/draft-pechanec-pkcs11uri-05">http://tools.ietf.org/html/draft-pechanec-pkcs11uri-05</a>.

     <br><dt><a name="ANDERSON"></a>[ANDERSON]<dd>R. J. Anderson, "Security Engineering: A Guide to Building Dependable Distributed Systems",
John Wiley \&amp; Sons, Inc., 2001.

     <br><dt><a name="RFC4821"></a>[RFC4821]<dd>M. Mathis, J. Heffner, "Packetization Layer Path MTU Discovery", March 2007,
available from <a href="http://www.ietf.org/rfc/rfc4821.txt">http://www.ietf.org/rfc/rfc4821.txt</a>.

</dl>

<div class="node">
<a name="Function-and-Data-Index"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Bibliography">Bibliography</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Concept-Index">Concept Index</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="unnumbered">Function and Data Index</h2>

<ul class="index-fn" compact>
<li><a href="#index-gnutls_005falert_005fget-85"><code>gnutls_alert_get</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005falert_005fget_005fname-86"><code>gnutls_alert_get_name</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005falert_005fget_005fstrname-87"><code>gnutls_alert_get_strname</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005falert_005fsend-88"><code>gnutls_alert_send</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005falert_005fsend_005fappropriate-89"><code>gnutls_alert_send_appropriate</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fanon_005fallocate_005fclient_005fcredentials-90"><code>gnutls_anon_allocate_client_credentials</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fanon_005fallocate_005fserver_005fcredentials-91"><code>gnutls_anon_allocate_server_credentials</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fanon_005ffree_005fclient_005fcredentials-92"><code>gnutls_anon_free_client_credentials</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fanon_005ffree_005fserver_005fcredentials-93"><code>gnutls_anon_free_server_credentials</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fanon_005fset_005fparams_005ffunction-94"><code>gnutls_anon_set_params_function</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fanon_005fset_005fserver_005fdh_005fparams-95"><code>gnutls_anon_set_server_dh_params</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fanon_005fset_005fserver_005fparams_005ffunction-96"><code>gnutls_anon_set_server_params_function</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fauth_005fclient_005fget_005ftype-97"><code>gnutls_auth_client_get_type</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fauth_005fget_005ftype-98"><code>gnutls_auth_get_type</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fauth_005fserver_005fget_005ftype-99"><code>gnutls_auth_server_get_type</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fbye-100"><code>gnutls_bye</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005factivation_005ftime_005fpeers-101"><code>gnutls_certificate_activation_time_peers</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fallocate_005fcredentials-102"><code>gnutls_certificate_allocate_credentials</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fclient_005fget_005frequest_005fstatus-103"><code>gnutls_certificate_client_get_request_status</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fexpiration_005ftime_005fpeers-104"><code>gnutls_certificate_expiration_time_peers</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005ffree_005fca_005fnames-105"><code>gnutls_certificate_free_ca_names</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005ffree_005fcas-106"><code>gnutls_certificate_free_cas</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005ffree_005fcredentials-107"><code>gnutls_certificate_free_credentials</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005ffree_005fcrls-108"><code>gnutls_certificate_free_crls</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005ffree_005fkeys-109"><code>gnutls_certificate_free_keys</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fget_005fissuer-110"><code>gnutls_certificate_get_issuer</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fget_005fours-111"><code>gnutls_certificate_get_ours</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fget_005fpeers-112"><code>gnutls_certificate_get_peers</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fsend_005fx509_005frdn_005fsequence-113"><code>gnutls_certificate_send_x509_rdn_sequence</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fserver_005fset_005frequest-114"><code>gnutls_certificate_server_set_request</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fset_005fdh_005fparams-115"><code>gnutls_certificate_set_dh_params</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fset_005fkey-636"><code>gnutls_certificate_set_key</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fset_005fopenpgp_005fkey-511"><code>gnutls_certificate_set_openpgp_key</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fset_005fopenpgp_005fkey_005ffile-512"><code>gnutls_certificate_set_openpgp_key_file</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fset_005fopenpgp_005fkey_005ffile2-513"><code>gnutls_certificate_set_openpgp_key_file2</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fset_005fopenpgp_005fkey_005fmem-514"><code>gnutls_certificate_set_openpgp_key_mem</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fset_005fopenpgp_005fkey_005fmem2-515"><code>gnutls_certificate_set_openpgp_key_mem2</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fset_005fopenpgp_005fkeyring_005ffile-516"><code>gnutls_certificate_set_openpgp_keyring_file</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fset_005fopenpgp_005fkeyring_005fmem-517"><code>gnutls_certificate_set_openpgp_keyring_mem</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fset_005fparams_005ffunction-116"><code>gnutls_certificate_set_params_function</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fset_005fretrieve_005ffunction-117"><code>gnutls_certificate_set_retrieve_function</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fset_005frsa_005fexport_005fparams-709"><code>gnutls_certificate_set_rsa_export_params</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fset_005fverify_005fflags-118"><code>gnutls_certificate_set_verify_flags</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fset_005fverify_005ffunction-119"><code>gnutls_certificate_set_verify_function</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fset_005fverify_005flimits-120"><code>gnutls_certificate_set_verify_limits</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fset_005fx509_005fcrl-121"><code>gnutls_certificate_set_x509_crl</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fset_005fx509_005fcrl_005ffile-122"><code>gnutls_certificate_set_x509_crl_file</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fset_005fx509_005fcrl_005fmem-123"><code>gnutls_certificate_set_x509_crl_mem</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fset_005fx509_005fkey-124"><code>gnutls_certificate_set_x509_key</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fset_005fx509_005fkey_005ffile-125"><code>gnutls_certificate_set_x509_key_file</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fset_005fx509_005fkey_005fmem-126"><code>gnutls_certificate_set_x509_key_mem</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fset_005fx509_005ftrust-127"><code>gnutls_certificate_set_x509_trust</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fset_005fx509_005ftrust_005ffile-128"><code>gnutls_certificate_set_x509_trust_file</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fset_005fx509_005ftrust_005fmem-129"><code>gnutls_certificate_set_x509_trust_mem</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005ftype_005fget-130"><code>gnutls_certificate_type_get</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005ftype_005fget_005fid-131"><code>gnutls_certificate_type_get_id</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005ftype_005fget_005fname-132"><code>gnutls_certificate_type_get_name</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005ftype_005flist-133"><code>gnutls_certificate_type_list</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcertificate_005ftype_005fset_005fpriority-710"><code>gnutls_certificate_type_set_priority</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005fcertificate_005fverify_005fflags-32"><code>gnutls_certificate_verify_flags</code></a>: <a href="#Verifying-a-certificate-in-the-context-of-TLS-session">Verifying a certificate in the context of TLS session</a></li>
<li><a href="#index-gnutls_005fcertificate_005fverify_005fpeers2-134"><code>gnutls_certificate_verify_peers2</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcheck_005fversion-135"><code>gnutls_check_version</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcipher_005fadd_005fauth-686"><code>gnutls_cipher_add_auth</code></a>: <a href="#Cryptographic-API">Cryptographic API</a></li>
<li><a href="#index-gnutls_005fcipher_005fdecrypt-687"><code>gnutls_cipher_decrypt</code></a>: <a href="#Cryptographic-API">Cryptographic API</a></li>
<li><a href="#index-gnutls_005fcipher_005fdecrypt2-688"><code>gnutls_cipher_decrypt2</code></a>: <a href="#Cryptographic-API">Cryptographic API</a></li>
<li><a href="#index-gnutls_005fcipher_005fdeinit-689"><code>gnutls_cipher_deinit</code></a>: <a href="#Cryptographic-API">Cryptographic API</a></li>
<li><a href="#index-gnutls_005fcipher_005fencrypt-690"><code>gnutls_cipher_encrypt</code></a>: <a href="#Cryptographic-API">Cryptographic API</a></li>
<li><a href="#index-gnutls_005fcipher_005fencrypt2-691"><code>gnutls_cipher_encrypt2</code></a>: <a href="#Cryptographic-API">Cryptographic API</a></li>
<li><a href="#index-gnutls_005fcipher_005fget-136"><code>gnutls_cipher_get</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcipher_005fget_005fblock_005fsize-692"><code>gnutls_cipher_get_block_size</code></a>: <a href="#Cryptographic-API">Cryptographic API</a></li>
<li><a href="#index-gnutls_005fcipher_005fget_005fid-137"><code>gnutls_cipher_get_id</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcipher_005fget_005fkey_005fsize-138"><code>gnutls_cipher_get_key_size</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcipher_005fget_005fname-139"><code>gnutls_cipher_get_name</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcipher_005finit-693"><code>gnutls_cipher_init</code></a>: <a href="#Cryptographic-API">Cryptographic API</a></li>
<li><a href="#index-gnutls_005fcipher_005flist-140"><code>gnutls_cipher_list</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcipher_005fset_005fiv-694"><code>gnutls_cipher_set_iv</code></a>: <a href="#Cryptographic-API">Cryptographic API</a></li>
<li><a href="#index-gnutls_005fcipher_005fset_005fpriority-711"><code>gnutls_cipher_set_priority</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005fcipher_005fsuite_005fget_005fname-141"><code>gnutls_cipher_suite_get_name</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcipher_005fsuite_005finfo-142"><code>gnutls_cipher_suite_info</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcipher_005ftag-695"><code>gnutls_cipher_tag</code></a>: <a href="#Cryptographic-API">Cryptographic API</a></li>
<li><a href="#index-gnutls_005fcompression_005fget-143"><code>gnutls_compression_get</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcompression_005fget_005fid-144"><code>gnutls_compression_get_id</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcompression_005fget_005fname-145"><code>gnutls_compression_get_name</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcompression_005flist-146"><code>gnutls_compression_list</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcompression_005fset_005fpriority-712"><code>gnutls_compression_set_priority</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005fcredentials_005fclear-147"><code>gnutls_credentials_clear</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fcredentials_005fset-148"><code>gnutls_credentials_set</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fdb_005fcheck_005fentry-149"><code>gnutls_db_check_entry</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fdb_005fget_005fptr-150"><code>gnutls_db_get_ptr</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fdb_005fremove_005fsession-151"><code>gnutls_db_remove_session</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fdb_005fset_005fcache_005fexpiration-152"><code>gnutls_db_set_cache_expiration</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fdb_005fset_005fptr-153"><code>gnutls_db_set_ptr</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fdb_005fset_005fremove_005ffunction-154"><code>gnutls_db_set_remove_function</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fdb_005fset_005fretrieve_005ffunction-155"><code>gnutls_db_set_retrieve_function</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fdb_005fset_005fstore_005ffunction-156"><code>gnutls_db_set_store_function</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fdeinit-157"><code>gnutls_deinit</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fdh_005fget_005fgroup-158"><code>gnutls_dh_get_group</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fdh_005fget_005fpeers_005fpublic_005fbits-159"><code>gnutls_dh_get_peers_public_bits</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fdh_005fget_005fprime_005fbits-160"><code>gnutls_dh_get_prime_bits</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fdh_005fget_005fpubkey-161"><code>gnutls_dh_get_pubkey</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fdh_005fget_005fsecret_005fbits-162"><code>gnutls_dh_get_secret_bits</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fdh_005fparams_005fcpy-163"><code>gnutls_dh_params_cpy</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fdh_005fparams_005fdeinit-164"><code>gnutls_dh_params_deinit</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fdh_005fparams_005fexport_005fpkcs3-165"><code>gnutls_dh_params_export_pkcs3</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fdh_005fparams_005fexport_005fraw-166"><code>gnutls_dh_params_export_raw</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fdh_005fparams_005fgenerate2-167"><code>gnutls_dh_params_generate2</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fdh_005fparams_005fimport_005fpkcs3-168"><code>gnutls_dh_params_import_pkcs3</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fdh_005fparams_005fimport_005fraw-169"><code>gnutls_dh_params_import_raw</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fdh_005fparams_005finit-170"><code>gnutls_dh_params_init</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fdh_005fset_005fprime_005fbits-171"><code>gnutls_dh_set_prime_bits</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fdtls_005fcookie_005fsend-301"><code>gnutls_dtls_cookie_send</code></a>: <a href="#Datagram-TLS-API">Datagram TLS API</a></li>
<li><a href="#index-gnutls_005fdtls_005fcookie_005fverify-302"><code>gnutls_dtls_cookie_verify</code></a>: <a href="#Datagram-TLS-API">Datagram TLS API</a></li>
<li><a href="#index-gnutls_005fdtls_005fget_005fdata_005fmtu-303"><code>gnutls_dtls_get_data_mtu</code></a>: <a href="#Datagram-TLS-API">Datagram TLS API</a></li>
<li><a href="#index-gnutls_005fdtls_005fget_005fmtu-304"><code>gnutls_dtls_get_mtu</code></a>: <a href="#Datagram-TLS-API">Datagram TLS API</a></li>
<li><a href="#index-gnutls_005fdtls_005fprestate_005fset-305"><code>gnutls_dtls_prestate_set</code></a>: <a href="#Datagram-TLS-API">Datagram TLS API</a></li>
<li><a href="#index-gnutls_005fdtls_005fset_005fmtu-306"><code>gnutls_dtls_set_mtu</code></a>: <a href="#Datagram-TLS-API">Datagram TLS API</a></li>
<li><a href="#index-gnutls_005fdtls_005fset_005ftimeouts-307"><code>gnutls_dtls_set_timeouts</code></a>: <a href="#Datagram-TLS-API">Datagram TLS API</a></li>
<li><a href="#index-gnutls_005fecc_005fcurve_005fget-172"><code>gnutls_ecc_curve_get</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fecc_005fcurve_005fget_005fname-173"><code>gnutls_ecc_curve_get_name</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fecc_005fcurve_005fget_005fsize-174"><code>gnutls_ecc_curve_get_size</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005ferror_005fis_005ffatal-175"><code>gnutls_error_is_fatal</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005ferror_005fto_005falert-176"><code>gnutls_error_to_alert</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005ffingerprint-177"><code>gnutls_fingerprint</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fglobal_005fdeinit-178"><code>gnutls_global_deinit</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fglobal_005finit-179"><code>gnutls_global_init</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fglobal_005fset_005faudit_005flog_005ffunction-180"><code>gnutls_global_set_audit_log_function</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fglobal_005fset_005flog_005ffunction-181"><code>gnutls_global_set_log_function</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fglobal_005fset_005flog_005flevel-182"><code>gnutls_global_set_log_level</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fglobal_005fset_005fmem_005ffunctions-183"><code>gnutls_global_set_mem_functions</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fglobal_005fset_005fmutex-184"><code>gnutls_global_set_mutex</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fglobal_005fset_005ftime_005ffunction-185"><code>gnutls_global_set_time_function</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fhandshake-186"><code>gnutls_handshake</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fhandshake_005fget_005flast_005fin-187"><code>gnutls_handshake_get_last_in</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fhandshake_005fget_005flast_005fout-188"><code>gnutls_handshake_get_last_out</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fhandshake_005fset_005fmax_005fpacket_005flength-189"><code>gnutls_handshake_set_max_packet_length</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fhandshake_005fset_005fpost_005fclient_005fhello_005ffunction-190"><code>gnutls_handshake_set_post_client_hello_function</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fhandshake_005fset_005fprivate_005fextensions-191"><code>gnutls_handshake_set_private_extensions</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fhash-696"><code>gnutls_hash</code></a>: <a href="#Cryptographic-API">Cryptographic API</a></li>
<li><a href="#index-gnutls_005fhash_005fdeinit-697"><code>gnutls_hash_deinit</code></a>: <a href="#Cryptographic-API">Cryptographic API</a></li>
<li><a href="#index-gnutls_005fhash_005ffast-698"><code>gnutls_hash_fast</code></a>: <a href="#Cryptographic-API">Cryptographic API</a></li>
<li><a href="#index-gnutls_005fhash_005fget_005flen-699"><code>gnutls_hash_get_len</code></a>: <a href="#Cryptographic-API">Cryptographic API</a></li>
<li><a href="#index-gnutls_005fhash_005finit-700"><code>gnutls_hash_init</code></a>: <a href="#Cryptographic-API">Cryptographic API</a></li>
<li><a href="#index-gnutls_005fhash_005foutput-701"><code>gnutls_hash_output</code></a>: <a href="#Cryptographic-API">Cryptographic API</a></li>
<li><a href="#index-gnutls_005fhex2bin-192"><code>gnutls_hex2bin</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fhex_005fdecode-193"><code>gnutls_hex_decode</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fhex_005fencode-194"><code>gnutls_hex_encode</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fhmac-702"><code>gnutls_hmac</code></a>: <a href="#Cryptographic-API">Cryptographic API</a></li>
<li><a href="#index-gnutls_005fhmac_005fdeinit-703"><code>gnutls_hmac_deinit</code></a>: <a href="#Cryptographic-API">Cryptographic API</a></li>
<li><a href="#index-gnutls_005fhmac_005ffast-704"><code>gnutls_hmac_fast</code></a>: <a href="#Cryptographic-API">Cryptographic API</a></li>
<li><a href="#index-gnutls_005fhmac_005fget_005flen-705"><code>gnutls_hmac_get_len</code></a>: <a href="#Cryptographic-API">Cryptographic API</a></li>
<li><a href="#index-gnutls_005fhmac_005finit-706"><code>gnutls_hmac_init</code></a>: <a href="#Cryptographic-API">Cryptographic API</a></li>
<li><a href="#index-gnutls_005fhmac_005foutput-707"><code>gnutls_hmac_output</code></a>: <a href="#Cryptographic-API">Cryptographic API</a></li>
<li><a href="#index-gnutls_005finit-195"><code>gnutls_init</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fkey_005fgenerate-196"><code>gnutls_key_generate</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fkx_005fget-197"><code>gnutls_kx_get</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fkx_005fget_005fid-198"><code>gnutls_kx_get_id</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fkx_005fget_005fname-199"><code>gnutls_kx_get_name</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fkx_005flist-200"><code>gnutls_kx_list</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fkx_005fset_005fpriority-713"><code>gnutls_kx_set_priority</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005fmac_005fget-201"><code>gnutls_mac_get</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fmac_005fget_005fid-202"><code>gnutls_mac_get_id</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fmac_005fget_005fkey_005fsize-203"><code>gnutls_mac_get_key_size</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fmac_005fget_005fname-204"><code>gnutls_mac_get_name</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fmac_005flist-205"><code>gnutls_mac_list</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fmac_005fset_005fpriority-714"><code>gnutls_mac_set_priority</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fcheck_005fhostname-518"><code>gnutls_openpgp_crt_check_hostname</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fdeinit-519"><code>gnutls_openpgp_crt_deinit</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fexport-520"><code>gnutls_openpgp_crt_export</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fget_005fauth_005fsubkey-521"><code>gnutls_openpgp_crt_get_auth_subkey</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fget_005fcreation_005ftime-522"><code>gnutls_openpgp_crt_get_creation_time</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fget_005fexpiration_005ftime-523"><code>gnutls_openpgp_crt_get_expiration_time</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fget_005ffingerprint-524"><code>gnutls_openpgp_crt_get_fingerprint</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fget_005fkey_005fid-525"><code>gnutls_openpgp_crt_get_key_id</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fget_005fkey_005fusage-526"><code>gnutls_openpgp_crt_get_key_usage</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fget_005fname-527"><code>gnutls_openpgp_crt_get_name</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fget_005fpk_005falgorithm-528"><code>gnutls_openpgp_crt_get_pk_algorithm</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fget_005fpk_005fdsa_005fraw-529"><code>gnutls_openpgp_crt_get_pk_dsa_raw</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fget_005fpk_005frsa_005fraw-530"><code>gnutls_openpgp_crt_get_pk_rsa_raw</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fget_005fpreferred_005fkey_005fid-531"><code>gnutls_openpgp_crt_get_preferred_key_id</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fget_005frevoked_005fstatus-532"><code>gnutls_openpgp_crt_get_revoked_status</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fcount-533"><code>gnutls_openpgp_crt_get_subkey_count</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fcreation_005ftime-534"><code>gnutls_openpgp_crt_get_subkey_creation_time</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fexpiration_005ftime-535"><code>gnutls_openpgp_crt_get_subkey_expiration_time</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005ffingerprint-536"><code>gnutls_openpgp_crt_get_subkey_fingerprint</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fid-537"><code>gnutls_openpgp_crt_get_subkey_id</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fidx-538"><code>gnutls_openpgp_crt_get_subkey_idx</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fpk_005falgorithm-539"><code>gnutls_openpgp_crt_get_subkey_pk_algorithm</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fpk_005fdsa_005fraw-540"><code>gnutls_openpgp_crt_get_subkey_pk_dsa_raw</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fpk_005frsa_005fraw-541"><code>gnutls_openpgp_crt_get_subkey_pk_rsa_raw</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005frevoked_005fstatus-542"><code>gnutls_openpgp_crt_get_subkey_revoked_status</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fget_005fsubkey_005fusage-543"><code>gnutls_openpgp_crt_get_subkey_usage</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fget_005fversion-544"><code>gnutls_openpgp_crt_get_version</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fimport-545"><code>gnutls_openpgp_crt_import</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005finit-546"><code>gnutls_openpgp_crt_init</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fprint-547"><code>gnutls_openpgp_crt_print</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fset_005fpreferred_005fkey_005fid-548"><code>gnutls_openpgp_crt_set_preferred_key_id</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fverify_005fring-549"><code>gnutls_openpgp_crt_verify_ring</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fcrt_005fverify_005fself-550"><code>gnutls_openpgp_crt_verify_self</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fkeyring_005fcheck_005fid-551"><code>gnutls_openpgp_keyring_check_id</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fkeyring_005fdeinit-552"><code>gnutls_openpgp_keyring_deinit</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fkeyring_005fget_005fcrt-553"><code>gnutls_openpgp_keyring_get_crt</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fkeyring_005fget_005fcrt_005fcount-554"><code>gnutls_openpgp_keyring_get_crt_count</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fkeyring_005fimport-555"><code>gnutls_openpgp_keyring_import</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fkeyring_005finit-556"><code>gnutls_openpgp_keyring_init</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fprivkey_005fdeinit-557"><code>gnutls_openpgp_privkey_deinit</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fprivkey_005fexport-558"><code>gnutls_openpgp_privkey_export</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fprivkey_005fexport_005fdsa_005fraw-559"><code>gnutls_openpgp_privkey_export_dsa_raw</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fprivkey_005fexport_005frsa_005fraw-560"><code>gnutls_openpgp_privkey_export_rsa_raw</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fprivkey_005fexport_005fsubkey_005fdsa_005fraw-561"><code>gnutls_openpgp_privkey_export_subkey_dsa_raw</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fprivkey_005fexport_005fsubkey_005frsa_005fraw-562"><code>gnutls_openpgp_privkey_export_subkey_rsa_raw</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fprivkey_005fget_005ffingerprint-563"><code>gnutls_openpgp_privkey_get_fingerprint</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fprivkey_005fget_005fkey_005fid-564"><code>gnutls_openpgp_privkey_get_key_id</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fprivkey_005fget_005fpk_005falgorithm-565"><code>gnutls_openpgp_privkey_get_pk_algorithm</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fprivkey_005fget_005fpreferred_005fkey_005fid-566"><code>gnutls_openpgp_privkey_get_preferred_key_id</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fprivkey_005fget_005frevoked_005fstatus-567"><code>gnutls_openpgp_privkey_get_revoked_status</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fprivkey_005fget_005fsubkey_005fcount-568"><code>gnutls_openpgp_privkey_get_subkey_count</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fprivkey_005fget_005fsubkey_005fcreation_005ftime-569"><code>gnutls_openpgp_privkey_get_subkey_creation_time</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fprivkey_005fget_005fsubkey_005ffingerprint-570"><code>gnutls_openpgp_privkey_get_subkey_fingerprint</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fprivkey_005fget_005fsubkey_005fid-571"><code>gnutls_openpgp_privkey_get_subkey_id</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fprivkey_005fget_005fsubkey_005fidx-572"><code>gnutls_openpgp_privkey_get_subkey_idx</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fprivkey_005fget_005fsubkey_005fpk_005falgorithm-573"><code>gnutls_openpgp_privkey_get_subkey_pk_algorithm</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fprivkey_005fget_005fsubkey_005frevoked_005fstatus-574"><code>gnutls_openpgp_privkey_get_subkey_revoked_status</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fprivkey_005fimport-575"><code>gnutls_openpgp_privkey_import</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fprivkey_005finit-576"><code>gnutls_openpgp_privkey_init</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fprivkey_005fsec_005fparam-577"><code>gnutls_openpgp_privkey_sec_param</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fprivkey_005fset_005fpreferred_005fkey_005fid-578"><code>gnutls_openpgp_privkey_set_preferred_key_id</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fprivkey_005fsign_005fhash-715"><code>gnutls_openpgp_privkey_sign_hash</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fsend_005fcert-206"><code>gnutls_openpgp_send_cert</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fopenpgp_005fset_005frecv_005fkey_005ffunction-579"><code>gnutls_openpgp_set_recv_key_function</code></a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-gnutls_005fpcert_005fdeinit-637"><code>gnutls_pcert_deinit</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpcert_005fimport_005fopenpgp-638"><code>gnutls_pcert_import_openpgp</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpcert_005fimport_005fopenpgp_005fraw-639"><code>gnutls_pcert_import_openpgp_raw</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpcert_005fimport_005fx509-640"><code>gnutls_pcert_import_x509</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpcert_005fimport_005fx509_005fraw-641"><code>gnutls_pcert_import_x509_raw</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpcert_005flist_005fimport_005fx509_005fraw-642"><code>gnutls_pcert_list_import_x509_raw</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpem_005fbase64_005fdecode-207"><code>gnutls_pem_base64_decode</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpem_005fbase64_005fdecode_005falloc-208"><code>gnutls_pem_base64_decode_alloc</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpem_005fbase64_005fencode-209"><code>gnutls_pem_base64_encode</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpem_005fbase64_005fencode_005falloc-210"><code>gnutls_pem_base64_encode_alloc</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fperror-211"><code>gnutls_perror</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpk_005falgorithm_005fget_005fname-212"><code>gnutls_pk_algorithm_get_name</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpk_005fbits_005fto_005fsec_005fparam-213"><code>gnutls_pk_bits_to_sec_param</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpk_005fget_005fid-214"><code>gnutls_pk_get_id</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpk_005fget_005fname-215"><code>gnutls_pk_get_name</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpk_005flist-216"><code>gnutls_pk_list</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005fadd_005fprovider-602"><code>gnutls_pkcs11_add_provider</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005fcopy_005fsecret_005fkey-603"><code>gnutls_pkcs11_copy_secret_key</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005fcopy_005fx509_005fcrt-604"><code>gnutls_pkcs11_copy_x509_crt</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005fcopy_005fx509_005fprivkey-605"><code>gnutls_pkcs11_copy_x509_privkey</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005fdeinit-606"><code>gnutls_pkcs11_deinit</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005fdelete_005furl-607"><code>gnutls_pkcs11_delete_url</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005finit-608"><code>gnutls_pkcs11_init</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005fobj_005fdeinit-609"><code>gnutls_pkcs11_obj_deinit</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005fobj_005fexport-610"><code>gnutls_pkcs11_obj_export</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005fobj_005fexport_005furl-611"><code>gnutls_pkcs11_obj_export_url</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005fobj_005fget_005finfo-612"><code>gnutls_pkcs11_obj_get_info</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005fobj_005fget_005ftype-613"><code>gnutls_pkcs11_obj_get_type</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005fobj_005fimport_005furl-614"><code>gnutls_pkcs11_obj_import_url</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005fobj_005finit-615"><code>gnutls_pkcs11_obj_init</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005fobj_005flist_005fimport_005furl-616"><code>gnutls_pkcs11_obj_list_import_url</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005fprivkey_005fdeinit-617"><code>gnutls_pkcs11_privkey_deinit</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005fprivkey_005fexport_005furl-618"><code>gnutls_pkcs11_privkey_export_url</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005fprivkey_005fgenerate-619"><code>gnutls_pkcs11_privkey_generate</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005fprivkey_005fget_005finfo-620"><code>gnutls_pkcs11_privkey_get_info</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005fprivkey_005fget_005fpk_005falgorithm-621"><code>gnutls_pkcs11_privkey_get_pk_algorithm</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005fprivkey_005fimport_005furl-622"><code>gnutls_pkcs11_privkey_import_url</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005fprivkey_005finit-623"><code>gnutls_pkcs11_privkey_init</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005fset_005fpin_005ffunction-624"><code>gnutls_pkcs11_set_pin_function</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005fset_005ftoken_005ffunction-625"><code>gnutls_pkcs11_set_token_function</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005ftoken_005fget_005fflags-626"><code>gnutls_pkcs11_token_get_flags</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005ftoken_005fget_005finfo-627"><code>gnutls_pkcs11_token_get_info</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005ftoken_005fget_005fmechanism-628"><code>gnutls_pkcs11_token_get_mechanism</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005ftoken_005fget_005furl-629"><code>gnutls_pkcs11_token_get_url</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005ftoken_005finit-630"><code>gnutls_pkcs11_token_init</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005ftoken_005fset_005fpin-631"><code>gnutls_pkcs11_token_set_pin</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs11_005ftype_005fget_005fname-632"><code>gnutls_pkcs11_type_get_name</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fpkcs12_005fbag_005fdecrypt-580"><code>gnutls_pkcs12_bag_decrypt</code></a>: <a href="#PKCS-12-API">PKCS 12 API</a></li>
<li><a href="#index-gnutls_005fpkcs12_005fbag_005fdeinit-581"><code>gnutls_pkcs12_bag_deinit</code></a>: <a href="#PKCS-12-API">PKCS 12 API</a></li>
<li><a href="#index-gnutls_005fpkcs12_005fbag_005fencrypt-582"><code>gnutls_pkcs12_bag_encrypt</code></a>: <a href="#PKCS-12-API">PKCS 12 API</a></li>
<li><a href="#index-gnutls_005fpkcs12_005fbag_005fget_005fcount-583"><code>gnutls_pkcs12_bag_get_count</code></a>: <a href="#PKCS-12-API">PKCS 12 API</a></li>
<li><a href="#index-gnutls_005fpkcs12_005fbag_005fget_005fdata-584"><code>gnutls_pkcs12_bag_get_data</code></a>: <a href="#PKCS-12-API">PKCS 12 API</a></li>
<li><a href="#index-gnutls_005fpkcs12_005fbag_005fget_005ffriendly_005fname-585"><code>gnutls_pkcs12_bag_get_friendly_name</code></a>: <a href="#PKCS-12-API">PKCS 12 API</a></li>
<li><a href="#index-gnutls_005fpkcs12_005fbag_005fget_005fkey_005fid-586"><code>gnutls_pkcs12_bag_get_key_id</code></a>: <a href="#PKCS-12-API">PKCS 12 API</a></li>
<li><a href="#index-gnutls_005fpkcs12_005fbag_005fget_005ftype-587"><code>gnutls_pkcs12_bag_get_type</code></a>: <a href="#PKCS-12-API">PKCS 12 API</a></li>
<li><a href="#index-gnutls_005fpkcs12_005fbag_005finit-588"><code>gnutls_pkcs12_bag_init</code></a>: <a href="#PKCS-12-API">PKCS 12 API</a></li>
<li><a href="#index-gnutls_005fpkcs12_005fbag_005fset_005fcrl-589"><code>gnutls_pkcs12_bag_set_crl</code></a>: <a href="#PKCS-12-API">PKCS 12 API</a></li>
<li><a href="#index-gnutls_005fpkcs12_005fbag_005fset_005fcrt-590"><code>gnutls_pkcs12_bag_set_crt</code></a>: <a href="#PKCS-12-API">PKCS 12 API</a></li>
<li><a href="#index-gnutls_005fpkcs12_005fbag_005fset_005fdata-591"><code>gnutls_pkcs12_bag_set_data</code></a>: <a href="#PKCS-12-API">PKCS 12 API</a></li>
<li><a href="#index-gnutls_005fpkcs12_005fbag_005fset_005ffriendly_005fname-592"><code>gnutls_pkcs12_bag_set_friendly_name</code></a>: <a href="#PKCS-12-API">PKCS 12 API</a></li>
<li><a href="#index-gnutls_005fpkcs12_005fbag_005fset_005fkey_005fid-593"><code>gnutls_pkcs12_bag_set_key_id</code></a>: <a href="#PKCS-12-API">PKCS 12 API</a></li>
<li><a href="#index-gnutls_005fpkcs12_005fdeinit-594"><code>gnutls_pkcs12_deinit</code></a>: <a href="#PKCS-12-API">PKCS 12 API</a></li>
<li><a href="#index-gnutls_005fpkcs12_005fexport-595"><code>gnutls_pkcs12_export</code></a>: <a href="#PKCS-12-API">PKCS 12 API</a></li>
<li><a href="#index-gnutls_005fpkcs12_005fgenerate_005fmac-596"><code>gnutls_pkcs12_generate_mac</code></a>: <a href="#PKCS-12-API">PKCS 12 API</a></li>
<li><a href="#index-gnutls_005fpkcs12_005fget_005fbag-597"><code>gnutls_pkcs12_get_bag</code></a>: <a href="#PKCS-12-API">PKCS 12 API</a></li>
<li><a href="#index-gnutls_005fpkcs12_005fimport-598"><code>gnutls_pkcs12_import</code></a>: <a href="#PKCS-12-API">PKCS 12 API</a></li>
<li><a href="#index-gnutls_005fpkcs12_005finit-599"><code>gnutls_pkcs12_init</code></a>: <a href="#PKCS-12-API">PKCS 12 API</a></li>
<li><a href="#index-gnutls_005fpkcs12_005fset_005fbag-600"><code>gnutls_pkcs12_set_bag</code></a>: <a href="#PKCS-12-API">PKCS 12 API</a></li>
<li><a href="#index-gnutls_005fpkcs12_005fverify_005fmac-601"><code>gnutls_pkcs12_verify_mac</code></a>: <a href="#PKCS-12-API">PKCS 12 API</a></li>
<li><a href="#index-gnutls_005fpkcs7_005fdeinit-310"><code>gnutls_pkcs7_deinit</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fpkcs7_005fdelete_005fcrl-311"><code>gnutls_pkcs7_delete_crl</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fpkcs7_005fdelete_005fcrt-312"><code>gnutls_pkcs7_delete_crt</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fpkcs7_005fexport-313"><code>gnutls_pkcs7_export</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fpkcs7_005fget_005fcrl_005fcount-314"><code>gnutls_pkcs7_get_crl_count</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fpkcs7_005fget_005fcrl_005fraw-315"><code>gnutls_pkcs7_get_crl_raw</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fpkcs7_005fget_005fcrt_005fcount-316"><code>gnutls_pkcs7_get_crt_count</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fpkcs7_005fget_005fcrt_005fraw-317"><code>gnutls_pkcs7_get_crt_raw</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fpkcs7_005fimport-318"><code>gnutls_pkcs7_import</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fpkcs7_005finit-319"><code>gnutls_pkcs7_init</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fpkcs7_005fset_005fcrl-320"><code>gnutls_pkcs7_set_crl</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fpkcs7_005fset_005fcrl_005fraw-321"><code>gnutls_pkcs7_set_crl_raw</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fpkcs7_005fset_005fcrt-322"><code>gnutls_pkcs7_set_crt</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fpkcs7_005fset_005fcrt_005fraw-323"><code>gnutls_pkcs7_set_crt_raw</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fprf-217"><code>gnutls_prf</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fprf_005fraw-218"><code>gnutls_prf_raw</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpriority_005fdeinit-219"><code>gnutls_priority_deinit</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpriority_005fget_005fcipher_005fsuite_005findex-220"><code>gnutls_priority_get_cipher_suite_index</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpriority_005finit-221"><code>gnutls_priority_init</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpriority_005fset-222"><code>gnutls_priority_set</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpriority_005fset_005fdirect-223"><code>gnutls_priority_set_direct</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fprivkey_005fdecrypt_005fdata-643"><code>gnutls_privkey_decrypt_data</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fprivkey_005fdeinit-644"><code>gnutls_privkey_deinit</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fprivkey_005fget_005fpk_005falgorithm-645"><code>gnutls_privkey_get_pk_algorithm</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fprivkey_005fget_005ftype-646"><code>gnutls_privkey_get_type</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fprivkey_005fimport_005fext-647"><code>gnutls_privkey_import_ext</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fprivkey_005fimport_005fopenpgp-648"><code>gnutls_privkey_import_openpgp</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fprivkey_005fimport_005fpkcs11-649"><code>gnutls_privkey_import_pkcs11</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fprivkey_005fimport_005fx509-650"><code>gnutls_privkey_import_x509</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fprivkey_005finit-651"><code>gnutls_privkey_init</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fprivkey_005fsign_005fdata-652"><code>gnutls_privkey_sign_data</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fprivkey_005fsign_005fhash-653"><code>gnutls_privkey_sign_hash</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fprotocol_005fget_005fid-224"><code>gnutls_protocol_get_id</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fprotocol_005fget_005fname-225"><code>gnutls_protocol_get_name</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fprotocol_005fget_005fversion-226"><code>gnutls_protocol_get_version</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fprotocol_005flist-227"><code>gnutls_protocol_list</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fprotocol_005fset_005fpriority-716"><code>gnutls_protocol_set_priority</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005fpsk_005fallocate_005fclient_005fcredentials-228"><code>gnutls_psk_allocate_client_credentials</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpsk_005fallocate_005fserver_005fcredentials-229"><code>gnutls_psk_allocate_server_credentials</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpsk_005fclient_005fget_005fhint-230"><code>gnutls_psk_client_get_hint</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpsk_005ffree_005fclient_005fcredentials-231"><code>gnutls_psk_free_client_credentials</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpsk_005ffree_005fserver_005fcredentials-232"><code>gnutls_psk_free_server_credentials</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpsk_005fserver_005fget_005fusername-233"><code>gnutls_psk_server_get_username</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpsk_005fset_005fclient_005fcredentials-234"><code>gnutls_psk_set_client_credentials</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpsk_005fset_005fclient_005fcredentials_005ffunction-235"><code>gnutls_psk_set_client_credentials_function</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpsk_005fset_005fparams_005ffunction-236"><code>gnutls_psk_set_params_function</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffile-237"><code>gnutls_psk_set_server_credentials_file</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpsk_005fset_005fserver_005fcredentials_005ffunction-238"><code>gnutls_psk_set_server_credentials_function</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpsk_005fset_005fserver_005fcredentials_005fhint-239"><code>gnutls_psk_set_server_credentials_hint</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpsk_005fset_005fserver_005fdh_005fparams-240"><code>gnutls_psk_set_server_dh_params</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpsk_005fset_005fserver_005fparams_005ffunction-241"><code>gnutls_psk_set_server_params_function</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fdeinit-654"><code>gnutls_pubkey_deinit</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fexport-655"><code>gnutls_pubkey_export</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fget_005fkey_005fid-656"><code>gnutls_pubkey_get_key_id</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fget_005fkey_005fusage-657"><code>gnutls_pubkey_get_key_usage</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fget_005fopenpgp_005fkey_005fid-658"><code>gnutls_pubkey_get_openpgp_key_id</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fget_005fpk_005falgorithm-659"><code>gnutls_pubkey_get_pk_algorithm</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fget_005fpk_005fdsa_005fraw-660"><code>gnutls_pubkey_get_pk_dsa_raw</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fget_005fpk_005fecc_005fraw-661"><code>gnutls_pubkey_get_pk_ecc_raw</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fget_005fpk_005fecc_005fx962-662"><code>gnutls_pubkey_get_pk_ecc_x962</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fget_005fpk_005frsa_005fraw-663"><code>gnutls_pubkey_get_pk_rsa_raw</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fget_005fpreferred_005fhash_005falgorithm-664"><code>gnutls_pubkey_get_preferred_hash_algorithm</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fget_005fverify_005falgorithm-665"><code>gnutls_pubkey_get_verify_algorithm</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fimport-666"><code>gnutls_pubkey_import</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fimport_005fdsa_005fraw-667"><code>gnutls_pubkey_import_dsa_raw</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fimport_005fecc_005fraw-668"><code>gnutls_pubkey_import_ecc_raw</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fimport_005fecc_005fx962-669"><code>gnutls_pubkey_import_ecc_x962</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fimport_005fopenpgp-670"><code>gnutls_pubkey_import_openpgp</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fimport_005fpkcs11-671"><code>gnutls_pubkey_import_pkcs11</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fimport_005fpkcs11_005furl-672"><code>gnutls_pubkey_import_pkcs11_url</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fimport_005fprivkey-673"><code>gnutls_pubkey_import_privkey</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fimport_005frsa_005fraw-674"><code>gnutls_pubkey_import_rsa_raw</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fimport_005fx509-675"><code>gnutls_pubkey_import_x509</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005finit-676"><code>gnutls_pubkey_init</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fset_005fkey_005fusage-677"><code>gnutls_pubkey_set_key_usage</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fverify_005fdata-678"><code>gnutls_pubkey_verify_data</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fverify_005fdata2-679"><code>gnutls_pubkey_verify_data2</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fpubkey_005fverify_005fhash-680"><code>gnutls_pubkey_verify_hash</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005frecord_005fcheck_005fpending-242"><code>gnutls_record_check_pending</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005frecord_005fdisable_005fpadding-243"><code>gnutls_record_disable_padding</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005frecord_005fget_005fdirection-244"><code>gnutls_record_get_direction</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005frecord_005fget_005fdiscarded-308"><code>gnutls_record_get_discarded</code></a>: <a href="#Datagram-TLS-API">Datagram TLS API</a></li>
<li><a href="#index-gnutls_005frecord_005fget_005fmax_005fsize-245"><code>gnutls_record_get_max_size</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005frecord_005frecv-246"><code>gnutls_record_recv</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005frecord_005frecv_005fseq-247"><code>gnutls_record_recv_seq</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005frecord_005fsend-248"><code>gnutls_record_send</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005frecord_005fset_005fmax_005fsize-249"><code>gnutls_record_set_max_size</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005frehandshake-250"><code>gnutls_rehandshake</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005frnd-708"><code>gnutls_rnd</code></a>: <a href="#Cryptographic-API">Cryptographic API</a></li>
<li><a href="#index-gnutls_005frsa_005fexport_005fget_005fmodulus_005fbits-717"><code>gnutls_rsa_export_get_modulus_bits</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005frsa_005fexport_005fget_005fpubkey-718"><code>gnutls_rsa_export_get_pubkey</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005frsa_005fparams_005fcpy-719"><code>gnutls_rsa_params_cpy</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005frsa_005fparams_005fdeinit-720"><code>gnutls_rsa_params_deinit</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005frsa_005fparams_005fexport_005fpkcs1-721"><code>gnutls_rsa_params_export_pkcs1</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005frsa_005fparams_005fexport_005fraw-722"><code>gnutls_rsa_params_export_raw</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005frsa_005fparams_005fgenerate2-723"><code>gnutls_rsa_params_generate2</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005frsa_005fparams_005fimport_005fpkcs1-724"><code>gnutls_rsa_params_import_pkcs1</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005frsa_005fparams_005fimport_005fraw-725"><code>gnutls_rsa_params_import_raw</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005frsa_005fparams_005finit-726"><code>gnutls_rsa_params_init</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005fsafe_005frenegotiation_005fstatus-251"><code>gnutls_safe_renegotiation_status</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsec_005fparam_005fget_005fname-252"><code>gnutls_sec_param_get_name</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsec_005fparam_005fto_005fpk_005fbits-253"><code>gnutls_sec_param_to_pk_bits</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fserver_005fname_005fget-254"><code>gnutls_server_name_get</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fserver_005fname_005fset-255"><code>gnutls_server_name_set</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsession_005fchannel_005fbinding-256"><code>gnutls_session_channel_binding</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsession_005fenable_005fcompatibility_005fmode-257"><code>gnutls_session_enable_compatibility_mode</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsession_005fget_005fdata-258"><code>gnutls_session_get_data</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsession_005fget_005fdata2-259"><code>gnutls_session_get_data2</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsession_005fget_005fid-260"><code>gnutls_session_get_id</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsession_005fget_005fptr-261"><code>gnutls_session_get_ptr</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsession_005fis_005fresumed-262"><code>gnutls_session_is_resumed</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsession_005fset_005fdata-263"><code>gnutls_session_set_data</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsession_005fset_005fptr-264"><code>gnutls_session_set_ptr</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsession_005fticket_005fenable_005fclient-265"><code>gnutls_session_ticket_enable_client</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsession_005fticket_005fenable_005fserver-266"><code>gnutls_session_ticket_enable_server</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsession_005fticket_005fkey_005fgenerate-267"><code>gnutls_session_ticket_key_generate</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fset_005fdefault_005fexport_005fpriority-727"><code>gnutls_set_default_export_priority</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005fset_005fdefault_005fpriority-268"><code>gnutls_set_default_priority</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsign_005falgorithm_005fget_005frequested-269"><code>gnutls_sign_algorithm_get_requested</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsign_005fcallback_005fget-728"><code>gnutls_sign_callback_get</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005fsign_005fcallback_005fset-729"><code>gnutls_sign_callback_set</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005fsign_005fget_005fid-270"><code>gnutls_sign_get_id</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsign_005fget_005fname-271"><code>gnutls_sign_get_name</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsign_005flist-272"><code>gnutls_sign_list</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsrp_005fallocate_005fclient_005fcredentials-273"><code>gnutls_srp_allocate_client_credentials</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsrp_005fallocate_005fserver_005fcredentials-274"><code>gnutls_srp_allocate_server_credentials</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsrp_005fbase64_005fdecode-275"><code>gnutls_srp_base64_decode</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsrp_005fbase64_005fdecode_005falloc-276"><code>gnutls_srp_base64_decode_alloc</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsrp_005fbase64_005fencode-277"><code>gnutls_srp_base64_encode</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsrp_005fbase64_005fencode_005falloc-278"><code>gnutls_srp_base64_encode_alloc</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsrp_005ffree_005fclient_005fcredentials-279"><code>gnutls_srp_free_client_credentials</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsrp_005ffree_005fserver_005fcredentials-280"><code>gnutls_srp_free_server_credentials</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsrp_005fserver_005fget_005fusername-281"><code>gnutls_srp_server_get_username</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsrp_005fset_005fclient_005fcredentials-282"><code>gnutls_srp_set_client_credentials</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsrp_005fset_005fclient_005fcredentials_005ffunction-283"><code>gnutls_srp_set_client_credentials_function</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsrp_005fset_005fprime_005fbits-284"><code>gnutls_srp_set_prime_bits</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffile-285"><code>gnutls_srp_set_server_credentials_file</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsrp_005fset_005fserver_005fcredentials_005ffunction-286"><code>gnutls_srp_set_server_credentials_function</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsrp_005fverifier-287"><code>gnutls_srp_verifier</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fstrerror-288"><code>gnutls_strerror</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fstrerror_005fname-289"><code>gnutls_strerror_name</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fsupplemental_005fget_005fname-290"><code>gnutls_supplemental_get_name</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005ftransport_005fget_005fptr-291"><code>gnutls_transport_get_ptr</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005ftransport_005fget_005fptr2-292"><code>gnutls_transport_get_ptr2</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005ftransport_005fset_005ferrno-293"><code>gnutls_transport_set_errno</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005ftransport_005fset_005ferrno_005ffunction-294"><code>gnutls_transport_set_errno_function</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005ftransport_005fset_005fptr-295"><code>gnutls_transport_set_ptr</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005ftransport_005fset_005fptr2-296"><code>gnutls_transport_set_ptr2</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005ftransport_005fset_005fpull_005ffunction-297"><code>gnutls_transport_set_pull_function</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005ftransport_005fset_005fpull_005ftimeout_005ffunction-298"><code>gnutls_transport_set_pull_timeout_function</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005ftransport_005fset_005fpush_005ffunction-299"><code>gnutls_transport_set_push_function</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005ftransport_005fset_005fvec_005fpush_005ffunction-300"><code>gnutls_transport_set_vec_push_function</code></a>: <a href="#Core-TLS-API">Core TLS API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fcheck_005fissuer-324"><code>gnutls_x509_crl_check_issuer</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fdeinit-325"><code>gnutls_x509_crl_deinit</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fexport-326"><code>gnutls_x509_crl_export</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fget_005fauthority_005fkey_005fid-327"><code>gnutls_x509_crl_get_authority_key_id</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fget_005fcrt_005fcount-328"><code>gnutls_x509_crl_get_crt_count</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fget_005fcrt_005fserial-329"><code>gnutls_x509_crl_get_crt_serial</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fget_005fdn_005foid-330"><code>gnutls_x509_crl_get_dn_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fget_005fextension_005fdata-331"><code>gnutls_x509_crl_get_extension_data</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fget_005fextension_005finfo-332"><code>gnutls_x509_crl_get_extension_info</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fget_005fextension_005foid-333"><code>gnutls_x509_crl_get_extension_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn-334"><code>gnutls_x509_crl_get_issuer_dn</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fget_005fissuer_005fdn_005fby_005foid-335"><code>gnutls_x509_crl_get_issuer_dn_by_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fget_005fnext_005fupdate-336"><code>gnutls_x509_crl_get_next_update</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fget_005fnumber-337"><code>gnutls_x509_crl_get_number</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fget_005fraw_005fissuer_005fdn-338"><code>gnutls_x509_crl_get_raw_issuer_dn</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fget_005fsignature-339"><code>gnutls_x509_crl_get_signature</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fget_005fsignature_005falgorithm-340"><code>gnutls_x509_crl_get_signature_algorithm</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fget_005fthis_005fupdate-341"><code>gnutls_x509_crl_get_this_update</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fget_005fversion-342"><code>gnutls_x509_crl_get_version</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fimport-343"><code>gnutls_x509_crl_import</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005finit-344"><code>gnutls_x509_crl_init</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005flist_005fimport-345"><code>gnutls_x509_crl_list_import</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005flist_005fimport2-346"><code>gnutls_x509_crl_list_import2</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fprint-347"><code>gnutls_x509_crl_print</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fprivkey_005fsign-681"><code>gnutls_x509_crl_privkey_sign</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fset_005fauthority_005fkey_005fid-348"><code>gnutls_x509_crl_set_authority_key_id</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fset_005fcrt-349"><code>gnutls_x509_crl_set_crt</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fset_005fcrt_005fserial-350"><code>gnutls_x509_crl_set_crt_serial</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fset_005fnext_005fupdate-351"><code>gnutls_x509_crl_set_next_update</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fset_005fnumber-352"><code>gnutls_x509_crl_set_number</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fset_005fthis_005fupdate-353"><code>gnutls_x509_crl_set_this_update</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fset_005fversion-354"><code>gnutls_x509_crl_set_version</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fsign-730"><code>gnutls_x509_crl_sign</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fsign2-355"><code>gnutls_x509_crl_sign2</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrl_005fverify-356"><code>gnutls_x509_crl_verify</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fdeinit-357"><code>gnutls_x509_crq_deinit</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fexport-358"><code>gnutls_x509_crq_export</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fget_005fattribute_005fby_005foid-359"><code>gnutls_x509_crq_get_attribute_by_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fget_005fattribute_005fdata-360"><code>gnutls_x509_crq_get_attribute_data</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fget_005fattribute_005finfo-361"><code>gnutls_x509_crq_get_attribute_info</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fget_005fbasic_005fconstraints-362"><code>gnutls_x509_crq_get_basic_constraints</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fget_005fchallenge_005fpassword-363"><code>gnutls_x509_crq_get_challenge_password</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fget_005fdn-364"><code>gnutls_x509_crq_get_dn</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fget_005fdn_005fby_005foid-365"><code>gnutls_x509_crq_get_dn_by_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fget_005fdn_005foid-366"><code>gnutls_x509_crq_get_dn_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fget_005fextension_005fby_005foid-367"><code>gnutls_x509_crq_get_extension_by_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fget_005fextension_005fdata-368"><code>gnutls_x509_crq_get_extension_data</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fget_005fextension_005finfo-369"><code>gnutls_x509_crq_get_extension_info</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fget_005fkey_005fid-370"><code>gnutls_x509_crq_get_key_id</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fget_005fkey_005fpurpose_005foid-371"><code>gnutls_x509_crq_get_key_purpose_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fget_005fkey_005frsa_005fraw-372"><code>gnutls_x509_crq_get_key_rsa_raw</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fget_005fkey_005fusage-373"><code>gnutls_x509_crq_get_key_usage</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fget_005fpk_005falgorithm-374"><code>gnutls_x509_crq_get_pk_algorithm</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fget_005fsubject_005falt_005fname-375"><code>gnutls_x509_crq_get_subject_alt_name</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fget_005fsubject_005falt_005fothername_005foid-376"><code>gnutls_x509_crq_get_subject_alt_othername_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fget_005fversion-377"><code>gnutls_x509_crq_get_version</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fimport-378"><code>gnutls_x509_crq_import</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005finit-379"><code>gnutls_x509_crq_init</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fprint-380"><code>gnutls_x509_crq_print</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fprivkey_005fsign-682"><code>gnutls_x509_crq_privkey_sign</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fset_005fattribute_005fby_005foid-381"><code>gnutls_x509_crq_set_attribute_by_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fset_005fbasic_005fconstraints-382"><code>gnutls_x509_crq_set_basic_constraints</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fset_005fchallenge_005fpassword-383"><code>gnutls_x509_crq_set_challenge_password</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fset_005fdn_005fby_005foid-384"><code>gnutls_x509_crq_set_dn_by_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fset_005fkey-385"><code>gnutls_x509_crq_set_key</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fset_005fkey_005fpurpose_005foid-386"><code>gnutls_x509_crq_set_key_purpose_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fset_005fkey_005frsa_005fraw-387"><code>gnutls_x509_crq_set_key_rsa_raw</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fset_005fkey_005fusage-388"><code>gnutls_x509_crq_set_key_usage</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fset_005fpubkey-683"><code>gnutls_x509_crq_set_pubkey</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fset_005fsubject_005falt_005fname-389"><code>gnutls_x509_crq_set_subject_alt_name</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fset_005fversion-390"><code>gnutls_x509_crq_set_version</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fsign-731"><code>gnutls_x509_crq_sign</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fsign2-391"><code>gnutls_x509_crq_sign2</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrq_005fverify-392"><code>gnutls_x509_crq_verify</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fcheck_005fhostname-393"><code>gnutls_x509_crt_check_hostname</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fcheck_005fissuer-394"><code>gnutls_x509_crt_check_issuer</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fcheck_005frevocation-395"><code>gnutls_x509_crt_check_revocation</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fcpy_005fcrl_005fdist_005fpoints-396"><code>gnutls_x509_crt_cpy_crl_dist_points</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fdeinit-397"><code>gnutls_x509_crt_deinit</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fexport-398"><code>gnutls_x509_crt_export</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005factivation_005ftime-399"><code>gnutls_x509_crt_get_activation_time</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fauthority_005finfo_005faccess-400"><code>gnutls_x509_crt_get_authority_info_access</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fauthority_005fkey_005fid-401"><code>gnutls_x509_crt_get_authority_key_id</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fbasic_005fconstraints-402"><code>gnutls_x509_crt_get_basic_constraints</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fca_005fstatus-403"><code>gnutls_x509_crt_get_ca_status</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fcrl_005fdist_005fpoints-404"><code>gnutls_x509_crt_get_crl_dist_points</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fdn-405"><code>gnutls_x509_crt_get_dn</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fdn_005fby_005foid-406"><code>gnutls_x509_crt_get_dn_by_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fdn_005foid-407"><code>gnutls_x509_crt_get_dn_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fexpiration_005ftime-408"><code>gnutls_x509_crt_get_expiration_time</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fextension_005fby_005foid-409"><code>gnutls_x509_crt_get_extension_by_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fextension_005fdata-410"><code>gnutls_x509_crt_get_extension_data</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fextension_005finfo-411"><code>gnutls_x509_crt_get_extension_info</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fextension_005foid-412"><code>gnutls_x509_crt_get_extension_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005ffingerprint-413"><code>gnutls_x509_crt_get_fingerprint</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fissuer-414"><code>gnutls_x509_crt_get_issuer</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fname-415"><code>gnutls_x509_crt_get_issuer_alt_name</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fname2-416"><code>gnutls_x509_crt_get_issuer_alt_name2</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fissuer_005falt_005fothername_005foid-417"><code>gnutls_x509_crt_get_issuer_alt_othername_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn-418"><code>gnutls_x509_crt_get_issuer_dn</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn_005fby_005foid-419"><code>gnutls_x509_crt_get_issuer_dn_by_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fissuer_005fdn_005foid-420"><code>gnutls_x509_crt_get_issuer_dn_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fissuer_005funique_005fid-421"><code>gnutls_x509_crt_get_issuer_unique_id</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fkey_005fid-422"><code>gnutls_x509_crt_get_key_id</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fkey_005fpurpose_005foid-423"><code>gnutls_x509_crt_get_key_purpose_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fkey_005fusage-424"><code>gnutls_x509_crt_get_key_usage</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fpk_005falgorithm-425"><code>gnutls_x509_crt_get_pk_algorithm</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fpk_005fdsa_005fraw-426"><code>gnutls_x509_crt_get_pk_dsa_raw</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fpk_005frsa_005fraw-427"><code>gnutls_x509_crt_get_pk_rsa_raw</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fpreferred_005fhash_005falgorithm-732"><code>gnutls_x509_crt_get_preferred_hash_algorithm</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fproxy-428"><code>gnutls_x509_crt_get_proxy</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fraw_005fdn-429"><code>gnutls_x509_crt_get_raw_dn</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fraw_005fissuer_005fdn-430"><code>gnutls_x509_crt_get_raw_issuer_dn</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fserial-431"><code>gnutls_x509_crt_get_serial</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fsignature-432"><code>gnutls_x509_crt_get_signature</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fsignature_005falgorithm-433"><code>gnutls_x509_crt_get_signature_algorithm</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fsubject-434"><code>gnutls_x509_crt_get_subject</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fname-435"><code>gnutls_x509_crt_get_subject_alt_name</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fname2-436"><code>gnutls_x509_crt_get_subject_alt_name2</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fsubject_005falt_005fothername_005foid-437"><code>gnutls_x509_crt_get_subject_alt_othername_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fsubject_005fkey_005fid-438"><code>gnutls_x509_crt_get_subject_key_id</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fsubject_005funique_005fid-439"><code>gnutls_x509_crt_get_subject_unique_id</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fverify_005falgorithm-733"><code>gnutls_x509_crt_get_verify_algorithm</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fget_005fversion-440"><code>gnutls_x509_crt_get_version</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fimport-441"><code>gnutls_x509_crt_import</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fimport_005fpkcs11-633"><code>gnutls_x509_crt_import_pkcs11</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fimport_005fpkcs11_005furl-634"><code>gnutls_x509_crt_import_pkcs11_url</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005finit-442"><code>gnutls_x509_crt_init</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005flist_005fimport-443"><code>gnutls_x509_crt_list_import</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005flist_005fimport2-444"><code>gnutls_x509_crt_list_import2</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005flist_005fimport_005fpkcs11-635"><code>gnutls_x509_crt_list_import_pkcs11</code></a>: <a href="#PKCS-11-API">PKCS 11 API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005flist_005fverify-445"><code>gnutls_x509_crt_list_verify</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fprint-446"><code>gnutls_x509_crt_print</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fprivkey_005fsign-684"><code>gnutls_x509_crt_privkey_sign</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fset_005factivation_005ftime-447"><code>gnutls_x509_crt_set_activation_time</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fset_005fauthority_005fkey_005fid-448"><code>gnutls_x509_crt_set_authority_key_id</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fset_005fbasic_005fconstraints-449"><code>gnutls_x509_crt_set_basic_constraints</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fset_005fca_005fstatus-450"><code>gnutls_x509_crt_set_ca_status</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fset_005fcrl_005fdist_005fpoints-451"><code>gnutls_x509_crt_set_crl_dist_points</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fset_005fcrl_005fdist_005fpoints2-452"><code>gnutls_x509_crt_set_crl_dist_points2</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fset_005fcrq-453"><code>gnutls_x509_crt_set_crq</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fset_005fcrq_005fextensions-454"><code>gnutls_x509_crt_set_crq_extensions</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fset_005fdn_005fby_005foid-455"><code>gnutls_x509_crt_set_dn_by_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fset_005fexpiration_005ftime-456"><code>gnutls_x509_crt_set_expiration_time</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fset_005fextension_005fby_005foid-457"><code>gnutls_x509_crt_set_extension_by_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fset_005fissuer_005fdn_005fby_005foid-458"><code>gnutls_x509_crt_set_issuer_dn_by_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fset_005fkey-459"><code>gnutls_x509_crt_set_key</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fset_005fkey_005fpurpose_005foid-460"><code>gnutls_x509_crt_set_key_purpose_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fset_005fkey_005fusage-461"><code>gnutls_x509_crt_set_key_usage</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fset_005fproxy-462"><code>gnutls_x509_crt_set_proxy</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fset_005fproxy_005fdn-463"><code>gnutls_x509_crt_set_proxy_dn</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fset_005fpubkey-685"><code>gnutls_x509_crt_set_pubkey</code></a>: <a href="#Abstract-key-API">Abstract key API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fset_005fserial-464"><code>gnutls_x509_crt_set_serial</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fset_005fsubject_005falt_005fname-466"><code>gnutls_x509_crt_set_subject_alt_name</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fset_005fsubject_005falternative_005fname-465"><code>gnutls_x509_crt_set_subject_alternative_name</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fset_005fsubject_005fkey_005fid-467"><code>gnutls_x509_crt_set_subject_key_id</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fset_005fversion-468"><code>gnutls_x509_crt_set_version</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fsign-469"><code>gnutls_x509_crt_sign</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fsign2-470"><code>gnutls_x509_crt_sign2</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fverify-471"><code>gnutls_x509_crt_verify</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fverify_005fdata-734"><code>gnutls_x509_crt_verify_data</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005fx509_005fcrt_005fverify_005fhash-735"><code>gnutls_x509_crt_verify_hash</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005fx509_005fdn_005fdeinit-472"><code>gnutls_x509_dn_deinit</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fdn_005fexport-473"><code>gnutls_x509_dn_export</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fdn_005fget_005frdn_005fava-474"><code>gnutls_x509_dn_get_rdn_ava</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fdn_005fimport-475"><code>gnutls_x509_dn_import</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fdn_005finit-476"><code>gnutls_x509_dn_init</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fdn_005foid_005fknown-477"><code>gnutls_x509_dn_oid_known</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fprivkey_005fcpy-478"><code>gnutls_x509_privkey_cpy</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fprivkey_005fdeinit-479"><code>gnutls_x509_privkey_deinit</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fprivkey_005fexport-480"><code>gnutls_x509_privkey_export</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fprivkey_005fexport_005fdsa_005fraw-481"><code>gnutls_x509_privkey_export_dsa_raw</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fprivkey_005fexport_005fecc_005fraw-482"><code>gnutls_x509_privkey_export_ecc_raw</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fprivkey_005fexport_005fpkcs8-483"><code>gnutls_x509_privkey_export_pkcs8</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fprivkey_005fexport_005frsa_005fraw-484"><code>gnutls_x509_privkey_export_rsa_raw</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fprivkey_005fexport_005frsa_005fraw2-485"><code>gnutls_x509_privkey_export_rsa_raw2</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fprivkey_005ffix-486"><code>gnutls_x509_privkey_fix</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fprivkey_005fgenerate-487"><code>gnutls_x509_privkey_generate</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fprivkey_005fget_005fkey_005fid-488"><code>gnutls_x509_privkey_get_key_id</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fprivkey_005fget_005fpk_005falgorithm-489"><code>gnutls_x509_privkey_get_pk_algorithm</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fprivkey_005fimport-490"><code>gnutls_x509_privkey_import</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fprivkey_005fimport_005fdsa_005fraw-491"><code>gnutls_x509_privkey_import_dsa_raw</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fprivkey_005fimport_005fecc_005fraw-492"><code>gnutls_x509_privkey_import_ecc_raw</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fprivkey_005fimport_005fpkcs8-493"><code>gnutls_x509_privkey_import_pkcs8</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fprivkey_005fimport_005frsa_005fraw-494"><code>gnutls_x509_privkey_import_rsa_raw</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fprivkey_005fimport_005frsa_005fraw2-495"><code>gnutls_x509_privkey_import_rsa_raw2</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fprivkey_005finit-496"><code>gnutls_x509_privkey_init</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fprivkey_005fsec_005fparam-497"><code>gnutls_x509_privkey_sec_param</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005fprivkey_005fsign_005fdata-736"><code>gnutls_x509_privkey_sign_data</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005fx509_005fprivkey_005fsign_005fhash-737"><code>gnutls_x509_privkey_sign_hash</code></a>: <a href="#Compatibility-API">Compatibility API</a></li>
<li><a href="#index-gnutls_005fx509_005fprivkey_005fverify_005fparams-498"><code>gnutls_x509_privkey_verify_params</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005frdn_005fget-499"><code>gnutls_x509_rdn_get</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005frdn_005fget_005fby_005foid-500"><code>gnutls_x509_rdn_get_by_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005frdn_005fget_005foid-501"><code>gnutls_x509_rdn_get_oid</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005ftrust_005flist_005fadd_005fcas-502"><code>gnutls_x509_trust_list_add_cas</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005ftrust_005flist_005fadd_005fcrls-503"><code>gnutls_x509_trust_list_add_crls</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005ftrust_005flist_005fadd_005fnamed_005fcrt-504"><code>gnutls_x509_trust_list_add_named_crt</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005ftrust_005flist_005fdeinit-505"><code>gnutls_x509_trust_list_deinit</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005ftrust_005flist_005fget_005fissuer-506"><code>gnutls_x509_trust_list_get_issuer</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005ftrust_005flist_005finit-507"><code>gnutls_x509_trust_list_init</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005ftrust_005flist_005fverify_005fcrt-508"><code>gnutls_x509_trust_list_verify_crt</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
<li><a href="#index-gnutls_005fx509_005ftrust_005flist_005fverify_005fnamed_005fcrt-509"><code>gnutls_x509_trust_list_verify_named_crt</code></a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
</ul><div class="node">
<a name="Concept-Index"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Function-and-Data-Index">Function and Data Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Copying-Information">Copying Information</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="unnumbered">Concept Index</h2>



<ul class="index-cp" compact>
<li><a href="#index-abstract-types-54">abstract types</a>: <a href="#Abstract-key-types">Abstract key types</a></li>
<li><a href="#index-alert-protocol-11">alert protocol</a>: <a href="#The-TLS-Alert-Protocol">The TLS Alert Protocol</a></li>
<li><a href="#index-anonymous-authentication-39">anonymous authentication</a>: <a href="#Anonymous-authentication">Anonymous authentication</a></li>
<li><a href="#index-API-reference-84">API reference</a>: <a href="#API-reference">API reference</a></li>
<li><a href="#index-bad_005frecord_005fmac-10">bad_record_mac</a>: <a href="#On-Record-Padding">On Record Padding</a></li>
<li><a href="#index-callback-functions-56">callback functions</a>: <a href="#Callback-functions">Callback functions</a></li>
<li><a href="#index-certificate-authentication-40">certificate authentication</a>: <a href="#More-on-certificate-authentication">More on certificate authentication</a></li>
<li><a href="#index-certificate-authentication-28">certificate authentication</a>: <a href="#Certificate-authentication">Certificate authentication</a></li>
<li><a href="#index-certificate-requests-41">certificate requests</a>: <a href="#PKCS-10-certificate-requests">PKCS 10 certificate requests</a></li>
<li><a href="#index-certificate-revocation-lists-43">certificate revocation lists</a>: <a href="#PKIX-certificate-revocation-lists">PKIX certificate revocation lists</a></li>
<li><a href="#index-certtool-48">certtool</a>: <a href="#The-certtool-application">The certtool application</a></li>
<li><a href="#index-channel-bindings-63">channel bindings</a>: <a href="#Channel-Bindings">Channel Bindings</a></li>
<li><a href="#index-ciphersuites-738">ciphersuites</a>: <a href="#Supported-ciphersuites-in-GnuTLS">Supported ciphersuites in GnuTLS</a></li>
<li><a href="#index-client-certificate-authentication-13">client certificate authentication</a>: <a href="#Client-Authentication">Client Authentication</a></li>
<li><a href="#index-compression-algorithms-8">compression algorithms</a>: <a href="#Compression-algorithms-used-in-the-record-layer">Compression algorithms used in the record layer</a></li>
<li><a href="#index-contributing-81">contributing</a>: <a href="#Contributing">Contributing</a></li>
<li><a href="#index-CRL-44">CRL</a>: <a href="#PKIX-certificate-revocation-lists">PKIX certificate revocation lists</a></li>
<li><a href="#index-debug-server-77">debug server</a>: <a href="#Setting-up-a-test-HTTPS-server">Setting up a test HTTPS server</a></li>
<li><a href="#index-digital-signatures-34">digital signatures</a>: <a href="#Digital-signatures">Digital signatures</a></li>
<li><a href="#index-download-2">download</a>: <a href="#Downloading-and-installing">Downloading and installing</a></li>
<li><a href="#index-Encrypted-keys-45">Encrypted keys</a>: <a href="#Managing-encrypted-keys">Managing encrypted keys</a></li>
<li><a href="#index-error-codes-83">error codes</a>: <a href="#Error-codes">Error codes</a></li>
<li><a href="#index-example-programs-70">example programs</a>: <a href="#GnuTLS-application-examples">GnuTLS application examples</a></li>
<li><a href="#index-examples-71">examples</a>: <a href="#GnuTLS-application-examples">GnuTLS application examples</a></li>
<li><a href="#index-exporting-keying-material-62">exporting keying material</a>: <a href="#Keying-Material-Exporters">Keying Material Exporters</a></li>
<li><a href="#index-FDL_002c-GNU-Free-Documentation-License-739">FDL, GNU Free Documentation License</a>: <a href="#GNU-Free-Documentation-License">GNU Free Documentation License</a></li>
<li><a href="#index-generating-parameters-60">generating parameters</a>: <a href="#Parameter-generation">Parameter generation</a></li>
<li><a href="#index-gnutls_002dcli-73">gnutls-cli</a>: <a href="#The-gnutls_002dcli-tool">The gnutls-cli tool</a></li>
<li><a href="#index-gnutls_002dcli_002ddebug-78">gnutls-cli-debug</a>: <a href="#The-gnutls_002dcli_002ddebug-tool">The gnutls-cli-debug tool</a></li>
<li><a href="#index-gnutls_002dserv-75">gnutls-serv</a>: <a href="#The-gnutls_002dserv-tool">The gnutls-serv tool</a></li>
<li><a href="#index-hacking-82">hacking</a>: <a href="#Contributing">Contributing</a></li>
<li><a href="#index-handshake-protocol-12">handshake protocol</a>: <a href="#The-TLS-Handshake-Protocol">The TLS Handshake Protocol</a></li>
<li><a href="#index-hardware-security-modules-51">hardware security modules</a>: <a href="#Hardware-tokens">Hardware tokens</a></li>
<li><a href="#index-hardware-tokens-50">hardware tokens</a>: <a href="#Hardware-tokens">Hardware tokens</a></li>
<li><a href="#index-hash-functions-66">hash functions</a>: <a href="#Hash-and-HMAC-functions">Hash and HMAC functions</a></li>
<li><a href="#index-HMAC-functions-67">HMAC functions</a>: <a href="#Hash-and-HMAC-functions">Hash and HMAC functions</a></li>
<li><a href="#index-HTTPS-server-76">HTTPS server</a>: <a href="#Setting-up-a-test-HTTPS-server">Setting up a test HTTPS server</a></li>
<li><a href="#index-installation-1">installation</a>: <a href="#Downloading-and-installing">Downloading and installing</a></li>
<li><a href="#index-internal-architecture-79">internal architecture</a>: <a href="#Internal-architecture-of-GnuTLS">Internal architecture of GnuTLS</a></li>
<li><a href="#index-key-sizes-69">key sizes</a>: <a href="#Selecting-cryptographic-key-sizes">Selecting cryptographic key sizes</a></li>
<li><a href="#index-keying-material-exporters-61">keying material exporters</a>: <a href="#Keying-Material-Exporters">Keying Material Exporters</a></li>
<li><a href="#index-maximum-fragment-length-18">maximum fragment length</a>: <a href="#Maximum-fragment-length-negotiation">Maximum fragment length negotiation</a></li>
<li><a href="#index-OpenPGP-API-510">OpenPGP API</a>: <a href="#OpenPGP-API">OpenPGP API</a></li>
<li><a href="#index-OpenPGP-certificates-33">OpenPGP certificates</a>: <a href="#OpenPGP-certificates">OpenPGP certificates</a></li>
<li><a href="#index-OpenPGP-server-72">OpenPGP server</a>: <a href="#Echo-Server-with-OpenPGP-authentication">Echo Server with OpenPGP authentication</a></li>
<li><a href="#index-OpenSSL-64">OpenSSL</a>: <a href="#Compatibility-with-the-OpenSSL-library">Compatibility with the OpenSSL library</a></li>
<li><a href="#index-p11tool-53">p11tool</a>: <a href="#The-p11tool-application">The p11tool application</a></li>
<li><a href="#index-parameter-generation-59">parameter generation</a>: <a href="#Parameter-generation">Parameter generation</a></li>
<li><a href="#index-PCT-27">PCT</a>: <a href="#On-SSL-2-and-older-protocols">On SSL 2 and older protocols</a></li>
<li><a href="#index-PKCS-_002310-42">PKCS #10</a>: <a href="#PKCS-10-certificate-requests">PKCS 10 certificate requests</a></li>
<li><a href="#index-PKCS-_002311-tokens-49">PKCS #11 tokens</a>: <a href="#Hardware-tokens">Hardware tokens</a></li>
<li><a href="#index-PKCS-_002312-47">PKCS #12</a>: <a href="#Managing-encrypted-keys">Managing encrypted keys</a></li>
<li><a href="#index-PKCS-_00238-46">PKCS #8</a>: <a href="#Managing-encrypted-keys">Managing encrypted keys</a></li>
<li><a href="#index-PSK-authentication-37">PSK authentication</a>: <a href="#Authentication-using-PSK">Authentication using PSK</a></li>
<li><a href="#index-PSK-client-74">PSK client</a>: <a href="#Example-client-PSK-connection">Example client PSK connection</a></li>
<li><a href="#index-psktool-38">psktool</a>: <a href="#Invoking-psktool">Invoking psktool</a></li>
<li><a href="#index-random-numbers-68">random numbers</a>: <a href="#Random-number-generation">Random number generation</a></li>
<li><a href="#index-record-padding-9">record padding</a>: <a href="#On-Record-Padding">On Record Padding</a></li>
<li><a href="#index-record-protocol-6">record protocol</a>: <a href="#The-TLS-record-protocol">The TLS record protocol</a></li>
<li><a href="#index-renegotiation-24">renegotiation</a>: <a href="#Safe-renegotiation">Safe renegotiation</a></li>
<li><a href="#index-reporting-bugs-80">reporting bugs</a>: <a href="#Bug-Reports">Bug Reports</a></li>
<li><a href="#index-resuming-sessions-57">resuming sessions</a>: <a href="#Session-resumption">Session resumption</a></li>
<li><a href="#index-resuming-sessions-14">resuming sessions</a>: <a href="#Resuming-Sessions">Resuming Sessions</a></li>
<li><a href="#index-safe-renegotiation-25">safe renegotiation</a>: <a href="#Safe-renegotiation">Safe renegotiation</a></li>
<li><a href="#index-server-name-indication-20">server name indication</a>: <a href="#Server-name-indication">Server name indication</a></li>
<li><a href="#index-session-resumption-58">session resumption</a>: <a href="#Session-resumption">Session resumption</a></li>
<li><a href="#index-session-resumption-15">session resumption</a>: <a href="#Resuming-Sessions">Resuming Sessions</a></li>
<li><a href="#index-session-tickets-22">session tickets</a>: <a href="#Session-tickets">Session tickets</a></li>
<li><a href="#index-smart-cards-52">smart cards</a>: <a href="#Hardware-tokens">Hardware tokens</a></li>
<li><a href="#index-SRP-authentication-35">SRP authentication</a>: <a href="#Authentication-using-SRP">Authentication using SRP</a></li>
<li><a href="#index-srptool-36">srptool</a>: <a href="#Invoking-srptool">Invoking srptool</a></li>
<li><a href="#index-SSL-2-26">SSL 2</a>: <a href="#On-SSL-2-and-older-protocols">On SSL 2 and older protocols</a></li>
<li><a href="#index-symmetric-cryptography-65">symmetric cryptography</a>: <a href="#Symmetric-cryptography">Symmetric cryptography</a></li>
<li><a href="#index-symmetric-encryption-algorithms-7">symmetric encryption algorithms</a>: <a href="#Encryption-algorithms-used-in-the-record-layer">Encryption algorithms used in the record layer</a></li>
<li><a href="#index-thread-safety-55">thread safety</a>: <a href="#Thread-safety">Thread safety</a></li>
<li><a href="#index-tickets-23">tickets</a>: <a href="#Session-tickets">Session tickets</a></li>
<li><a href="#index-TLS-extensions-21">TLS extensions</a>: <a href="#Session-tickets">Session tickets</a></li>
<li><a href="#index-TLS-extensions-19">TLS extensions</a>: <a href="#Server-name-indication">Server name indication</a></li>
<li><a href="#index-TLS-extensions-17">TLS extensions</a>: <a href="#Maximum-fragment-length-negotiation">Maximum fragment length negotiation</a></li>
<li><a href="#index-TLS-extensions-16">TLS extensions</a>: <a href="#TLS-Extensions">TLS Extensions</a></li>
<li><a href="#index-TLS-layers-3">TLS layers</a>: <a href="#TLS-layers">TLS layers</a></li>
<li><a href="#index-transport-layer-5">transport layer</a>: <a href="#The-transport-layer">The transport layer</a></li>
<li><a href="#index-transport-protocol-4">transport protocol</a>: <a href="#The-transport-layer">The transport layer</a></li>
<li><a href="#index-verifying-certificate-paths-31">verifying certificate paths</a>: <a href="#Verifying-a-certificate-in-the-context-of-TLS-session">Verifying a certificate in the context of TLS session</a></li>
<li><a href="#index-verifying-certificate-paths-30">verifying certificate paths</a>: <a href="#Verifying-X_002e509-certificate-paths">Verifying X.509 certificate paths</a></li>
<li><a href="#index-X_002e509-certificates-29">X.509 certificates</a>: <a href="#X_002e509-certificates">X.509 certificates</a></li>
<li><a href="#index-X_002e509-Functions-309">X.509 Functions</a>: <a href="#X509-certificate-API">X509 certificate API</a></li>
</ul><div class="footnote">
<hr>
<a name="texinfo-footnotes-in-document"></a><h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> <a href="http://www.gnu.org/software/libtasn1/">http://www.gnu.org/software/libtasn1/</a></p>

<p class="footnote"><small>[<a name="fn-2" href="#fnd-2">2</a>]</small> <a href="http://www.lysator.liu.se/~nisse/nettle/">http://www.lysator.liu.se/~nisse/nettle/</a></p>

<p class="footnote"><small>[<a name="fn-3" href="#fnd-3">3</a>]</small> IETF, or Internet Engineering Task Force,
is a large open international community of network designers,
operators, vendors, and researchers concerned with the evolution of
the Internet architecture and the smooth operation of the Internet. 
It is open to any interested individual.</p>

<p class="footnote"><small>[<a name="fn-4" href="#fnd-4">4</a>]</small> MAC stands for Message Authentication Code. It can be described as a keyed hash algorithm. See RFC2104.</p>

<p class="footnote"><small>[<a name="fn-5" href="#fnd-5">5</a>]</small> See also the Server Name Indication extension on
<a href="#serverind">serverind</a>.</p>

<p class="footnote"><small>[<a name="fn-6" href="#fnd-6">6</a>]</small> See LDAP, IMAP etc.</p>

<p class="footnote"><small>[<a name="fn-7" href="#fnd-7">7</a>]</small> <a href="http://www.gnupg.org/related_software/gpgme/">http://www.gnupg.org/related_software/gpgme/</a></p>

<p class="footnote"><small>[<a name="fn-8" href="#fnd-8">8</a>]</small> See
<a href="http://srp.stanford.edu/">http://srp.stanford.edu/</a>.</p>

<p class="footnote"><small>[<a name="fn-9" href="#fnd-9">9</a>]</small> <a href="http://www.opensc-project.org">http://www.opensc-project.org</a></p>

<p class="footnote"><small>[<a name="fn-10" href="#fnd-10">10</a>]</small> <a href="http://trousers.sourceforge.net/">http://trousers.sourceforge.net/</a></p>

<p class="footnote"><small>[<a name="fn-11" href="#fnd-11">11</a>]</small> <a href="http://p11-glue.freedesktop.org/">http://p11-glue.freedesktop.org/</a></p>

<p class="footnote"><small>[<a name="fn-12" href="#fnd-12">12</a>]</small> The first message in a <acronym>TLS</acronym> handshake</p>

<p class="footnote"><small>[<a name="fn-13" href="#fnd-13">13</a>]</small> It depends on the group used.  Primes with
lesser bits are always faster, but also easier to break.  See <a href="#Selecting-cryptographic-key-sizes">Selecting cryptographic key sizes</a>
for the acceptable security levels.</p>

<p class="footnote"><small>[<a name="fn-14" href="#fnd-14">14</a>]</small> A key of 128 bits or 16 bytes should be sufficient for this purpose.</p>

<p class="footnote"><small>[<a name="fn-15" href="#fnd-15">15</a>]</small> To avoid collisions in order to specify a compression algorithm in
this string you have to prefix it with "COMP-", protocol versions
with "VERS-", signature algorithms with "SIGN-" and certificate types with "CTYPE-". All other
algorithms don't need a prefix.</p>

<p class="footnote"><small>[<a name="fn-16" href="#fnd-16">16</a>]</small> such as the
<code>gnutls_certificate_credentials_t</code> structures</p>

<p class="footnote"><small>[<a name="fn-17" href="#fnd-17">17</a>]</small> Check <a href="http://home.gna.org/cryptodev-linux/">http://home.gna.org/cryptodev-linux/</a>
for the Linux kernel implementation of <code>/dev/crypto</code>.</p>

<hr></div>

</body></html>

